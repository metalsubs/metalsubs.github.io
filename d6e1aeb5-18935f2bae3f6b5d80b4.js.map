{"version":3,"sources":["webpack:///./node_modules/video.js/dist/video.es.js"],"names":["history","log","createLogger","name","logByType","level","_len","arguments","length","args","Array","_key","type","lvl","levels","lvlRegExp","RegExp","unshift","toUpperCase","push","concat","splice","console","fn","info","test","isArray","LogByTypeFactory","subname","all","off","debug","warn","error","DEFAULT","hasOwnProperty","Error","filter","fname","historyItem","clear","disable","enable","_len2","_key2","_len3","_key3","_len4","_key4","createLogger$1","toString","Object","prototype","keys","object","isObject","each","forEach","key","assign","target","sources","apply","source","value","isPlain","call","constructor","computedStyle","el","prop","getComputedStyle","computedStyleValue","getPropertyValue","isNonBlankString","str","Boolean","trim","throwIfWhitespace","indexOf","isReal","document","isEl","nodeType","isInFrame","parent","self","x","createQuerier","method","selector","context","querySelector","ctx","createEl","tagName","properties","attributes","content","createElement","getOwnPropertyNames","propName","val","setAttribute","textContent","attrName","appendContent","text","innerText","prependTo","child","firstChild","insertBefore","appendChild","hasClass","element","classToCheck","classList","contains","className","addClass","classToAdd","add","removeClass","classToRemove","remove","split","c","join","toggleClass","classToToggle","predicate","has","setAttributes","attrValue","removeAttribute","getAttributes","tag","obj","knownBooleans","attrs","i","attrVal","getAttribute","attribute","blockTextSelection","body","focus","onselectstart","unblockTextSelection","getBoundingClientRect","parentNode","rect","result","k","undefined","height","parseFloat","width","findPosition","offsetParent","left","top","offsetWidth","offsetHeight","offsetLeft","offsetTop","getPointerPosition","event","position","boxTarget","box","boxW","boxH","offsetY","offsetX","changedTouches","pageX","pageY","y","Math","max","min","isTextNode","emptyEl","removeChild","normalizeContent","map","createTextNode","node","insertContent","isSingleLeftClick","button","buttons","videojs","$","$$","Dom","freeze","__proto__","_windowLoaded","autoSetup","options","vids","slice","getElementsByTagName","audios","divs","mediaEls","e","mediaEl","autoSetupTimeout","player","wait","vjs","setTimeout","setWindowLoaded","removeEventListener","readyState","addEventListener","FakeWeakMap","createStyleElement","style","setTextContent","styleSheet","cssText","_guid","newGUID","WeakMap","this","vdata","floor","performance","now","Date","data","_proto","set","access","get","_supportsPassive","DomData","_cleanUpEvents","elem","handlers","dispatcher","detachEvent","disabled","_handleMultipleEvents","types","callback","fixEvent","fixed_","returnTrue","returnFalse","isPropagationStopped","old","preventDefault","srcElement","relatedTarget","fromElement","toElement","returnValue","defaultPrevented","stopPropagation","cancelBubble","stopImmediatePropagation","isImmediatePropagationStopped","clientX","doc","documentElement","scrollLeft","clientLeft","clientY","scrollTop","clientTop","which","charCode","keyCode","passiveEvents","on","guid","hash","handlersCopy","m","n","opts","defineProperty","supportsPassive","passive","attachEvent","removeType","t","trigger","elemData","ownerDocument","bubbles","targetData","one","func","any","EVENT_MAP","Events","bind","uid","bound","throttle","last","EventTarget","allowedEvents_","ael","dispatchEvent","queueTrigger","_this","Map","oldTimeout","clearTimeout","timeout","size","isEvented","eventBusEl_","every","isValidEventType","validateTarget","nodeName","validateEventType","validateListener","listener","normalizeListenArgs","isTargetingSelf","shift","listen","EventedMixin","_normalizeListenArgs","removeListenerOnDispose","removeRemoverOnTargetDispose","_this2","_normalizeListenArgs2","wrapper","largs","_this3","_normalizeListenArgs3","_len5","_key5","targetOrType","typeOrListener","evented","eventBusKey","eventedCallbacks","StatefulMixin","state","setState","stateUpdates","changes","from","to","stateful","defaultState","handleStateChanged","toLowerCase","string","replace","w","toTitleCase","mergeOptions","MapSham","map_","set_","thisArg","Map$1","SetSham","Set","Component","ready","play","player_","isDisposed_","parentComponent_","options_","id_","id","name_","el_","children_","childIndex_","childNameIndex_","setTimeoutIds_","setIntervalIds_","rafIds_","namedRafs_","clearingTimersOnDispose_","initChildren","reportTouchActivity","enableTouchActivity","dispose","isDisposed","localize","tokens","defaultValue","code","language","languages","primaryCode","primaryLang","localizedString","match","index","ret","contentEl","contentEl_","children","getChildById","getChild","getDescendant","names","reduce","acc","currentChild","addChild","component","componentName","componentClassName","componentClass","ComponentClass","getComponent","refNode","childFound","compEl","workingChildren","parentOptions","Tech","some","wchild","isTech","playerOptions","newChild","buildCSSClass","sync","isReady_","readyQueue_","triggerReady","readyQueue","show","hide","lockShowing","unlockShowing","num","skipListeners","dimension","dimensions","widthOrHeight","pxIndex","parseInt","currentDimension","computedWidthOrHeight","isNaN","rule","currentDimensions","currentWidth","currentHeight","blur","handleKeyDown","handleKeyPress","emitTapEvents","couldBeTap","touchStart","firstTouch","touches","xdiff","ydiff","sqrt","noTap","reportUserActivity","touchHolding","report","clearInterval","setInterval","touchEnd","timeoutId","clearTimersOnDispose_","interval","intervalId","requestAnimationFrame","supportsRaf_","requestNamedAnimationFrame","_this4","cancelNamedAnimationFrame","cancelAnimationFrame","_this5","_ref","idName","cancelName","registerComponent","ComponentToRegister","reason","isComp","isPrototypeOf","components_","Player","players","playerNames","pname","USER_AGENT","navigator","userAgent","webkitVersionMap","exec","appleWebkitVersion","pop","IS_IPOD","IOS_VERSION","IS_ANDROID","ANDROID_VERSION","major","minor","IS_NATIVE_ANDROID","IS_FIREFOX","IS_EDGE","IS_CHROME","CHROME_VERSION","IE_VERSION","version","IS_SAFARI","IS_WINDOWS","TOUCH_ENABLED","maxTouchPoints","DocumentTouch","IS_IPAD","IS_IPHONE","IS_IOS","IS_ANY_SAFARI","browser","getRange","fnName","valueIndex","ranges","rangeIndex","maxIndex","rangeCheck","createTimeRangesObj","start","end","createTimeRanges","bufferedPercent","buffered","duration","bufferedDuration","browserApi","FullscreenApi","prefixed","apiMap","specApi","_i","MediaError","message","defaultMessages","status","errorTypes","1","2","3","4","5","errNum","isPromise","then","silencePromise","trackToJson_","track","cues","cue","startTime","endTime","textTrackConverter","tech","trackEls","trackObjs","trackEl","json","src","textTracks","addedTrack","addRemoteTextTrack","addCue","ModalDialog","_Component","opened_","hasBeenOpened_","hasBeenFilled_","closeable","uncloseable","MODAL_CLASS_NAME","role","descEl_","description","tabIndex","label","previouslyActiveEl_","desc","open","fillAlways","fill","wasPlaying_","paused","pauseOnOpen","pause","hadControls_","controls","conditionalFocus_","opened","close","conditionalBlur_","temporary","closeable_","temp","controlText","fillWith","parentEl","nextSiblingEl","nextSibling","empty","closeButton","content_","activeEl","activeElement","playerEl","isEventKey","focusIndex","focusableEls","focusableEls_","shiftKey","allChildren","querySelectorAll","HTMLAnchorElement","HTMLAreaElement","hasAttribute","HTMLInputElement","HTMLSelectElement","HTMLTextAreaElement","HTMLButtonElement","HTMLIFrameElement","HTMLObjectElement","HTMLEmbedElement","TrackList","_EventTarget","tracks","tracks_","addTrack","removeTrack","rtrack","l","getTrackById","change","addtrack","removetrack","disableOthers","list","enabled","AudioTrackList","_TrackList","changing_","enabledChange_","disableOthers$1","selected","VideoTrackList","selectedChange_","TextTrackList","queueChange_","triggerSelectedlanguagechange","triggerSelectedlanguagechange_","kind","selectedlanguagechange_","HtmlTrackElementList","trackElements","trackElements_","addTrackElement_","trackElement","getTrackElementByTrack_","trackElement_","removeTrackElement_","TextTrackCueList","setCues_","length_","oldLength","cues_","defineProp","getCueById","VideoTrackKind","alternative","captions","main","sign","subtitles","commentary","AudioTrackKind","TextTrackKind","descriptions","chapters","metadata","TextTrackMode","hidden","showing","Track","trackProps","_loop","parseUrl","url","props","a","href","div","addToBody","host","protocol","innerHTML","details","location","getAbsoluteURL","getFileExtension","path","pathParts","isCrossOrigin","winLoc","urlInfo","Url","parseCues","srcContent","parser","WebVTT","Parser","vttjs","StringDecoder","errors","oncue","onparsingerror","onflush","parse","groupCollapsed","groupEnd","flush","loadTrack","uri","crossOrigin","cors","withCredentials","tech_","err","response","responseBody","loaded_","TextTrack","_Track","settings","srclang","mode","default_","activeCues_","preload_","preloadTextTracks","activeCues","changed","timeupdateHandler","defineProperties","newMode","ct","currentTime","active","originalCue","VTTCue","originalCue_","removeCue","_removeCue","cuechange","AudioTrack","newEnabled","VideoTrack","newSelected","HTMLTrackElement","load","NONE","LOADING","LOADED","ERROR","NORMAL","audio","ListClass","TrackClass","capitalName","video","getterName","privateName","REMOTE","remoteText","remoteTextEl","ALL","hasStarted_","featuresProgressEvents","manualProgressOn","featuresTimeupdateEvents","manualTimeUpdatesOn","nativeCaptions","nativeTextTracks","featuresNativeTextTracks","emulateTextTracks","autoRemoteTextTracks_","initTrackListeners","nativeControlsForTouch","triggerSourceset","onDurationChange","manualProgress","trackProgress","manualProgressOff","stopTrackingProgress","progressInterval","numBufferedPercent","bufferedPercent_","duration_","manualTimeUpdates","trackCurrentTime","stopTrackingCurrentTime","manualTimeUpdatesOff","currentTimeInterval","manuallyTriggered","clearTracks","removeRemoteTextTrack","cleanupAutoTextTracks","reset","setCrossOrigin","error_","played","setScrubbing","setCurrentTime","trackListChanges","addWebVttScript_","script","onload","onerror","_this6","remoteTracks","remoteTextTracks","handleAddTrack","handleRemoveTrack","updateDisplay","textTracksChanges","addTextTrack","createTrackHelper","createRemoteTextTrack","manualCleanup","_this7","htmlTrackElement","remoteTextTrackEls","getVideoPlaybackQuality","requestPictureInPicture","PromiseClass","Promise","reject","disablePictureInPicture","setDisablePictureInPicture","setPoster","playsinline","setPlaysinline","overrideNativeAudioTracks","overrideNativeVideoTracks","canPlayType","canPlaySource","srcObj","registerTech","techs_","defaultTechOrder_","getTech","featuresVolumeControl","featuresMuteControl","featuresFullscreenResize","featuresPlaybackRate","featuresSourceset","withSourceHandlers","_Tech","registerSourceHandler","handler","sourceHandlers","can","selectSourceHandler","canHandleSource","sh","originalFn","sourceHandler_","setSource","nativeSourceHandler","disposeSourceHandler","currentSource_","handleSource","middlewares","middlewareInstances","TERMINATOR","next","setSourceHelper","middleware","lastRun","_middleware","mwFactory","mwrest","mw","mws","_mws$i","mwf","mwi","getOrCreateFactory","_src","mediate","arg","callMethod","middlewareValue","middlewareIterator","terminated","executeRight","allowedGetters","muted","seekable","volume","allowedSetters","setMuted","setVolume","allowedMediators","MimetypesKind","opus","ogv","mp4","mov","m4v","mkv","m4a","mp3","aac","caf","flac","oga","wav","m3u8","jpg","jpeg","gif","png","svg","webp","getMimetype","ext","fixSource","mimetype","MediaLoader","j","techOrder","techName","isSupported","loadTech_","ClickableComponent","tabIndex_","createControlTextEl","controlTextEl_","controlText_","localizedText","nonIconControl","enabled_","handleClick","handleMouseOver","handleMouseOut","clickHandler","PosterImage","_ClickableComponent","update","poster","setSrc","backgroundImage","sourceIsEncrypted","usingPlugin","eme","sessions","fontMap","monospace","sansSerif","serif","monospaceSansSerif","monospaceSerif","proportionalSansSerif","proportionalSerif","casual","smallcaps","constructColor","color","opacity","hex","tryUpdateStyle","TextTrackDisplay","updateDisplayHandler","toggleDisplay","preselectTrack","firstDesc","firstCaptions","preferredTrack","modes","trackList","userPref","cache_","selectedLanguage","clearDisplay","processCues","allowMultipleShowingTracks","showingTracks","updateForTrack","descriptionsTrack","captionsSubtitlesTrack","_track","updateDisplayState","overrides","textTrackSettings","getValues","cueDiv","displayState","textOpacity","backgroundColor","backgroundOpacity","windowColor","windowOpacity","edgeStyle","textShadow","fontPercent","fontSize","fontFamily","fontVariant","_i2","_track2","_j","cueEl","LoadingSpinner","isAudio","playerType","dir","Button","BigPlayButton","_Button","mouseused_","handleMouseDown","playPromise","cb","playToggle","playFocus","CloseButton","PlayToggle","replay","handlePlay","handlePause","handleEnded","handleSeeked","defaultImplementation","seconds","guide","s","h","gm","gh","Infinity","implementation","formatTime","TimeDisplay","updateContent","updateTextNode_","labelText_","textNode_","time","formattedTime_","oldNode","replaceChild","CurrentTimeDisplay","_TimeDisplay","ended","scrubbing","getCache","DurationDisplay","TimeDivider","RemainingTimeDisplay","remainingTimeDisplay","remainingTime","LiveDisplay","updateShowing","SeekToLive","updateLiveEdgeStatus","liveTracker","textEl_","atLiveEdge","seekToLiveEdge","clamp","number","Number","Slider","bar","barName","vertical","playerEvent","handleMouseMove","handleMouseUp","progress","getProgress","progress_","sizeKey","toFixed","getPercent","calculateDistance","stepBack","stepForward","bool","vertical_","percentify","LoadProgressBar","partEls_","loadedText","separator","percentageEl_","isLive","seekableEnd","bufferedEnd","percent","percent_","part","dataset","TimeTooltip","seekBarRect","seekBarPoint","tooltipRect","playerRect","seekBarPointPx","spaceLeftOfPoint","spaceRightOfPoint","right","pullTooltipBy","write","updateTime","liveWindow","secondsBehind","PlayProgressBar","timeTooltip","MouseTimeDisplay","SeekBar","_Slider","setEventHandlers_","update_","updateInterval","enableInterval_","disableInterval_","toggleVisibility_","getCurrentTime_","liveCurrentTime","currentTime_","seekableStart","videoWasPlaying","newTime","distance","mouseTimeDisplay","handleAction","gotoFraction","codes","STEP_SECONDS","ProgressControl","throttledHandleMouseSeek","handleMouseSeek","seekBar","playProgressBar","seekBarEl","PictureInPictureToggle","handlePictureInPictureChange","handlePictureInPictureEnabledChange","pictureInPictureEnabled","isInPictureInPicture","exitPictureInPicture","FullscreenToggle","handleFullscreenChange","fsApi_","fullscreenEnabled","isFullscreen","exitFullscreen","requestFullscreen","VolumeLevel","VolumeBar","updateLastVolume_","updateARIAAttributes","checkMuted","ariaValue","volumeAsPercentage_","round","volumeBeforeDrag","lastVolume_","VolumeControl","volumeBar","checkVolumeSupport","throttledHandleMouseMove","orientationClass","MuteToggle","checkMuteSupport","vol","lastVolume","volumeToSet","updateIcon_","updateControlText_","VolumePanel","inline","volumeControl","volumePanelState_","muteToggle","handleVolumeControlKeyUp","sliderActive_","sliderInactive_","Menu","menuButton_","menuButton","focusedChild_","boundHandleBlur_","handleBlur","boundHandleTapClick_","handleTapClick","addEventListenerForItem","removeEventListenerForItem","addItem","childComponent","contentElType","append","btn","buttonPressed_","unpressButton","childComponents","foundComponent","stepChild","item","MenuButton","buttonClass","menu","handleMenuKeyUp","handleMouseLeave","handleSubmenuKeyDown","createMenu","items","hideThreshold_","title","titleEl","titleComponent","createItems","buildWrapperCSSClass","menuButtonClass","pressButton","handleSubmenuKeyPress","TrackButton","_MenuButton","updateHandler","MenuKeys","MenuItem","selectable","isSelected_","multiSelectable","_selected","TextTrackMenuItem","_MenuItem","kinds","changeHandler","handleTracksChange","selectedLanguageChangeHandler","handleSelectedLanguageChange","onchange","Event","createEvent","initEvent","referenceTrack","shouldBeSelected","OffTextTrackMenuItem","_TextTrackMenuItem","allHidden","TextTrackButton","_TrackButton","TrackMenuItem","label_","kinds_","kind_","ChaptersTrackMenuItem","ChaptersButton","_TextTrackButton","track_","setTrack","findChaptersTrack","updateHandler_","remoteTextTrackEl","_remoteTextTrackEl","getMenuCaption","mi","DescriptionsButton","SubtitlesButton","CaptionSettingsMenuItem","CaptionsButton","SubsCapsMenuItem","SubsCapsButton","language_","AudioTrackMenuItem","audioTracks","AudioTrackButton","PlaybackRateMenuItem","rate","playbackRate","PlaybackRateMenuButton","updateVisibility","updateLabel","labelEl_","rates","playbackRates","currentRate","newRate","playbackRateSupported","Spacer","CustomControlSpacer","_Spacer","ControlBar","ErrorDisplay","_ModalDialog","COLOR_BLACK","COLOR_BLUE","COLOR_CYAN","COLOR_GREEN","COLOR_MAGENTA","COLOR_RED","COLOR_WHITE","COLOR_YELLOW","OPACITY_OPAQUE","OPACITY_SEMI","OPACITY_TRANS","selectConfigs","v","parseOptionValue","TextTrackSettings","endDialog","setDefaults","persistTextTrackSettings","saveSettings","config","restoreSettings","createElSelect_","legendId","selectLabelledbyIds","o","optionId","createElFgColor_","createElBgColor_","createElWinColor_","createElColors_","createElFont_","createElControls_","defaultsDescription","initial","accum","selectedIndex","setValues","values","setSelectedOption","JSON","localStorage","getItem","setItem","stringify","removeItem","ttDisplay","controlBar","subsCapsBtn","subsCapsButton","ccBtn","captionsButton","ResizeManager","RESIZE_OBSERVER_AVAILABLE","ResizeObserver","loadListener_","resizeObserver_","debouncedHandler_","immediate","debounced","_later","cancel","debounce","resizeHandler","observe","contentWindow","unloadListener_","unobserve","disconnect","resizeObserver","defaults","trackingThreshold","liveTolerance","LiveTracker","reset_","handleDurationchange","handleVisibilityChange","stopTracking","startTracking","trackLive_","deltaTime","lastTime_","pastSeekEnd_","pastSeekEnd","isBehind","seekedBehindLive_","abs","timeupdateSeen_","behindLiveEdge_","liveui","isTracking","hasStarted","trackingInterval_","handleFirstTimeupdate","timeDiff","skipNextSeeked_","lastSeekEnd_","seekableEnds","sort","seekableStarts","behindLiveEdge","sourcesetLoad","srcUrls","innerHTMLDescriptorPolyfill","cloneNode","dummy","docFrag","createDocumentFragment","childNodes","Element","getDescriptor","priority","descriptor","getOwnPropertyDescriptor","enumerable","configurable","firstSourceWatch","resetSourceWatch_","innerDescriptor","HTMLMediaElement","getInnerHTMLDescriptor","appendWrapper","appendFn","retval","srcDescriptorPolyfill","setupSourceset","resetSourceset_","srcDescriptor","getSrcDescriptor","oldSetAttribute","oldLoad","currentSrc","defineLazyProperty","getValue","setter","writable","Html5","crossoriginTracks","initNetworkState_","handleLateInit_","enableSourceset","setupSourcesetHandling_","hasChildNodes","nodes","nodesLength","removeNodes","proxyNativeTracks_","restoreMetadataTracksInIOSNativePlayer_","setControls","proxyWebkitFullscreen_","disposeMediaElement","metadataTracksPreFullscreenState","takeMetadataTrackSnapshot","storedMode","restoreTrackMode","storedTrack","overrideNative_","override","lowerCaseType","eventName","proxyNativeTracksForType_","elTracks","techTracks","listeners","currentTarget","removeOldTracks","removeTracks","found","playerElIngest","movingMediaElementInDOM","clone","techId","playerId","preload","settingsAttrs","attr","networkState","loadstartFired","setLoadstartFired","triggerLoadstart","eventsToTrigger","isScrubbing","isScrubbing_","fastSeek","checkProgress","NaN","endFn","beginFn","webkitPresentationMode","nativeIOSFullscreen","supportsFullScreen","webkitEnterFullScreen","enterFullScreen","HAVE_METADATA","exitFullScreen","webkitDisplayingFullscreen","webkitExitFullScreen","resetMediaElement","videoPlaybackQuality","webkitDroppedFrameCount","webkitDecodedFrameCount","droppedVideoFrames","totalVideoFrames","creationTime","timing","navigationStart","TEST_VID","canControlVolume","canMuteVolume","canControlPlaybackRate","canOverrideAttributes","noop","supportsNativeTextTracks","supportsNativeVideoTracks","videoTracks","supportsNativeAudioTracks","patchCanPlayType","unpatchCanPlayType","r","TECH_EVENTS_RETRIGGER","TECH_EVENTS_QUEUE","canplay","canplaythrough","playing","seeked","BREAKPOINT_ORDER","BREAKPOINT_CLASSES","charAt","substring","DEFAULT_BREAKPOINTS","tiny","xsmall","small","medium","large","xlarge","huge","getTagSettings","closest","boundDocumentFullscreenChange_","documentFullscreenChange_","boundFullWindowOnEscKey_","fullWindowOnEscKey","isFullscreen_","isPosterFromTech_","queuedCallbacks_","userActive_","debugEnabled_","tagAttributes","languagesToLower","languages_","resetCache_","poster_","controls_","changingSrc_","playCallbacks_","playTerminatedQueue_","autoplay","plugins","scrubbing_","fullscreenchange","fluid_","updateStyleEl_","playerOptionsCopy","middleware_","flexNotSupported_","majorVersion","userActive","listenForUserActivity_","handleStageClick_","breakpoints","responsive","styleEl_","playerElIngest_","divEmbed","tabindex","VIDEOJS_NO_DYNAMIC_STYLE","defaultsStyleEl","head","fill_","fluid","aspectRatio","crossorigin","links","linkEl","techGet_","techCall_","_dimension","privDimension","parsedVal","ratio","aspectRatio_","idClass","ratioParts","videoWidth","videoHeight","ratioMultiplier","width_","height_","_width","_height","techEl","unloadTech_","titleTechName","camelTechName","techName_","techOptions","loop","techCanOverridePoster","TechClass","handleTechReady_","textTracksJson_","eventObj","seeking","handleTechLoadStart_","handleTechSourceset_","handleTechWaiting_","handleTechEnded_","handleTechSeeking_","handleTechPlay_","handleTechFirstPlay_","handleTechPause_","handleTechDurationChange_","handleTechFullscreenChange_","handleTechFullscreenError_","handleTechEnterPictureInPicture_","handleTechLeavePictureInPicture_","handleTechError_","handleTechPosterChange_","handleTechTextData_","handleTechRateChange_","usingNativeControls","addTechControlsListeners_","safety","removeTechControlsListeners_","handleTechClick_","handleTechDoubleClick_","handleTechTouchStart_","handleTechTouchMove_","handleTechTouchEnd_","handleTechTap_","manualAutoplay_","promise","previouslyMuted","restoreMuted","mutedPromise","updateSourceCaches_","matchingSources","findMimetype","sourceElSources","sourceEls","matchingSourceEls","sourceObj","updateSourceCaches","playerSrc","currentSource","eventSrc","lastSource_","techSrc","techGet","request","lastPlaybackRate","queued","timeWhenWaiting","timeUpdateListener","handleTechCanPlay_","handleTechCanPlayThrough_","handleTechPlaying_","handleTechSeeked_","starttime","userActions","doubleClick","userWasActive","toggleFullscreenClass_","targetPlayer","isFs","fullscreenElement","matches","fullscreen","msMatchesSelector","togglePictureInPictureClass_","initTime","inactivityTimeout","defaultPlaybackRate","media","reduceRight","_this8","resolve","play_","_this9","isSrcReady","waitToPlay_","runPlayTerminatedQueue_","runPlayCallbacks_","queue","q","callbacks","applyInitTime_","percentAsDecimal","_muted","defaultMuted","_defaultMuted","isFS","oldValue","fullscreenOptions","offHandler","errorHandler","requestFullscreenHelper_","fsOptions","_this10","enterFullWindow","exitFullscreenHelper_","_this11","exitFullWindow","isFullWindow","docOrigOverflow","overflow","isPiP","isInPictureInPicture_","hotkeys","isContentEditable","excludeElement","handleHotkeys","_hotkeys$fullscreenKe","fullscreenKey","keydownEvent","_hotkeys$muteKey","muteKey","_hotkeys$playPauseKey","playPauseKey","FSToggle","selectSource","_this12","techs","findFirstPassingTechSourcePair","outerArray","innerArray","tester","outerChoice","innerChoice","finder","_ref2","sourceOrder","b","_this13","filterSource","newsrc","srcobj","middlewareSource","src_","notSupportedMessage","setTech","str1","str2","_this14","sourceTech","_this15","doReset_","resetControlBarUI_","resetProgressBar_","resetPlaybackRate_","resetVolumeBar_","_this$controlBar","durationDisplay","currentSources","currentType","techAutoplay","newPoster","usingNativeControls_","suppressNotSupportedError","triggerSuppressedError","errorDisplay","userActivity_","mouseInProgress","lastMoveX","lastMoveY","handleActivity","handleMouseUpAndMouseLeave","screenX","screenY","isAudio_","String","toJSON","createModal","_this16","modal","updateCurrentBreakpoint_","currentBreakpoint","candidateBreakpoint","breakpoints_","breakpoint_","removeCurrentBreakpoint_","currentBreakpointClass","_breakpoints","responsive_","loadMedia","_this17","_this$cache_$media","artwork","tt","getMedia","baseOptions","tagOptions","dataSetup","_safeParseTuple","childName","previousLogLevel_","html5","flash","userLanguage","navigationUI","pluginStorage","pluginExists","getPlugin","markPluginAsActive","triggerSetupEvent","before","createPluginFactory","PluginSubClass","plugin","instance","getEventHash","Plugin","VERSION","isBasic","p","registerPlugin","basicPluginWrapper","createBasicPlugin","deregisterPlugin","getPlugins","getPluginVersion","BASE_PLUGIN_NAME","hasPlugin","normalizeId","videojs$1","getPlayer","TypeError","defaultView","hooks","hookFunction","PlayerComponent","hooks_","hook","hookOnce","original","removeHook","getPlayers","nId","_tag","_player","getAllPlayers","comp","use","writeable","extend","superClass","subClassMethods","subClass","methods","super_","addLanguage","_mergeOptions","createTimeRange","setFormatTime","customImplementation","resetFormatTime","xhr","dom","currentTransmux","resolveUrl","resolveManifestRedirect","handleManifestRedirect","req","responseURL","log$1","createPlaylistID","parseManifest","manifestString","_ref$customTagParsers","customTagParsers","_ref$customTagMappers","customTagMappers","customParser","addParser","mapper","addTagMapper","manifest","forEachMediaGroup","master","mediaType","groupKey","mediaGroups","labelKey","mediaProperties","setupMediaPlaylist","playlist","addPropertiesToMaster","playlists","phonyUri","resolvedUri","BANDWIDTH","setupMediaPlaylists","resolveMediaGroupUris","mergeOptions$1","EventTarget$1","resolveSegmentUris","segment","baseUri","updateMaster","segments","endList","mediaSequence","mergedPlaylist","offset","updateSegments","refreshDelay","lastSegment","targetDuration","PlaylistLoader","vhs","_options","_options$withCredenti","_options$handleManife","handleManifestRedirects","vhs_","vhsOptions","playlistRequestError","haveMetadata","playlistString","responseText","startingState","playlistObject","media_","mediaUpdateTimeout","stopRequest","finalRenditionTimeout","oldRequest","onreadystatechange","abort","isFinalRendition","delay","mediaChange","started","setupInitialPlaylist","srcUri","masterForMedia","filterRanges","timeRanges","results","findRange","TIME_FUDGE_FACTOR","findNextRange","printableRange","range","strArr","timeRangesToArray","timeRangesList","intervalDuration","endSequence","expired","backward","precise","backwardDuration","forward","forwardDuration","totalDuration","sumDurations","startIndex","endIndex","durations","safeLiveIndex","liveEdgePadding","lastSegmentDuration","safeDistance","distanceFromEnd","playlistEnd","useSafeLiveEnd","isBlacklisted","excludeUntil","isIncompatible","isEnabled","blacklisted","isLowestEnabledRendition","currentBandwidth","MAX_VALUE","Playlist","getMediaInfoForTime","numSegments","mediaIndex","isDisabled","isAes","estimateSegmentRequestTime","segmentDuration","bandwidth","bytesReceived","videojsXHR","mergeOptions$1$1","callbackWrapper","reqResponse","responseType","responseTime","roundTripTime","requestTime","byteLength","headers","responseHeaders","timedout","aborted","statusCode","xhrFactory","XhrFunction","beforeRequest","Vhs","newOptions","originalAbort","segmentXhrHeaders","byterange","byterangeEnd","Range","textRange","formatHexString","formatAsciiString","fromCharCode","createTransferableMessage","transferable","ArrayBuffer","isView","bytes","buffer","byteOffset","initSegmentId","initSegment","segmentKeyId","hexDump","utils","tagDump","textRanges","getProgramTime","_ref$time","matchedSegment","segmentEnd","videoTimingInfo","transmuxedPresentationEnd","estimatedStart","transmuxedPresentationStart","findSegmentForPlayerTime","seekTime","programTimeObject","mediaSeconds","programTime","playerTime","dateTimeObject","transmuxerPrependedSeconds","offsetFromSegmentStart","getTime","playerTimeToProgramTime","programDateTime","toISOString","seekToProgramTime","_ref2$retryCount","retryCount","seekTo","_ref2$pauseAfterSeek","pauseAfterSeek","verifyProgramDateTimeTags","lastSegmentStart","findSegmentForProgramTime","mediaOffset","comparisonTimeStamp","segmentDateTime","segmentTimeEpoch","getOffsetFromTimestamp","seekToTime","callbackOnCompleted","EventTarget$1$1","mergeOptions$2","parseMasterXml","masterXml","srcUrl","clientOffset","sidxMapping","manifestUri","updateMaster$1","oldMaster","newMaster","noChanges","minimumUpdatePeriod","playlistUpdate","group","_playlistUpdate","generateSidxKey","sidxInfo","sidxByteRangeEnd","compareSidxEntry","oldSidxMapping","newSidxMapping","currentSidxInfo","sidx","savedSidxInfo","requestSidx_","loader","sidxRange","finishProcessingFn","sidxRequestOptions","id3Offset","finished","endRequestAndCallback","_bytes","progressListener","newPart","beforeSend","overrideMimeType","total","loaded","containerRequest","container","internal","blacklistDuration","_sidxInfo$byterange","subarray","DashPlaylistLoader","srcUrlOrPlaylist","masterPlaylistLoader","refreshXml_","refreshMedia_","loadedPlaylists_","sidxMapping_","setupChildLoader","masterPlaylistLoader_","childPlaylist_","minimumUpdatePeriodTimeout_","mediaRequest_","hasPendingRequest","sidxRequestFinished_","doneFn","sidxKey","haveMaster_","masterXml_","date","masterLoaded_","syncClientServerClock_","onClientServerClockSync_","done","utcTiming","clientOffset_","serverTime","updateMainManifest_","updateMinimumUpdatePeriodTimeout_","createMUPTimeout","mup","updatedManifest","locations","mediaGroupSidx","filterChangedSidxMappings","updatedMaster","mediaID","Config","GOAL_BUFFER_LENGTH","MAX_GOAL_BUFFER_LENGTH","BACK_BUFFER_LENGTH","GOAL_BUFFER_LENGTH_RATE","INITIAL_BANDWIDTH","BANDWIDTH_VARIANCE","BUFFER_LOW_WATER_LINE","MAX_BUFFER_LOW_WATER_LINE","BUFFER_LOW_WATER_LINE_RATE","stringToArrayBuffer","view","Uint8Array","charCodeAt","transmuxQueue","processTransmux","transmuxer","audioAppendStart","gopsToAlignWith","isPartial","remux","onData","onTrackInfo","onAudioTimingInfo","onVideoTimingInfo","onVideoSegmentTimingInfo","onId3","onCaptions","onDone","transmuxedData","onmessage","action","_event$data$segment","captionStreams","videoFrameDtsTime","videoFramePtsTime","boxes","handleData_","trackInfo","gopInfo","handleGopInfo_","audioTimingInfo","videoSegmentTimingInfo","id3Frame","dispatchType","caption","handleDone_","dequeue","postMessage","appendStart","processAction","enqueueAction","transmux","segmentTransmuxer","REQUEST_ERRORS","abortAll","activeXhrs","handleErrors","transmuxAndNotify","_ref3","trackInfoFn","timingInfoFn","videoSegmentTimingInfoFn","id3Fn","captionsFn","dataFn","fmp4Tracks","isMuxed","audioStartFn","audioEndFn","videoStartFn","videoEndFn","lastReachedChar","probeResult","baseStartTime","timeInfo","inspect","hasVideo","hasAudio","videoStart","ptsTime","audioStart","probeTsSegment","id3Frames","handleSegmentBytes","_ref4","bytesAsUint8Array","isFmp4","codec","audioCodec","videoCodec","timingInfo","timescales","finishLoading","listenForCaptions","trackIds","waitForCompletion","_ref6","decryptionWorker","count","didError","endOfAllRequests","encryptedBytes","_ref5","keyBytes","decryptionHandler","requestId","decrypted","Uint32Array","encrypted","iv","decryptSegment","handleProgress","_ref8","progressFn","handlePartialData","newBytes","stats","progressEvent","getProgressStats","firstBytesReceivedAt","mediaSegmentRequest","_ref9","xhrOptions","abortFn","keyXhr","errorObj","DataView","getUint32","handleKeyResponse","initSegmentXhr","timescale","handleInitSegmentResponse","segmentRequestOptions","xhrObject","segmentXhr","getRequestStats","handleSegmentResponse","loadendState","activeXhr","_ref7","calledAbortFn","handleLoadEnd","win","window","TARGET","Symbol","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","URL","webkitURL","msURL","Worker","shimWorker","filename","forceFallback","objURL","createSourceObject","worker","term","terminate","revokeObjectURL","wrapTerminate","selfShim","isThisThread","testWorker","testArray","createObjectURL","Blob","blob","getBlob","TransmuxWorker","Stream","init","pipe","destination","flushSource","partialFlush","endTimeline","dinf","esds","ftyp","mfhd","minf","moof","moov","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","videoSample","audioSample","audioTrun","videoTrun","trunHeader","stream","UINT32_MAX","pow","avc1","avcC","btrt","dref","mdat","mp4a","pasp","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","vmhd","payload","setUint32","audioobjecttype","samplingfrequencyindex","channelcount","samplerate","sequenceNumber","trackFragments","flags","samples","dependsOn","isDependedOn","hasRedundancy","avc1Box","sps","pps","sequenceParameterSets","pictureParameterSets","profileIdc","profileCompatibility","levelIdc","sarRatio","hSpacing","vSpacing","samplesize","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","baseMediaDecodeTime","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","bytesOffest","header","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","silence","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","audioTsToVideoTs","videoTsToAudioTs","metadataTsToSeconds","mp4Generator","fileType","movie","sampleForFrame","frame","dataOffset","pts","dts","keyFrame","frameUtils","nalUnits","currentNal","currentFrame","frames","nalCount","nalUnitType","currentGop","gops","baseDataOffset","nalsByteLength","numberOfNals","highPrefix","lowPrefix","zeroFill","silence_1","coneOfSilence","96000","88200","64000","48000","44100","32000","24000","16000","12000","11025","8000","metaTable","arr","timestamp","sampleRate","timelineStartPts","keepOriginalTimestamps","clock","clock_2","clock_4","audioFrameUtils","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","frameDuration","silentFrame","firstFrame","audioGapDuration","audioFillFrameCount","audioFillDuration","ceil","adtsFrames","earliestAllowedDts","minSegmentDts","minSegmentPts","array","sum","sumFrameByteLengths","ONE_SECOND_IN_TS$1","trackDecodeInfo","maxSegmentDts","maxSegmentPts","timelineStartInfo","captionPacketParser","payloadType","payloadSize","sei","userData","ccData","newLength","newData","emulationPreventionBytesPositions","sourceIndex","CaptionStream","captionPackets_","ccStreams_","Cea608Stream","cc","newCaptionPackets","escapedRBSP","latestDts_","ignoreNextEqualDts_","numSameDts_","flushCCStreams","flushType","flushStream","idx","presortIndex","packet","dispatchCea608Packet","activeCea608Channel_","ccStream","setsTextOrXDSActive","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION","getCharFromCode","ROWS","createDisplayBuffer","BOTTOM_ROW","field","dataChannel","field_","dataChannel_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","flushDisplayed","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","row","formatting_","isColorPAC","isNormalChar","startPts","endPts","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","_char","newBaseRow","format","reverse","popOn","baseRow","rollUp","paintOn","captionStream","streamTypes","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","handleRollover","reference","direction","TimestampRolloverStream","lastDTS","referenceDTS","type_","discontinuity","_MetadataStream","timestampRolloverStream","percentEncode","parseUtf8","decodeURIComponent","parseSyncSafeInteger","tagParsers","TXXX","WXXX","PRIV","owner","unescape","privateData","tagSize","bufferSize","chunk","frameStart","frameSize","dataAlignmentIndicator","d","timeStamp","_TransportPacketStream","_TransportParseStream","_ElementaryStream","metadataStream","TimestampRolloverStream$1","bytesInBuffer","everything","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","psi","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","tableEnd","streamType","pid","processPes_","STREAM_TYPES","h264","adts","timedMetadata","forceFlush","packetFlushable","fragment","packetData","trackId","pes","ptsDtsFlags","packetLength","flushStreams_","m2ts","PAT_PID","MP2T_PACKET_LENGTH","TransportPacketStream","TransportParseStream","ElementaryStream","MetadataStream","_AdtsStream","m2ts_1","ONE_SECOND_IN_TS$2","ADTS_SAMPLING_FREQUENCIES","handlePartialSegments","frameNum","frameLength","protectionSkipBytes","frameEnd","oldBuffer","sampleCount","adtsFrameDuration","_H264Stream","_NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","expGolomb","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","workingBytes","availableBytes","skipBits","skipBytes","readBits","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","syncPoint","swapBuffer","len","100","110","122","244","44","83","86","118","128","138","139","134","currentPts","currentDts","discardEmulationPreventionBytes","readSequenceParameterSet","skipScalingList","nalByteStream","expGolombDecoder","lastScale","nextScale","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","sarScale","_AacStream","H264Stream","NalByteStream","parseId3TagSize","byteIndex","returnSize","getId3Offset","lowThree","middle","setTimestamp","bytesLeft","tempLength","_VideoSegmentStream","_AudioSegmentStream","_Transmuxer","_CoalesceStream","audioProperties","videoProperties","H264Stream$1","isLikelyAacData$1","ONE_SECOND_IN_TS$3","arrayEquals","generateVideoSegmentTimingInfo","startDts","endDts","prependedContentDuration","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","dtsDistance","nearestGopObj","currentGopObj","nearestDistance","alignIndex","gopIndex","align","alignEndIndex","matchFound","trimIndex","alignGopsWith","newGopsToAlignWith","numberOfTracks","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","audioTrack","id3","cueTime","setRemux","hasFlushed","transmuxPipeline_","setupAacPipeline","pipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","audioSegmentStream","setupTsPipeline","packetStream","parseStream","elementaryStream","h264Stream","videoSegmentStream","setBaseMediaDecodeTime","isAac","resetCaptions","transmuxer_1","Transmuxer","VideoSegmentStream","AudioSegmentStream","AUDIO_PROPERTIES","VIDEO_PROPERTIES","codecs","Adts","ONE_SECOND_IN_TS$4","AudioSegmentStream$1","segmentStartPts","segmentEndPts","processFrames_","resetTiming_","VideoSegmentStream$1","frameCache","ensureNextFrameIsKeyFrame","processNals_","cacheLastFrame","sequence","videoFrameDts","videoFramePts","resetTimingAndConfig_","isLikelyAacData$2","createPipeline","setupPipelineListeners","Transmuxer$1","elementary","timestampRollover","tsPipeline","audioRollover","timedMetadataRollover","aacPipeline","transmuxer$1","bin","parseType_1","toUnsigned$1","findBox_1","findBox","subresults","toUnsigned$2","parseTfdt","parseSampleFlags_1","parseTrun","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","parseTfhd","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","discardEmulationPreventionBytes$1","CaptionStream$1","mapToSample","approximateOffset","parseCaptionNals","videoTrackId","trafs","mdats","captionNals","mdatTrafPairs","matchingTraf","pair","seiNals","headerInfo","truns","avcStream","seiNal","lastMatchedSample","avcView","matchingSample","findSeiNals","allSamples","parseSamples","captionParser","segmentCache","parsedCaptions","parsingPartial","isInitialized","isNewInit","videoTrackIds","parsedData","cachedSegment","parseEmbeddedCaptions","pushNals","nals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","typeFromStreamString","streamString","MessageHandlers","timingInfoInSeconds","wirePartialTransmuxerEvents","initArray","typedArray","decode","presentation","wireFullTransmuxerEvents","pushMp4Captions","parsed","clearAllMp4Captions","clearParsedMp4Captions","setTimestampOffset","timestampOffset","messageHandlers","isMaat","mediaAttributes","AUDIO","codecsForPlaylist","codecInfo","CODECS","getCodecs","audioGroup","groupId","defaultCodecs","logger","logFn","representationToString","representation","safeGetComputedStyle","property","stableSort","sortFn","newArray","cmp","comparePlaylistBandwidth","leftBandwidth","rightBandwidth","addMetadata","inbandTextTracks","metadataArray","videoDuration","Cue","WebKitDataCue","metadataTrack","metadataTrack_","deprecateOldCue","cuesArray","cuesGroupedByStartTime","timeSlot","sortedStartTimes","cueGroup","nextTime","removeCuesFromTrack","finite","isFinite","timingInfoPropertyForMedia","timestampOffsetForSegment","segmentTimeline","currentTimeline","startOfSegment","overrideCheck","shouldWaitForTimelineChange","timelineChangeController","loaderType","audioDisabled","lastMainTimelineChange","lastTimelineChange","pendingAudioTimelineChange","pendingTimelineChange","SegmentLoader","_videojs$EventTarget","mediaSource","throughput","roundTrip","resetStats_","hasPlayed_","hasPlayed","seekable_","seeking_","mediaSource_","loaderType_","currentMediaInfo_","startingMediaInfo_","segmentMetadataTrack_","segmentMetadataTrack","goalBufferLength_","goalBufferLength","sourceType_","sourceType","sourceUpdater_","sourceUpdater","inbandTextTracks_","state_","handlePartialData_","timelineChangeController_","shouldSaveSegmentTimingInfo_","checkBufferTimeout_","currentTimeline_","pendingSegment_","xhrOptions_","pendingSegments_","audioDisabled_","isPendingTimestampOffset_","gopBuffer_","timeMapping_","safeAppend_","appendInitSegment_","playlistOfLastInitSegment_","callQueue_","loadQueue_","metadataQueue_","activeInitSegmentId_","initSegments_","cacheEncryptionKeys_","cacheEncryptionKeys","keyCache_","decrypter_","decrypter","syncController_","syncController","syncPoint_","segmentIndex","transmuxer_","createTransmuxer_","triggerSyncInfoUpdate_","isEndOfStream_","ended_","fetchAtBuffer_","logger_","newState","hasEnoughInfoToAppend_","processCallQueue_","hasEnoughInfoToLoad_","processLoadQueue_","mediaBytesTransferred","mediaRequests","mediaRequestsAborted","mediaRequestsTimedout","mediaRequestsErrored","mediaTransferDuration","mediaSecondsLoaded","abort_","setAudio","removeAudio","monitorBuffer_","abortRequests","clearPendingTimelineChange","checkForAbort_","_error","endOfStream","buffered_","_this$startingMediaIn","videoBuffered","audioBuffered","initSegmentForMap","storedMap","segmentKey","storedKey","couldBeginLoading_","playlist_","setDateTimeMapping","init_","resetEverything","newPlaylist","oldPlaylist","segmentInfo","syncInfo","oldId","resyncLoader","mediaSequenceDiff","saveExpiredSegmentInfo","resetLoader","removesRemaining","removeFinished","mapping","updatedBuffer","removeGopBuffer","removeVideo","monitorBufferTick_","fillBuffer_","updating","getSyncPoint","checkBuffer_","timeline","loadSegment_","appendedLastSegment","currentMediaIndex","lastBufferedEnd","bufferedTime","nextMediaIndex","isSyncRequest","getSyncSegmentCandidate_","mediaSourceInfo","_mediaSourceInfo","generateSegmentInfo_","segmentIndexArray","audioTimestampOffset","currentTimePts","gopsSafeToAlignWith","videoTimestampOffset","random","abortRequestEarly_","measuredBandwidth","requestTimeRemaining","timeUntilRebuffer$1","timeUntilRebuffer","switchCandidate","compatiblePlaylists","enabledPlaylists","rebufferingEstimates","numRequests","rebufferingImpact","noRebufferingPlaylists","estimate","minRebufferMaxBandwidthSelector","timeSavedBySwitching","minimumTimeSaving","handleAbort_","handleProgress_","simpleSegment","handleTrackInfo_","checkForIllegalMediaSwitch","akeys","bkeys","shallowEqual","handleTimingInfo_","timeType","timingInfoProperty","handleCaptions_","captionData","hasAppendedData_","captionTracks","captionTrack","trackName","_captionTracks$trackN","createCaptionsTrackIfNotExists","captionArray","addCaptionData","handleId3_","inBandMetadataTrackDispatchType","createMetadataTrackIfNotExists","processMetadataQueue_","callQueue","fun","loadQueue","_this$currentMediaInf","setTimeMapping_","updateMediaSecondsLoaded_","firstVideoFrameTimeForData","useVideoTimingInfo","trueSegmentStart_","currentStart","currentVideoTimestampOffset","updateAppendInitSegmentStatus","updateSourceBufferTimestampOffset_","appendData_","changedTimestampOffset","getInitSegmentAndUpdateState_","appendToSourceBuffer_","segmentObj","tempBuffer","appendBuffer","handleVideoSegmentTimingInfo_","trimBackBuffer_","updateTransmuxerAndRequestSegment_","shouldUpdateTransmuxerTimestampOffset_","createSimplifiedSegmentObj_","segmentRequestFinished_","removeToTime","trimTime","maxTrimTime","safeBackBufferTrimTime","previousSegment","saveTransferStats_","saveBandwidthRelatedStats_","handleTimeout_","updateGopBuffer","isEndOfStream","isWalkingForward","isDiscontinuity","waitForAppendsToComplete_","timelineMapping","mappingForTimeline","_this$currentMediaInf2","waitForVideo","waitForAudio","waitingOnAppends","checkAppendsDone_","videoQueueCallback","audioQueueCallback","handleAppendsDone_","illegalMediaSwitchError","startingMedia","illegalMediaSwitch","didChange","updateTimingInfoEnd_","prioritizedTimingInfo","saveSegmentTimingInfo","shouldSaveTimelineMapping","_segmentInfo$segment","_segmentInfo$playlist","seq","_segmentInfo$playlist2","segmentInfoString","recordThroughput_","addSegmentMetadataCue_","segmentProcessingTime","segmentProcessingThroughput","custom","dateTimeString","resolution","RESOLUTION","toTitleCase$1","bufferTypes","_updating","sourceBuffer","queuePending","shiftQueue","queueIndex","queueEntry","started_","nextQueueIndexOfType","cleanupBuffer","titleType","inSourceBuffers","sourceBuffers","actions","_callback","_duration","mime","addSourceBuffer","removeSourceBuffer","changeType","pushQueue","onUpdateend","SourceUpdater","sourceopenListener_","audioTimestampOffset_","videoTimestampOffset_","delayedAudioAppendQueue_","videoAppendQueued_","onVideoUpdateEnd_","onAudioUpdateEnd_","onVideoError_","videoError_","onAudioError_","audioError_","createSourceBuffers","addOrChangeSourceBuffers","canRemoveSourceBuffer","MediaSource","canChangeType","SourceBuffer","processedAppend_","videoBuffer","que","audioBuffer","bufferA","bufferB","arity","extents","bufferIntersection","setDuration","uint8ToUtf8","uintArray","escape","VTT_LINE_TERMINATORS","_char2","VTTSegmentLoader","_SegmentLoader","subtitlesTrack_","featuresNativeTextTracks_","combinedByteLength","combinedSegment","skipEmptySegments_","timestampOffsetForTimeline","stopForError","loadHandler","requested","parseVTTCues_","updateTimeMapping_","timelines","decoder","decodeBytesToString","TextDecoder","timestampmap","MPEGTS","LOCAL","ontimestampmap","mapData","segmentData","mappingObj","diff","firstStart","lastStart","findAdCue","mediaTime","adStartTime","adEndTime","syncPointStrategies","run","datetimeToDisplayTime","lastDistance","segmentStart","discontinuityStarts","discontinuitySequence","discontinuitySync","discontinuities","SyncController","syncPoints","runStrategies_","selectSyncPoint_","getExpiredTime","strategy","bestSyncPoint","bestDistance","bestStrategy","newDistance","lastRemovedSegment","playlistTimestamp","calculateSegmentTimeMapping_","saveDiscontinuitySyncInfo_","accuracy","mediaIndexDiff","TimelineChangeController","pendingTimelineChanges_","lastTimelineChanges_","Decrypter","_defineProperties","createClass","Constructor","protoProps","staticProps","inheritsLoose","create","_length","aesTables","AES","tmp","xInv","x2","x4","tEnc","tDec","tables","encTable","decTable","sbox","sboxInv","th","precompute","_tables","keyLen","rcon","encKey","decKey","decrypt","encrypted0","encrypted1","encrypted2","encrypted3","out","a2","b2","c2","nInnerRounds","kIndex","table","table0","table1","table2","table3","AsyncStream","_Stream","jobs","timeout_","processJob_","job","ntoh","word","initVector","step","STEP","encrypted32","Int32Array","asyncStream_","decryptChunk_","padded","init0","init1","init2","init3","wordIx","decipher","decrypted32","audioTrackKind_","characteristics","stopLoaders","segmentLoader","activePlaylistLoader","startLoaders","playlistLoader","onError","segmentLoaders","mediaTypes","blacklistCurrentPlaylist","activeTrack","activeGroup","defaultTrack","onTrackChanged","SUBTITLES","setupListeners","requestOptions","initialize","_settings$master","_settings$mediaTypes$","groups","groupPlaylists","_loop2","variantLabel","_settings$mediaTypes$2","forced","autoselect","_settings$mediaTypes$3","instreamId","setupMediaGroups","variants","onGroupChanged","_settings$segmentLoad","mainSegmentLoader","previousActiveLoader","onGroupChanging","_settings$segmentLoad2","onAudioTrackChanged","loaderStats","sumLoaderStat","stat","audioSegmentLoader_","mainSegmentLoader_","MasterPlaylistController","externVhs","useCueTags","enableLowInitialPlaylist","useCueTags_","cueTagsTrack_","requestOptions_","pauseLoading","mediaTypes_","handleDurationChange_","handleSourceOpen_","handleSourceEnded_","segmentLoaderSettings","setupMasterPlaylistLoaderListeners_","subtitleSegmentLoader_","setupSegmentLoaderListeners_","triggeredFmp4Usage","requestTimeout","triggerPresenceUsage_","setupFirstPlay","updatedPlaylist","selectedMedia","excludeUnsupportedVariants_","selectInitialPlaylist","selectPlaylist","initialMedia_","handleUpdatedMediaPlaylist","stuckAtPlaylistEnd_","updateAdCues_","updateDuration","defaultDemuxed","audioGroupKeys","mediaGroup","nextPlaylist","currentPlaylist","forwardBuffer","bufferLowWaterLine","shouldSwitchToMedia","onSyncInfoUpdate_","onEndOfStream","updateCodecs","tryToCreateSourceBuffers_","getCodecsOrExclude_","mediaSecondsLoaded_","smoothQualityChange_","fastQualityChange_","absolutePlaylistEnd","reincluded","errorMessage","delegateLoaders_","fnNames","loaders","dontFilterPlaylist","audioSeekable","suggestedPresentationDelay","mainSeekable","oldEnd","oldStart","updateDuration_","areMediaTypesKnown_","usingAudioLoader","playlistCodecs","unsupportedAudio","unsupportedCodecs","supporter","variant","switchMessages","newCodec","oldCodec","codecString","excludeIncompatibleVariants_","codecCount","variantCodecs","variantCodecCount","blacklistReasons","variantCodecStrings","variantCodecString","cueOut","_segment$cueOutCont$s","cueOutCont","adOffset","adTotal","updateAdCues","Representation","vhsHandler","playlistID","changePlaylistFn","mpc","masterPlaylistController_","qualityChangeFunction","smoothQualityChange","incompatible","currentlyEnabled","timerCancelEvents","PlaybackWatcher","masterPlaylistController","allowSeeksWithinUnsafeLiveWindow","consecutiveUpdates","lastRecordedTime","timer_","checkCurrentTimeTimeout_","canPlayHandler","monitorCurrentTime_","waitingHandler","techWaiting_","cancelTimerHandler","cancelTimer_","fixesBadSeeksHandler","fixesBadSeeks_","loaderTypes","loaderChecks","resetSegmentDownloads_","updateend","checkSegmentDownloads_","checkCurrentTime_","isBufferedDifferent","isRangeDifferent","playlistId","waiting_","afterSeekableWindow_","beforeSeekableWindow_","closeToBufferedContent","currentRange","livePoint","videoUnderflow_","nextRange","difference","skipTheGap_","allowedEnd","gap","lastVideoRange","videoRange","audioRange","gapFromVideoUnderflow_","scheduledCurrentTime","gaps","findGaps","defaultOptions","errorInterval","getSource","IWillNotUseThisInPlugins","reloadSourceOnError","initPlugin","lastCalled","localOptions","loadedMetadataHandler","cleanupEvents","Vhs$1","STANDARD_PLAYLIST_SELECTOR","pixelRatio","useDevicePixelRatio","devicePixelRatio","playerBandwidth","playerWidth","playerHeight","limitRenditionByPlayerDimensions","sortedPlaylistReps","enabledPlaylistReps","rep","bandwidthPlaylistReps","highestRemainingBandwidthRep","bandwidthBestRep","_chosenRep","haveResolution","resolutionBestRepList","resolutionPlusOneList","resolutionPlusOneSmallest","resolutionPlusOneRep","resolutionBestRep","chosenRep","_type","simpleSelector","systemBandwidth","INITIAL_PLAYLIST_SELECTOR","comparePlaylistResolution","leftWidth","rightWidth","handleVhsMediaChange","qualityLevels","selectedIndex_","setupEmeOptions","sourceKeySystems","audioMedia","mainPlaylists","sourceOptions","keySystemOptions","videoPlaylist","audioPlaylist","videoContentType","audioContentType","keySystemContentTypes","keySystem","contentProtection","pssh","emeKeySystems","keySystems","initializeMediaKeys","keySystemsArr","keySystemsOptions","keySystemsObj","getAllPsshKeySystemsOptions","getVhsLocalStorage","storedObject","supportsNativeHls","canItPlay","supportsNativeDash","supportsTypeNatively","VhsHandler","hls","source_","ignoreNextSeekingEvent_","setOptions_","overrideNative","featuresNativeVideoTracks","featuresNativeAudioTracks","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","useBandwidthFromLocalStorage","option","dataUri","playbackWatcher_","invThroughput","invBandwidth","mediaRequests_","mediaRequestsAborted_","mediaRequestsTimedout_","mediaRequestsErrored_","mediaTransferDuration_","mediaBytesTransferred_","currentTech","playerDimensions","objectToStore","updateVhsLocalStorage","representations","audioPlaylistLoader","setupQualityLevels_","mediaSourceUrl_","qualityLevels_","addQualityLevel","dash","convertToProgramTime","VhsSourceHandler","_videojs$mergeOptions2","supportedType"],"mappings":"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","file":"d6e1aeb5-18935f2bae3f6b5d80b4.js","sourcesContent":["import \"core-js/modules/es.array.reduce\";\nimport \"core-js/modules/es.array.reduce-right\";\n\n/**\n * @license\n * Video.js 7.10.2 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\n */\nimport window$1 from 'global/window';\nimport document from 'global/document';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport '@babel/runtime/helpers/possibleConstructorReturn';\nimport '@babel/runtime/helpers/getPrototypeOf';\nimport _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport safeParseTuple from 'safe-json-parse/tuple';\nimport keycode from 'keycode';\nimport XHR from '@videojs/xhr';\nimport vtt from 'videojs-vtt.js';\nimport _construct from '@babel/runtime/helpers/construct';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _resolveUrl from '@videojs/vhs-utils/dist/resolve-url.js';\nimport { Parser } from 'm3u8-parser';\nimport { simpleTypeFromSourceType } from '@videojs/vhs-utils/dist/media-types.js';\nimport { parseUTCTiming, parse } from 'mpd-parser';\nimport parseSidx from 'mux.js/lib/tools/parse-sidx';\nimport { detectContainerForBytes, isLikelyFmp4MediaSegment, getId3Offset } from '@videojs/vhs-utils/dist/containers';\nimport { toUint8, concatTypedArrays, stringToBytes } from '@videojs/vhs-utils/dist/byte-helpers';\nimport tsInspector from 'mux.js/lib/tools/ts-inspector.js';\nimport { ONE_SECOND_IN_TS } from 'mux.js/lib/utils/clock';\nimport mp4probe from 'mux.js/lib/mp4/probe';\nimport { browserSupportsCodec, DEFAULT_VIDEO_CODEC, DEFAULT_AUDIO_CODEC, muxerSupportsCodec, parseCodecs, codecsFromDefault, translateLegacyCodec, getMimeForCodec, isAudioCodec, isVideoCodec } from '@videojs/vhs-utils/dist/codecs.js';\nvar version = \"7.10.2\";\n/**\n * @file create-logger.js\n * @module create-logger\n */\n\nvar history = [];\n/**\n * Log messages to the console and history based on the type of message\n *\n * @private\n * @param  {string} type\n *         The name of the console method to use.\n *\n * @param  {Array} args\n *         The arguments to be passed to the matching console method.\n */\n\nvar LogByTypeFactory = function LogByTypeFactory(name, log) {\n  return function (type, level, args) {\n    var lvl = log.levels[level];\n    var lvlRegExp = new RegExp(\"^(\" + lvl + \")$\");\n\n    if (type !== 'log') {\n      // Add the type to the front of the message when it's not \"log\".\n      args.unshift(type.toUpperCase() + ':');\n    } // Add console prefix after adding to history.\n\n\n    args.unshift(name + ':'); // Add a clone of the args at this point to history.\n\n    if (history) {\n      history.push([].concat(args)); // only store 1000 history entries\n\n      var splice = history.length - 1000;\n      history.splice(0, splice > 0 ? splice : 0);\n    } // If there's no console then don't try to output messages, but they will\n    // still be stored in history.\n\n\n    if (!window$1.console) {\n      return;\n    } // Was setting these once outside of this function, but containing them\n    // in the function makes it easier to test cases where console doesn't exist\n    // when the module is executed.\n\n\n    var fn = window$1.console[type];\n\n    if (!fn && type === 'debug') {\n      // Certain browsers don't have support for console.debug. For those, we\n      // should default to the closest comparable log.\n      fn = window$1.console.info || window$1.console.log;\n    } // Bail out if there's no console or if this type is not allowed by the\n    // current logging level.\n\n\n    if (!fn || !lvl || !lvlRegExp.test(type)) {\n      return;\n    }\n\n    fn[Array.isArray(args) ? 'apply' : 'call'](window$1.console, args);\n  };\n};\n\nfunction createLogger(name) {\n  // This is the private tracking variable for logging level.\n  var level = 'info'; // the curried logByType bound to the specific log and history\n\n  var logByType;\n  /**\n   * Logs plain debug messages. Similar to `console.log`.\n   *\n   * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n   * of our JSDoc template, we cannot properly document this as both a function\n   * and a namespace, so its function signature is documented here.\n   *\n   * #### Arguments\n   * ##### *args\n   * Mixed[]\n   *\n   * Any combination of values that could be passed to `console.log()`.\n   *\n   * #### Return Value\n   *\n   * `undefined`\n   *\n   * @namespace\n   * @param    {Mixed[]} args\n   *           One or more messages or objects that should be logged.\n   */\n\n  var log = function log() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    logByType('log', level, args);\n  }; // This is the logByType helper that the logging methods below use\n\n\n  logByType = LogByTypeFactory(name, log);\n  /**\n   * Create a new sublogger which chains the old name to the new name.\n   *\n   * For example, doing `videojs.log.createLogger('player')` and then using that logger will log the following:\n   * ```js\n   *  mylogger('foo');\n   *  // > VIDEOJS: player: foo\n   * ```\n   *\n   * @param {string} name\n   *        The name to add call the new logger\n   * @return {Object}\n   */\n\n  log.createLogger = function (subname) {\n    return createLogger(name + ': ' + subname);\n  };\n  /**\n   * Enumeration of available logging levels, where the keys are the level names\n   * and the values are `|`-separated strings containing logging methods allowed\n   * in that logging level. These strings are used to create a regular expression\n   * matching the function name being called.\n   *\n   * Levels provided by Video.js are:\n   *\n   * - `off`: Matches no calls. Any value that can be cast to `false` will have\n   *   this effect. The most restrictive.\n   * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n   *   `log.warn`, and `log.error`).\n   * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n   * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n   * - `warn`: Matches `log.warn` and `log.error` calls.\n   * - `error`: Matches only `log.error` calls.\n   *\n   * @type {Object}\n   */\n\n\n  log.levels = {\n    all: 'debug|log|warn|error',\n    off: '',\n    debug: 'debug|log|warn|error',\n    info: 'log|warn|error',\n    warn: 'warn|error',\n    error: 'error',\n    DEFAULT: level\n  };\n  /**\n   * Get or set the current logging level.\n   *\n   * If a string matching a key from {@link module:log.levels} is provided, acts\n   * as a setter.\n   *\n   * @param  {string} [lvl]\n   *         Pass a valid level to set a new logging level.\n   *\n   * @return {string}\n   *         The current logging level.\n   */\n\n  log.level = function (lvl) {\n    if (typeof lvl === 'string') {\n      if (!log.levels.hasOwnProperty(lvl)) {\n        throw new Error(\"\\\"\" + lvl + \"\\\" in not a valid log level\");\n      }\n\n      level = lvl;\n    }\n\n    return level;\n  };\n  /**\n   * Returns an array containing everything that has been logged to the history.\n   *\n   * This array is a shallow clone of the internal history record. However, its\n   * contents are _not_ cloned; so, mutating objects inside this array will\n   * mutate them in history.\n   *\n   * @return {Array}\n   */\n\n\n  log.history = function () {\n    return history ? [].concat(history) : [];\n  };\n  /**\n   * Allows you to filter the history by the given logger name\n   *\n   * @param {string} fname\n   *        The name to filter by\n   *\n   * @return {Array}\n   *         The filtered list to return\n   */\n\n\n  log.history.filter = function (fname) {\n    return (history || []).filter(function (historyItem) {\n      // if the first item in each historyItem includes `fname`, then it's a match\n      return new RegExp(\".*\" + fname + \".*\").test(historyItem[0]);\n    });\n  };\n  /**\n   * Clears the internal history tracking, but does not prevent further history\n   * tracking.\n   */\n\n\n  log.history.clear = function () {\n    if (history) {\n      history.length = 0;\n    }\n  };\n  /**\n   * Disable history tracking if it is currently enabled.\n   */\n\n\n  log.history.disable = function () {\n    if (history !== null) {\n      history.length = 0;\n      history = null;\n    }\n  };\n  /**\n   * Enable history tracking if it is currently disabled.\n   */\n\n\n  log.history.enable = function () {\n    if (history === null) {\n      history = [];\n    }\n  };\n  /**\n   * Logs error messages. Similar to `console.error`.\n   *\n   * @param {Mixed[]} args\n   *        One or more messages or objects that should be logged as an error\n   */\n\n\n  log.error = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return logByType('error', level, args);\n  };\n  /**\n   * Logs warning messages. Similar to `console.warn`.\n   *\n   * @param {Mixed[]} args\n   *        One or more messages or objects that should be logged as a warning.\n   */\n\n\n  log.warn = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return logByType('warn', level, args);\n  };\n  /**\n   * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n   * log if `console.debug` is not available\n   *\n   * @param {Mixed[]} args\n   *        One or more messages or objects that should be logged as debug.\n   */\n\n\n  log.debug = function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return logByType('debug', level, args);\n  };\n\n  return log;\n}\n/**\n * @file log.js\n * @module log\n */\n\n\nvar log = createLogger('VIDEOJS');\nvar createLogger$1 = log.createLogger;\n/**\n * @file obj.js\n * @module obj\n */\n\n/**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n */\n\n/**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */\n\nvar toString = Object.prototype.toString;\n/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */\n\nvar keys = function keys(object) {\n  return isObject(object) ? Object.keys(object) : [];\n};\n/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */\n\n\nfunction each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}\n/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */\n\n\nfunction reduce(object, fn, initial) {\n  if (initial === void 0) {\n    initial = 0;\n  }\n\n  return keys(object).reduce(function (accum, key) {\n    return fn(accum, object[key], key);\n  }, initial);\n}\n/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */\n\n\nfunction assign(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (Object.assign) {\n    return _extends.apply(void 0, [target].concat(sources));\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      target[key] = value;\n    });\n  });\n  return target;\n}\n/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  return !!value && typeof value === 'object';\n}\n/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {boolean}\n */\n\n\nfunction isPlain(value) {\n  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;\n}\n/**\n * @file computed-style.js\n * @module computed-style\n */\n\n/**\n * A safe getComputedStyle.\n *\n * This is needed because in Firefox, if the player is loaded in an iframe with\n * `display:none`, then `getComputedStyle` returns `null`, so, we do a\n * null-check to make sure that the player doesn't break in these cases.\n *\n * @function\n * @param    {Element} el\n *           The element you want the computed style of\n *\n * @param    {string} prop\n *           The property name you want\n *\n * @see      https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n */\n\n\nfunction computedStyle(el, prop) {\n  if (!el || !prop) {\n    return '';\n  }\n\n  if (typeof window$1.getComputedStyle === 'function') {\n    var computedStyleValue = window$1.getComputedStyle(el);\n    return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';\n  }\n\n  return '';\n}\n/**\n * @file dom.js\n * @module dom\n */\n\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @private\n * @param  {string} str\n *         The string to check\n *\n * @return {boolean}\n *         Will be `true` if the string is non-blank, `false` otherwise.\n *\n */\n\n\nfunction isNonBlankString(str) {\n  // we use str.trim as it will trim any whitespace characters\n  // from the front or back of non-whitespace characters. aka\n  // Any string that contains non-whitespace characters will\n  // still contain them after `trim` but whitespace only strings\n  // will have a length of 0, failing this check.\n  return typeof str === 'string' && Boolean(str.trim());\n}\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @private\n * @param  {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n */\n\n\nfunction throwIfWhitespace(str) {\n  // str.indexOf instead of regex because str.indexOf is faster performance wise.\n  if (str.indexOf(' ') >= 0) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @private\n * @param  {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\n\n\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n/**\n * Whether the current DOM interface appears to be real (i.e. not simulated).\n *\n * @return {boolean}\n *         Will be `true` if the DOM appears to be real, `false` otherwise.\n */\n\n\nfunction isReal() {\n  // Both document and window will never be undefined thanks to `global`.\n  return document === window$1.document;\n}\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param  {Mixed} value\n *         The value to check.\n *\n * @return {boolean}\n *         Will be `true` if the value is a DOM element, `false` otherwise.\n */\n\n\nfunction isEl(value) {\n  return isObject(value) && value.nodeType === 1;\n}\n/**\n * Determines if the current DOM is embedded in an iframe.\n *\n * @return {boolean}\n *         Will be `true` if the DOM is embedded in an iframe, `false`\n *         otherwise.\n */\n\n\nfunction isInFrame() {\n  // We need a try/catch here because Safari will throw errors when attempting\n  // to get either `parent` or `self`\n  try {\n    return window$1.parent !== window$1.self;\n  } catch (x) {\n    return true;\n  }\n}\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @private\n * @param   {string} method\n *          The method to create the query with.\n *\n * @return  {Function}\n *          The query method\n */\n\n\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return document[method](null);\n    }\n\n    if (isNonBlankString(context)) {\n      context = document.querySelector(context);\n    }\n\n    var ctx = isEl(context) ? context : document;\n    return ctx[method] && ctx[method](selector);\n  };\n}\n/**\n * Creates an element and applies properties, attributes, and inserts content.\n *\n * @param  {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param  {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param  {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {module:dom~ContentDescriptor} content\n *        A content descriptor object.\n *\n * @return {Element}\n *         The element that was created.\n */\n\n\nfunction createEl(tagName, properties, attributes, content) {\n  if (tagName === void 0) {\n    tagName = 'div';\n  }\n\n  if (properties === void 0) {\n    properties = {};\n  }\n\n  if (attributes === void 0) {\n    attributes = {};\n  }\n\n  var el = document.createElement(tagName);\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName]; // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      log.warn('Setting attributes in the second argument of createEl()\\n' + 'has been deprecated. Use the third argument instead.\\n' + (\"createEl(type, properties, attributes). Attempting to set \" + propName + \" to \" + val + \".\"));\n      el.setAttribute(propName, val); // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else if (el[propName] !== val) {\n      el[propName] = val;\n    }\n  });\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n\n  if (content) {\n    appendContent(el, content);\n  }\n\n  return el;\n}\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param  {Element} el\n *         The element to add text content into\n *\n * @param  {string} text\n *         The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\n\n\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n\n  return el;\n}\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n */\n\n\nfunction prependTo(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n/**\n * Check if an element has a class name.\n *\n * @param  {Element} element\n *         Element to check\n *\n * @param  {string} classToCheck\n *         Class name to check for\n *\n * @return {boolean}\n *         Will be `true` if the element has a class, `false` otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\n\n\nfunction hasClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n\n  return classRegExp(classToCheck).test(element.className);\n}\n/**\n * Add a class name to an element.\n *\n * @param  {Element} element\n *         Element to add class name to.\n *\n * @param  {string} classToAdd\n *         Class name to add.\n *\n * @return {Element}\n *         The DOM element with the added class name.\n */\n\n\nfunction addClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd); // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}\n/**\n * Remove a class name from an element.\n *\n * @param  {Element} element\n *         Element to remove a class name from.\n *\n * @param  {string} classToRemove\n *         Class name to remove\n *\n * @return {Element}\n *         The DOM element with class name removed.\n */\n\n\nfunction removeClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n\n  return element;\n}\n/**\n * The callback definition for toggleClass.\n *\n * @callback module:dom~PredicateCallback\n * @param    {Element} element\n *           The DOM element of the Component.\n *\n * @param    {string} classToToggle\n *           The `className` that wants to be toggled\n *\n * @return   {boolean|undefined}\n *           If `true` is returned, the `classToToggle` will be added to the\n *           `element`. If `false`, the `classToToggle` will be removed from\n *           the `element`. If `undefined`, the callback will be ignored.\n */\n\n/**\n * Adds or removes a class name to/from an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param  {Element} element\n *         The element to toggle a class name on.\n *\n * @param  {string} classToToggle\n *         The class that should be toggled.\n *\n * @param  {boolean|module:dom~PredicateCallback} [predicate]\n *         See the return value for {@link module:dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\n\n\nfunction toggleClass(element, classToToggle, predicate) {\n  // This CANNOT use `classList` internally because IE11 does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  } // If the necessary class operation matches the current state of the\n  // element, no action is required.\n\n\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addClass(element, classToToggle);\n  } else {\n    removeClass(element, classToToggle);\n  }\n\n  return element;\n}\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\n\n\nfunction setAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n/**\n * Get an element's attribute values, as defined on the HTML tag.\n *\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute.\n *\n * @param  {Element} tag\n *         Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element. Boolean attributes will be `true` or\n *         `false`, others will be strings.\n */\n\n\nfunction getAttributes(tag) {\n  var obj = {}; // known boolean attributes\n  // we can check for matching boolean properties, but not all browsers\n  // and not all tags know about these attributes, so, we still want to check them manually\n\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value; // check for known booleans\n      // the matching element property will return a value for typeof\n\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n}\n/**\n * Get the value of an element's attribute.\n *\n * @param {Element} el\n *        A DOM element.\n *\n * @param {string} attribute\n *        Attribute to get the value of.\n *\n * @return {string}\n *         The value of the attribute.\n */\n\n\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n/**\n * Set the value of an element's attribute.\n *\n * @param {Element} el\n *        A DOM element.\n *\n * @param {string} attribute\n *        Attribute to set.\n *\n * @param {string} value\n *        Value to set the attribute to.\n */\n\n\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n/**\n * Remove an element's attribute.\n *\n * @param {Element} el\n *        A DOM element.\n *\n * @param {string} attribute\n *        Attribute to remove.\n */\n\n\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n/**\n * Attempt to block the ability to select text.\n */\n\n\nfunction blockTextSelection() {\n  document.body.focus();\n\n  document.onselectstart = function () {\n    return false;\n  };\n}\n/**\n * Turn off text selection blocking.\n */\n\n\nfunction unblockTextSelection() {\n  document.onselectstart = function () {\n    return true;\n  };\n}\n/**\n * Identical to the native `getBoundingClientRect` function, but ensures that\n * the method is supported at all (it is in all browsers we claim to support)\n * and that the element is in the DOM before continuing.\n *\n * This wrapper function also shims properties which are not provided by some\n * older browsers (namely, IE8).\n *\n * Additionally, some browsers do not support adding properties to a\n * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n * properties (except `x` and `y` which are not widely supported). This helps\n * avoid implementations where keys are non-enumerable.\n *\n * @param  {Element} el\n *         Element whose `ClientRect` we want to calculate.\n *\n * @return {Object|undefined}\n *         Always returns a plain object - or `undefined` if it cannot.\n */\n\n\nfunction getBoundingClientRect(el) {\n  if (el && el.getBoundingClientRect && el.parentNode) {\n    var rect = el.getBoundingClientRect();\n    var result = {};\n    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {\n      if (rect[k] !== undefined) {\n        result[k] = rect[k];\n      }\n    });\n\n    if (!result.height) {\n      result.height = parseFloat(computedStyle(el, 'height'));\n    }\n\n    if (!result.width) {\n      result.width = parseFloat(computedStyle(el, 'width'));\n    }\n\n    return result;\n  }\n}\n/**\n * Represents the position of a DOM element on the page.\n *\n * @typedef  {Object} module:dom~Position\n *\n * @property {number} left\n *           Pixels to the left.\n *\n * @property {number} top\n *           Pixels from the top.\n */\n\n/**\n * Get the position of an element in the DOM.\n *\n * Uses `getBoundingClientRect` technique from John Resig.\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param  {Element} el\n *         Element from which to get offset.\n *\n * @return {module:dom~Position}\n *         The position of the element that was passed in.\n */\n\n\nfunction findPosition(el) {\n  if (!el || el && !el.offsetParent) {\n    return {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    };\n  }\n\n  var width = el.offsetWidth;\n  var height = el.offsetHeight;\n  var left = 0;\n  var top = 0;\n\n  do {\n    left += el.offsetLeft;\n    top += el.offsetTop;\n    el = el.offsetParent;\n  } while (el);\n\n  return {\n    left: left,\n    top: top,\n    width: width,\n    height: height\n  };\n}\n/**\n * Represents x and y coordinates for a DOM element or mouse pointer.\n *\n * @typedef  {Object} module:dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get the pointer position within an element.\n *\n * The base on the coordinates are the bottom left of the element.\n *\n * @param  {Element} el\n *         Element on which to get the pointer position on.\n *\n * @param  {EventTarget~Event} event\n *         Event object.\n *\n * @return {module:dom~Coordinates}\n *         A coordinates object corresponding to the mouse position.\n *\n */\n\n\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var boxTarget = findPosition(event.target);\n  var box = findPosition(el);\n  var boxW = box.width;\n  var boxH = box.height;\n  var offsetY = event.offsetY - (box.top - boxTarget.top);\n  var offsetX = event.offsetX - (box.left - boxTarget.left);\n\n  if (event.changedTouches) {\n    offsetX = event.changedTouches[0].pageX - box.left;\n    offsetY = event.changedTouches[0].pageY + box.top;\n  }\n\n  position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));\n  position.x = Math.max(0, Math.min(1, offsetX / boxW));\n  return position;\n}\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param  {Mixed} value\n *         Check if this value is a text node.\n *\n * @return {boolean}\n *         Will be `true` if the value is a text node, `false` otherwise.\n */\n\n\nfunction isTextNode(value) {\n  return isObject(value) && value.nodeType === 3;\n}\n/**\n * Empties the contents of an element.\n *\n * @param  {Element} el\n *         The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\n\n\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n\n  return el;\n}\n/**\n * This is a mixed value that describes content to be injected into the DOM\n * via some method. It can be of the following types:\n *\n * Type       | Description\n * -----------|-------------\n * `string`   | The value will be normalized into a text node.\n * `Element`  | The value will be accepted as-is.\n * `TextNode` | The value will be accepted as-is.\n * `Array`    | A one-dimensional array of strings, elements, text nodes, or functions. These functions should return a string, element, or text node (any other return value, like an array, will be ignored).\n * `Function` | A function, which is expected to return a string, element, text node, or array - any of the other possible values described above. This means that a content descriptor could be a function that returns an array of functions, but those second-level functions must return strings, elements, or text nodes.\n *\n * @typedef {string|Element|TextNode|Array|Function} module:dom~ContentDescriptor\n */\n\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but helps protect\n * from falling into the trap of simply writing to `innerHTML`, which could\n * be an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {module:dom~ContentDescriptor} content\n *        A content descriptor value.\n *\n * @return {Array}\n *         All of the content that was passed in, normalized to an array of\n *         elements or text nodes.\n */\n\n\nfunction normalizeContent(content) {\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  } // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n\n\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return document.createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n/**\n * Normalizes and appends content to an element.\n *\n * @param  {Element} el\n *         Element to append normalized content to.\n *\n * @param {module:dom~ContentDescriptor} content\n *        A content descriptor value.\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\n\n\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {module:dom~ContentDescriptor} content\n *        A content descriptor value.\n *\n * @return {Element}\n *         The element with inserted normalized content.\n */\n\n\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n/**\n * Check if an event was a single left click.\n *\n * @param  {EventTarget~Event} event\n *         Event object.\n *\n * @return {boolean}\n *         Will be `true` if a single left click, `false` otherwise.\n */\n\n\nfunction isSingleLeftClick(event) {\n  // Note: if you create something draggable, be sure to\n  // call it on both `mousedown` and `mousemove` event,\n  // otherwise `mousedown` should be enough for a button\n  if (event.button === undefined && event.buttons === undefined) {\n    // Why do we need `buttons` ?\n    // Because, middle mouse sometimes have this:\n    // e.button === 0 and e.buttons === 4\n    // Furthermore, we want to prevent combination click, something like\n    // HOLD middlemouse then left click, that would be\n    // e.button === 0, e.buttons === 5\n    // just `button` is not gonna work\n    // Alright, then what this block does ?\n    // this is for chrome `simulate mobile devices`\n    // I want to support this as well\n    return true;\n  }\n\n  if (event.button === 0 && event.buttons === undefined) {\n    // Touch screen, sometimes on some specific device, `buttons`\n    // doesn't have anything (safari on ios, blackberry...)\n    return true;\n  } // `mouseup` event on a single left click has\n  // `button` and `buttons` equal to 0\n\n\n  if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {\n    return true;\n  }\n\n  if (event.button !== 0 || event.buttons !== 1) {\n    // This is the reason we have those if else block above\n    // if any special case we can catch and let it slide\n    // we do it above, when get to here, this definitely\n    // is-not-left-click\n    return false;\n  }\n\n  return true;\n}\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param  {string} selector\n *         A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param  {Element|String} [context=document]\n *         A DOM element within which to query. Can also be a selector\n *         string in which case the first matching element will be used\n *         as context. If missing (or no element matches selector), falls\n *         back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\n\n\nvar $ = createQuerier('querySelector');\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param  {string} selector\n *         A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param  {Element|String} [context=document]\n *         A DOM element within which to query. Can also be a selector\n *         string in which case the first matching element will be used\n *         as context. If missing (or no element matches selector), falls\n *         back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none\n *         were found.\n *\n */\n\nvar $$ = createQuerier('querySelectorAll');\nvar Dom = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isReal: isReal,\n  isEl: isEl,\n  isInFrame: isInFrame,\n  createEl: createEl,\n  textContent: textContent,\n  prependTo: prependTo,\n  hasClass: hasClass,\n  addClass: addClass,\n  removeClass: removeClass,\n  toggleClass: toggleClass,\n  setAttributes: setAttributes,\n  getAttributes: getAttributes,\n  getAttribute: getAttribute,\n  setAttribute: setAttribute,\n  removeAttribute: removeAttribute,\n  blockTextSelection: blockTextSelection,\n  unblockTextSelection: unblockTextSelection,\n  getBoundingClientRect: getBoundingClientRect,\n  findPosition: findPosition,\n  getPointerPosition: getPointerPosition,\n  isTextNode: isTextNode,\n  emptyEl: emptyEl,\n  normalizeContent: normalizeContent,\n  appendContent: appendContent,\n  insertContent: insertContent,\n  isSingleLeftClick: isSingleLeftClick,\n  $: $,\n  $$: $$\n});\n/**\n * @file setup.js - Functions for setting up a player without\n * user interaction based on the data-setup `attribute` of the video tag.\n *\n * @module setup\n */\n\nvar _windowLoaded = false;\nvar videojs;\n/**\n * Set up any tags that have a data-setup `attribute` when the player is started.\n */\n\nvar autoSetup = function autoSetup() {\n  // Protect against breakage in non-browser environments and check global autoSetup option.\n  if (!isReal() || videojs.options.autoSetup === false) {\n    return;\n  }\n\n  var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n  var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n  var divs = Array.prototype.slice.call(document.getElementsByTagName('video-js'));\n  var mediaEls = vids.concat(audios, divs); // Check if any media elements exist\n\n  if (mediaEls && mediaEls.length > 0) {\n    for (var i = 0, e = mediaEls.length; i < e; i++) {\n      var mediaEl = mediaEls[i]; // Check if element exists, has getAttribute func.\n\n      if (mediaEl && mediaEl.getAttribute) {\n        // Make sure this player hasn't already been set up.\n        if (mediaEl.player === undefined) {\n          var options = mediaEl.getAttribute('data-setup'); // Check if data-setup attr exists.\n          // We only auto-setup if they've added the data-setup attr.\n\n          if (options !== null) {\n            // Create new video.js instance.\n            videojs(mediaEl);\n          }\n        } // If getAttribute isn't defined, we need to wait for the DOM.\n\n      } else {\n        autoSetupTimeout(1);\n        break;\n      }\n    } // No videos were found, so keep looping unless page is finished loading.\n\n  } else if (!_windowLoaded) {\n    autoSetupTimeout(1);\n  }\n};\n/**\n * Wait until the page is loaded before running autoSetup. This will be called in\n * autoSetup if `hasLoaded` returns false.\n *\n * @param {number} wait\n *        How long to wait in ms\n *\n * @param {module:videojs} [vjs]\n *        The videojs library function\n */\n\n\nfunction autoSetupTimeout(wait, vjs) {\n  if (vjs) {\n    videojs = vjs;\n  }\n\n  window$1.setTimeout(autoSetup, wait);\n}\n/**\n * Used to set the internal tracking of window loaded state to true.\n *\n * @private\n */\n\n\nfunction setWindowLoaded() {\n  _windowLoaded = true;\n  window$1.removeEventListener('load', setWindowLoaded);\n}\n\nif (isReal()) {\n  if (document.readyState === 'complete') {\n    setWindowLoaded();\n  } else {\n    /**\n     * Listen for the load event on window, and set _windowLoaded to true.\n     *\n     * We use a standard event listener here to avoid incrementing the GUID\n     * before any players are created.\n     *\n     * @listens load\n     */\n    window$1.addEventListener('load', setWindowLoaded);\n  }\n}\n/**\n * @file stylesheet.js\n * @module stylesheet\n */\n\n/**\n * Create a DOM syle element given a className for it.\n *\n * @param {string} className\n *        The className to add to the created style element.\n *\n * @return {Element}\n *         The element that was created.\n */\n\n\nvar createStyleElement = function createStyleElement(className) {\n  var style = document.createElement('style');\n  style.className = className;\n  return style;\n};\n/**\n * Add text to a DOM element.\n *\n * @param {Element} el\n *        The Element to add text content to.\n *\n * @param {string} content\n *        The text to add to the element.\n */\n\n\nvar setTextContent = function setTextContent(el, content) {\n  if (el.styleSheet) {\n    el.styleSheet.cssText = content;\n  } else {\n    el.textContent = content;\n  }\n};\n/**\n * @file guid.js\n * @module guid\n */\n// Default value for GUIDs. This allows us to reset the GUID counter in tests.\n//\n// The initial GUID is 3 because some users have come to rely on the first\n// default player ID ending up as `vjs_video_3`.\n//\n// See: https://github.com/videojs/video.js/pull/6216\n\n\nvar _initialGuid = 3;\n/**\n * Unique ID for an element or function\n *\n * @type {Number}\n */\n\nvar _guid = _initialGuid;\n/**\n * Get a unique auto-incrementing ID by number that has not been returned before.\n *\n * @return {number}\n *         A new unique ID.\n */\n\nfunction newGUID() {\n  return _guid++;\n}\n/**\n * @file dom-data.js\n * @module dom-data\n */\n\n\nvar FakeWeakMap;\n\nif (!window$1.WeakMap) {\n  FakeWeakMap = /*#__PURE__*/function () {\n    function FakeWeakMap() {\n      this.vdata = 'vdata' + Math.floor(window$1.performance && window$1.performance.now() || Date.now());\n      this.data = {};\n    }\n\n    var _proto = FakeWeakMap.prototype;\n\n    _proto.set = function set(key, value) {\n      var access = key[this.vdata] || newGUID();\n\n      if (!key[this.vdata]) {\n        key[this.vdata] = access;\n      }\n\n      this.data[access] = value;\n      return this;\n    };\n\n    _proto.get = function get(key) {\n      var access = key[this.vdata]; // we have data, return it\n\n      if (access) {\n        return this.data[access];\n      } // we don't have data, return nothing.\n      // return undefined explicitly as that's the contract for this method\n\n\n      log('We have no data for this element', key);\n      return undefined;\n    };\n\n    _proto.has = function has(key) {\n      var access = key[this.vdata];\n      return access in this.data;\n    };\n\n    _proto[\"delete\"] = function _delete(key) {\n      var access = key[this.vdata];\n\n      if (access) {\n        delete this.data[access];\n        delete key[this.vdata];\n      }\n    };\n\n    return FakeWeakMap;\n  }();\n}\n/**\n * Element Data Store.\n *\n * Allows for binding data to an element without putting it directly on the\n * element. Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\n\n\nvar DomData = window$1.WeakMap ? new WeakMap() : new FakeWeakMap();\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @file events.js\n * @module events\n */\n\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\n\nfunction _cleanUpEvents(elem, type) {\n  if (!DomData.has(elem)) {\n    return;\n  }\n\n  var data = DomData.get(elem); // Remove the events of a particular type if there are none left\n\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type]; // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n    // Remove the meta-handler from the element\n\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  } // Remove the events object if there are no types left\n\n\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  } // Finally remove the element data if there is no data left\n\n\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    DomData[\"delete\"](elem);\n  }\n}\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\n\n\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\n\n\nfunction fixEvent(event) {\n  if (event.fixed_) {\n    return event;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n\n\n  if (!event || !event.isPropagationStopped) {\n    var old = event || window$1.event;\n    event = {}; // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    } // The event occurred on this element\n\n\n    if (!event.target) {\n      event.target = event.srcElement || document;\n    } // Handle which other element the event is related to\n\n\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    } // Stop the default browser action\n\n\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n\n    event.defaultPrevented = false; // Stop the event from bubbling\n\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse; // Stop the event from bubbling and executing other handlers\n\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse; // Handle mouse position\n\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = document.documentElement;\n      var body = document.body;\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    } // Handle key presses\n\n\n    event.which = event.charCode || event.keyCode; // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n\n    if (event.button !== null && event.button !== undefined) {\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  }\n\n  event.fixed_ = true; // Returns fixed-up instance\n\n  return event;\n}\n/**\n * Whether passive event listeners are supported\n */\n\n\nvar _supportsPassive;\n\nvar supportsPassive = function supportsPassive() {\n  if (typeof _supportsPassive !== 'boolean') {\n    _supportsPassive = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          _supportsPassive = true;\n        }\n      });\n      window$1.addEventListener('test', null, opts);\n      window$1.removeEventListener('test', null, opts);\n    } catch (e) {// disregard\n    }\n  }\n\n  return _supportsPassive;\n};\n/**\n * Touch events Chrome expects to be passive\n */\n\n\nvar passiveEvents = ['touchstart', 'touchmove'];\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\n\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n\n  if (!DomData.has(elem)) {\n    DomData.set(elem, {});\n  }\n\n  var data = DomData.get(elem); // We need a place to store all our handler data\n\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  }\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event, hash) {\n      if (data.disabled) {\n        return;\n      }\n\n      event = fixEvent(event);\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              log.error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n\n      if (supportsPassive() && passiveEvents.indexOf(type) > -1) {\n        options = {\n          passive: true\n        };\n      }\n\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\n\n\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!DomData.has(elem)) {\n    return;\n  }\n\n  var data = DomData.get(elem); // If no events exist, nothing to unbind\n\n  if (!data.handlers) {\n    return;\n  }\n\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  } // Utility function\n\n\n  var removeType = function removeType(el, t) {\n    data.handlers[t] = [];\n\n    _cleanUpEvents(el, t);\n  }; // Are we removing all bound events?\n\n\n  if (type === undefined) {\n    for (var t in data.handlers) {\n      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\n        removeType(elem, t);\n      }\n    }\n\n    return;\n  }\n\n  var handlers = data.handlers[type]; // If no handlers exist, nothing to unbind\n\n  if (!handlers) {\n    return;\n  } // If no listener was provided, remove all listeners for type\n\n\n  if (!fn) {\n    removeType(elem, type);\n    return;\n  } // We're only removing a single handler\n\n\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  _cleanUpEvents(elem, type);\n}\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         Returns the opposite of `defaultPrevented` if default was\n *         prevented. Otherwise, returns `undefined`\n */\n\n\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = DomData.has(elem) ? DomData.get(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument; // type = event.type || event,\n  // handler;\n  // If an event name was passed as a string, creates an event out of it\n\n  if (typeof event === 'string') {\n    event = {\n      type: event,\n      target: elem\n    };\n  } else if (!event.target) {\n    event.target = elem;\n  } // Normalizes the event properties.\n\n\n  event = fixEvent(event); // If the passed element has a dispatcher, executes the established handlers.\n\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  } // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n\n\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash); // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {\n    if (!DomData.has(event.target)) {\n      DomData.set(event.target, {});\n    }\n\n    var targetData = DomData.get(event.target); // Checks if the target has a default action for this event.\n\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true; // Executes the default action.\n\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      } // Re-enables event dispatching.\n\n\n      targetData.disabled = false;\n    }\n  } // Inform the triggerer if the default was prevented by returning false\n\n\n  return !event.defaultPrevented;\n}\n/**\n * Trigger a listener only once for an event.\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event listener function\n */\n\n\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  }; // copy the guid to the new function so it can removed using the original function's ID\n\n\n  func.guid = fn.guid = fn.guid || newGUID();\n  on(elem, type, func);\n}\n/**\n * Trigger a listener only once and then turn if off for all\n * configured events\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event listener function\n */\n\n\nfunction any(elem, type, fn) {\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  }; // copy the guid to the new function so it can removed using the original function's ID\n\n\n  func.guid = fn.guid = fn.guid || newGUID(); // multiple ons, but one off for everything\n\n  on(elem, type, func);\n}\n\nvar Events = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  fixEvent: fixEvent,\n  on: on,\n  off: off,\n  trigger: trigger,\n  one: one,\n  any: any\n});\n/**\n * @file fn.js\n * @module fn\n */\n\nvar UPDATE_REFRESH_INTERVAL = 30;\n/**\n * Bind (a.k.a proxy or context). A simple method for changing the context of\n * a function.\n *\n * It also stores a unique id on the function so it can be easily removed from\n * events.\n *\n * @function\n * @param    {Mixed} context\n *           The object to bind as scope.\n *\n * @param    {Function} fn\n *           The function to be bound to a scope.\n *\n * @param    {number} [uid]\n *           An optional unique ID for the function to be set\n *\n * @return   {Function}\n *           The new function that will be bound into the context given\n */\n\nvar bind = function bind(context, fn, uid) {\n  // Make sure the function has a unique ID\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  } // Create the new function that changes the context\n\n\n  var bound = fn.bind(context); // Allow for the ability to individualize this function\n  // Needed in the case where multiple objects might share the same prototype\n  // IF both items add an event listener with the same function, then you try to remove just one\n  // it will remove both because they both have the same guid.\n  // when using this, you need to use the bind method when you remove the listener as well.\n  // currently used in text tracks\n\n  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n  return bound;\n};\n/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @function\n * @param    {Function} fn\n *           The function to be throttled.\n *\n * @param    {number}   wait\n *           The number of milliseconds by which to throttle.\n *\n * @return   {Function}\n */\n\n\nvar throttle = function throttle(fn, wait) {\n  var last = window$1.performance.now();\n\n  var throttled = function throttled() {\n    var now = window$1.performance.now();\n\n    if (now - last >= wait) {\n      fn.apply(void 0, arguments);\n      last = now;\n    }\n  };\n\n  return throttled;\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked.\n *\n * Inspired by lodash and underscore implementations.\n *\n * @function\n * @param    {Function} func\n *           The function to wrap with debounce behavior.\n *\n * @param    {number} wait\n *           The number of milliseconds to wait after the last invocation.\n *\n * @param    {boolean} [immediate]\n *           Whether or not to invoke the function immediately upon creation.\n *\n * @param    {Object} [context=window]\n *           The \"context\" in which the debounced function should debounce. For\n *           example, if this function should be tied to a Video.js player,\n *           the player can be passed here. Alternatively, defaults to the\n *           global `window` object.\n *\n * @return   {Function}\n *           A debounced function.\n */\n\n\nvar debounce = function debounce(func, wait, immediate, context) {\n  if (context === void 0) {\n    context = window$1;\n  }\n\n  var timeout;\n\n  var cancel = function cancel() {\n    context.clearTimeout(timeout);\n    timeout = null;\n  };\n  /* eslint-disable consistent-this */\n\n\n  var debounced = function debounced() {\n    var self = this;\n    var args = arguments;\n\n    var _later = function later() {\n      timeout = null;\n      _later = null;\n\n      if (!immediate) {\n        func.apply(self, args);\n      }\n    };\n\n    if (!timeout && immediate) {\n      func.apply(self, args);\n    }\n\n    context.clearTimeout(timeout);\n    timeout = context.setTimeout(_later, wait);\n  };\n  /* eslint-enable consistent-this */\n\n\n  debounced.cancel = cancel;\n  return debounced;\n};\n/**\n * @file src/js/event-target.js\n */\n\n/**\n * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n * adds shorthand functions that wrap around lengthy functions. For example:\n * the `on` function is a wrapper around `addEventListener`.\n *\n * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n * @class EventTarget\n */\n\n\nvar EventTarget = function EventTarget() {};\n/**\n * A Custom DOM event.\n *\n * @typedef {Object} EventTarget~Event\n * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n */\n\n/**\n * All event listeners should follow the following format.\n *\n * @callback EventTarget~EventListener\n * @this {EventTarget}\n *\n * @param {EventTarget~Event} event\n *        the event that triggered this function\n *\n * @param {Object} [hash]\n *        hash of data sent during the event\n */\n\n/**\n * An object containing event names as keys and booleans as values.\n *\n * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n *         will have extra functionality. See that function for more information.\n *\n * @property EventTarget.prototype.allowedEvents_\n * @private\n */\n\n\nEventTarget.prototype.allowedEvents_ = {};\n/**\n * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n * function that will get called when an event with a certain name gets triggered.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to call with `EventTarget`s\n */\n\nEventTarget.prototype.on = function (type, fn) {\n  // Remove the addEventListener alias before calling Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n\n  on(this, type, fn);\n  this.addEventListener = ael;\n};\n/**\n * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#on}\n */\n\n\nEventTarget.prototype.addEventListener = EventTarget.prototype.on;\n/**\n * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n * This makes it so that the `event listener` will no longer get called when the\n * named event happens.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to remove.\n */\n\nEventTarget.prototype.off = function (type, fn) {\n  off(this, type, fn);\n};\n/**\n * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#off}\n */\n\n\nEventTarget.prototype.removeEventListener = EventTarget.prototype.off;\n/**\n * This function will add an `event listener` that gets triggered only once. After the\n * first trigger it will get removed. This is like adding an `event listener`\n * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to be called once for each event name.\n */\n\nEventTarget.prototype.one = function (type, fn) {\n  // Remove the addEventListener aliasing Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n\n  one(this, type, fn);\n  this.addEventListener = ael;\n};\n\nEventTarget.prototype.any = function (type, fn) {\n  // Remove the addEventListener aliasing Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n\n  any(this, type, fn);\n  this.addEventListener = ael;\n};\n/**\n * This function causes an event to happen. This will then cause any `event listeners`\n * that are waiting for that event, to get called. If there are no `event listeners`\n * for an event then nothing will happen.\n *\n * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n * Trigger will also call the `on` + `uppercaseEventName` function.\n *\n * Example:\n * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n * `onClick` if it exists.\n *\n * @param {string|EventTarget~Event|Object} event\n *        The name of the event, an `Event`, or an object with a key of type set to\n *        an event name.\n */\n\n\nEventTarget.prototype.trigger = function (event) {\n  var type = event.type || event; // deprecation\n  // In a future version we should default target to `this`\n  // similar to how we default the target to `elem` in\n  // `Events.trigger`. Right now the default `target` will be\n  // `document` due to the `Event.fixEvent` call.\n\n  if (typeof event === 'string') {\n    event = {\n      type: type\n    };\n  }\n\n  event = fixEvent(event);\n\n  if (this.allowedEvents_[type] && this['on' + type]) {\n    this['on' + type](event);\n  }\n\n  trigger(this, event);\n};\n/**\n * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#trigger}\n */\n\n\nEventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;\nvar EVENT_MAP;\n\nEventTarget.prototype.queueTrigger = function (event) {\n  var _this = this; // only set up EVENT_MAP if it'll be used\n\n\n  if (!EVENT_MAP) {\n    EVENT_MAP = new Map();\n  }\n\n  var type = event.type || event;\n  var map = EVENT_MAP.get(this);\n\n  if (!map) {\n    map = new Map();\n    EVENT_MAP.set(this, map);\n  }\n\n  var oldTimeout = map.get(type);\n  map[\"delete\"](type);\n  window$1.clearTimeout(oldTimeout);\n  var timeout = window$1.setTimeout(function () {\n    // if we cleared out all timeouts for the current target, delete its map\n    if (map.size === 0) {\n      map = null;\n      EVENT_MAP[\"delete\"](_this);\n    }\n\n    _this.trigger(event);\n  }, 0);\n  map.set(type, timeout);\n};\n/**\n * @file mixins/evented.js\n * @module evented\n */\n\n/**\n * Returns whether or not an object has had the evented mixin applied.\n *\n * @param  {Object} object\n *         An object to test.\n *\n * @return {boolean}\n *         Whether or not the object appears to be evented.\n */\n\n\nvar isEvented = function isEvented(object) {\n  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {\n    return typeof object[k] === 'function';\n  });\n};\n/**\n * Adds a callback to run after the evented mixin applied.\n *\n * @param  {Object} object\n *         An object to Add\n * @param  {Function} callback\n *         The callback to run.\n */\n\n\nvar addEventedCallback = function addEventedCallback(target, callback) {\n  if (isEvented(target)) {\n    callback();\n  } else {\n    if (!target.eventedCallbacks) {\n      target.eventedCallbacks = [];\n    }\n\n    target.eventedCallbacks.push(callback);\n  }\n};\n/**\n * Whether a value is a valid event type - non-empty string or array.\n *\n * @private\n * @param  {string|Array} type\n *         The type value to test.\n *\n * @return {boolean}\n *         Whether or not the type is a valid event type.\n */\n\n\nvar isValidEventType = function isValidEventType(type) {\n  return (// The regex here verifies that the `type` contains at least one non-\n    // whitespace character.\n    typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length\n  );\n};\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the target does not appear to be a valid event target.\n *\n * @param  {Object} target\n *         The object to test.\n */\n\n\nvar validateTarget = function validateTarget(target) {\n  if (!target.nodeName && !isEvented(target)) {\n    throw new Error('Invalid target; must be a DOM node or evented object.');\n  }\n};\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the type does not appear to be a valid event type.\n *\n * @param  {string|Array} type\n *         The type to test.\n */\n\n\nvar validateEventType = function validateEventType(type) {\n  if (!isValidEventType(type)) {\n    throw new Error('Invalid event type; must be a non-empty string or array.');\n  }\n};\n/**\n * Validates a value to determine if it is a valid listener. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the listener is not a function.\n *\n * @param  {Function} listener\n *         The listener to test.\n */\n\n\nvar validateListener = function validateListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Invalid listener; must be a function.');\n  }\n};\n/**\n * Takes an array of arguments given to `on()` or `one()`, validates them, and\n * normalizes them into an object.\n *\n * @private\n * @param  {Object} self\n *         The evented object on which `on()` or `one()` was called. This\n *         object will be bound as the `this` value for the listener.\n *\n * @param  {Array} args\n *         An array of arguments passed to `on()` or `one()`.\n *\n * @return {Object}\n *         An object containing useful values for `on()` or `one()` calls.\n */\n\n\nvar normalizeListenArgs = function normalizeListenArgs(self, args) {\n  // If the number of arguments is less than 3, the target is always the\n  // evented object itself.\n  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n  var target;\n  var type;\n  var listener;\n\n  if (isTargetingSelf) {\n    target = self.eventBusEl_; // Deal with cases where we got 3 arguments, but we are still listening to\n    // the evented object itself.\n\n    if (args.length >= 3) {\n      args.shift();\n    }\n\n    type = args[0];\n    listener = args[1];\n  } else {\n    target = args[0];\n    type = args[1];\n    listener = args[2];\n  }\n\n  validateTarget(target);\n  validateEventType(type);\n  validateListener(listener);\n  listener = bind(self, listener);\n  return {\n    isTargetingSelf: isTargetingSelf,\n    target: target,\n    type: type,\n    listener: listener\n  };\n};\n/**\n * Adds the listener to the event type(s) on the target, normalizing for\n * the type of target.\n *\n * @private\n * @param  {Element|Object} target\n *         A DOM node or evented object.\n *\n * @param  {string} method\n *         The event binding method to use (\"on\" or \"one\").\n *\n * @param  {string|Array} type\n *         One or more event type(s).\n *\n * @param  {Function} listener\n *         A listener function.\n */\n\n\nvar listen = function listen(target, method, type, listener) {\n  validateTarget(target);\n\n  if (target.nodeName) {\n    Events[method](target, type, listener);\n  } else {\n    target[method](type, listener);\n  }\n};\n/**\n * Contains methods that provide event capabilities to an object which is passed\n * to {@link module:evented|evented}.\n *\n * @mixin EventedMixin\n */\n\n\nvar EventedMixin = {\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  on: function on() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _normalizeListenArgs = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,\n        target = _normalizeListenArgs.target,\n        type = _normalizeListenArgs.type,\n        listener = _normalizeListenArgs.listener;\n\n    listen(target, 'on', type, listener); // If this object is listening to another evented object.\n\n    if (!isTargetingSelf) {\n      // If this object is disposed, remove the listener.\n      var removeListenerOnDispose = function removeListenerOnDispose() {\n        return _this.off(target, type, listener);\n      }; // Use the same function ID as the listener so we can remove it later it\n      // using the ID of the original listener.\n\n\n      removeListenerOnDispose.guid = listener.guid; // Add a listener to the target's dispose event as well. This ensures\n      // that if the target is disposed BEFORE this object, we remove the\n      // removal listener that was just added. Otherwise, we create a memory leak.\n\n      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {\n        return _this.off('dispose', removeListenerOnDispose);\n      }; // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n\n\n      removeRemoverOnTargetDispose.guid = listener.guid;\n      listen(this, 'on', 'dispose', removeListenerOnDispose);\n      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n    }\n  },\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object. The listener will be called once per event and then removed.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  one: function one() {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var _normalizeListenArgs2 = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,\n        target = _normalizeListenArgs2.target,\n        type = _normalizeListenArgs2.type,\n        listener = _normalizeListenArgs2.listener; // Targeting this evented object.\n\n\n    if (isTargetingSelf) {\n      listen(target, 'one', type, listener); // Targeting another evented object.\n    } else {\n      // TODO: This wrapper is incorrect! It should only\n      //       remove the wrapper for the event type that called it.\n      //       Instead all listners are removed on the first trigger!\n      //       see https://github.com/videojs/video.js/issues/5962\n      var wrapper = function wrapper() {\n        _this2.off(target, type, wrapper);\n\n        for (var _len3 = arguments.length, largs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          largs[_key3] = arguments[_key3];\n        }\n\n        listener.apply(null, largs);\n      }; // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n\n\n      wrapper.guid = listener.guid;\n      listen(target, 'one', type, wrapper);\n    }\n  },\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object. The listener will only be called once for the first event that is triggered\n   * then removed.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  any: function any() {\n    var _this3 = this;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var _normalizeListenArgs3 = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs3.isTargetingSelf,\n        target = _normalizeListenArgs3.target,\n        type = _normalizeListenArgs3.type,\n        listener = _normalizeListenArgs3.listener; // Targeting this evented object.\n\n\n    if (isTargetingSelf) {\n      listen(target, 'any', type, listener); // Targeting another evented object.\n    } else {\n      var wrapper = function wrapper() {\n        _this3.off(target, type, wrapper);\n\n        for (var _len5 = arguments.length, largs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          largs[_key5] = arguments[_key5];\n        }\n\n        listener.apply(null, largs);\n      }; // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n\n\n      wrapper.guid = listener.guid;\n      listen(target, 'any', type, wrapper);\n    }\n  },\n\n  /**\n   * Removes listener(s) from event(s) on an evented object.\n   *\n   * @param  {string|Array|Element|Object} [targetOrType]\n   *         If this is a string or array, it represents the event type(s).\n   *\n   *         Another evented object can be passed here instead, in which case\n   *         ALL 3 arguments are _required_.\n   *\n   * @param  {string|Array|Function} [typeOrListener]\n   *         If the first argument was a string or array, this may be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function; otherwise, _all_ listeners bound to the\n   *         event type(s) will be removed.\n   */\n  off: function off$1(targetOrType, typeOrListener, listener) {\n    // Targeting this evented object.\n    if (!targetOrType || isValidEventType(targetOrType)) {\n      off(this.eventBusEl_, targetOrType, typeOrListener); // Targeting another evented object.\n    } else {\n      var target = targetOrType;\n      var type = typeOrListener; // Fail fast and in a meaningful way!\n\n      validateTarget(target);\n      validateEventType(type);\n      validateListener(listener); // Ensure there's at least a guid, even if the function hasn't been used\n\n      listener = bind(this, listener); // Remove the dispose listener on this evented object, which was given\n      // the same guid as the event listener in on().\n\n      this.off('dispose', listener);\n\n      if (target.nodeName) {\n        off(target, type, listener);\n        off(target, 'dispose', listener);\n      } else if (isEvented(target)) {\n        target.off(type, listener);\n        target.off('dispose', listener);\n      }\n    }\n  },\n\n  /**\n   * Fire an event on this evented object, causing its listeners to be called.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash]\n   *          An additional object to pass along to listeners.\n   *\n   * @return {boolean}\n   *          Whether or not the default behavior was prevented.\n   */\n  trigger: function trigger$1(event, hash) {\n    return trigger(this.eventBusEl_, event, hash);\n  }\n};\n/**\n * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n *\n * @param  {Object} target\n *         The object to which to add event methods.\n *\n * @param  {Object} [options={}]\n *         Options for customizing the mixin behavior.\n *\n * @param  {string} [options.eventBusKey]\n *         By default, adds a `eventBusEl_` DOM element to the target object,\n *         which is used as an event bus. If the target object already has a\n *         DOM element that should be used, pass its key here.\n *\n * @return {Object}\n *         The target object.\n */\n\nfunction evented(target, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      eventBusKey = _options.eventBusKey; // Set or create the eventBusEl_.\n\n  if (eventBusKey) {\n    if (!target[eventBusKey].nodeName) {\n      throw new Error(\"The eventBusKey \\\"\" + eventBusKey + \"\\\" does not refer to an element.\");\n    }\n\n    target.eventBusEl_ = target[eventBusKey];\n  } else {\n    target.eventBusEl_ = createEl('span', {\n      className: 'vjs-event-bus'\n    });\n  }\n\n  assign(target, EventedMixin);\n\n  if (target.eventedCallbacks) {\n    target.eventedCallbacks.forEach(function (callback) {\n      callback();\n    });\n  } // When any evented object is disposed, it removes all its listeners.\n\n\n  target.on('dispose', function () {\n    target.off();\n    window$1.setTimeout(function () {\n      target.eventBusEl_ = null;\n    }, 0);\n  });\n  return target;\n}\n/**\n * @file mixins/stateful.js\n * @module stateful\n */\n\n/**\n * Contains methods that provide statefulness to an object which is passed\n * to {@link module:stateful}.\n *\n * @mixin StatefulMixin\n */\n\n\nvar StatefulMixin = {\n  /**\n   * A hash containing arbitrary keys and values representing the state of\n   * the object.\n   *\n   * @type {Object}\n   */\n  state: {},\n\n  /**\n   * Set the state of an object by mutating its\n   * {@link module:stateful~StatefulMixin.state|state} object in place.\n   *\n   * @fires   module:stateful~StatefulMixin#statechanged\n   * @param   {Object|Function} stateUpdates\n   *          A new set of properties to shallow-merge into the plugin state.\n   *          Can be a plain object or a function returning a plain object.\n   *\n   * @return {Object|undefined}\n   *          An object containing changes that occurred. If no changes\n   *          occurred, returns `undefined`.\n   */\n  setState: function setState(stateUpdates) {\n    var _this = this; // Support providing the `stateUpdates` state as a function.\n\n\n    if (typeof stateUpdates === 'function') {\n      stateUpdates = stateUpdates();\n    }\n\n    var changes;\n    each(stateUpdates, function (value, key) {\n      // Record the change if the value is different from what's in the\n      // current state.\n      if (_this.state[key] !== value) {\n        changes = changes || {};\n        changes[key] = {\n          from: _this.state[key],\n          to: value\n        };\n      }\n\n      _this.state[key] = value;\n    }); // Only trigger \"statechange\" if there were changes AND we have a trigger\n    // function. This allows us to not require that the target object be an\n    // evented object.\n\n    if (changes && isEvented(this)) {\n      /**\n       * An event triggered on an object that is both\n       * {@link module:stateful|stateful} and {@link module:evented|evented}\n       * indicating that its state has changed.\n       *\n       * @event    module:stateful~StatefulMixin#statechanged\n       * @type     {Object}\n       * @property {Object} changes\n       *           A hash containing the properties that were changed and\n       *           the values they were changed `from` and `to`.\n       */\n      this.trigger({\n        changes: changes,\n        type: 'statechanged'\n      });\n    }\n\n    return changes;\n  }\n};\n/**\n * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n * object.\n *\n * If the target object is {@link module:evented|evented} and has a\n * `handleStateChanged` method, that method will be automatically bound to the\n * `statechanged` event on itself.\n *\n * @param   {Object} target\n *          The object to be made stateful.\n *\n * @param   {Object} [defaultState]\n *          A default set of properties to populate the newly-stateful object's\n *          `state` property.\n *\n * @return {Object}\n *          Returns the `target`.\n */\n\nfunction stateful(target, defaultState) {\n  assign(target, StatefulMixin); // This happens after the mixing-in because we need to replace the `state`\n  // added in that step.\n\n  target.state = assign({}, target.state, defaultState); // Auto-bind the `handleStateChanged` method of the target object if it exists.\n\n  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\n    target.on('statechanged', target.handleStateChanged);\n  }\n\n  return target;\n}\n/**\n * @file string-cases.js\n * @module to-lower-case\n */\n\n/**\n * Lowercase the first letter of a string.\n *\n * @param {string} string\n *        String to be lowercased\n *\n * @return {string}\n *         The string with a lowercased first letter\n */\n\n\nvar toLowerCase = function toLowerCase(string) {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replace(/./, function (w) {\n    return w.toLowerCase();\n  });\n};\n/**\n * Uppercase the first letter of a string.\n *\n * @param {string} string\n *        String to be uppercased\n *\n * @return {string}\n *         The string with an uppercased first letter\n */\n\n\nvar toTitleCase = function toTitleCase(string) {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replace(/./, function (w) {\n    return w.toUpperCase();\n  });\n};\n/**\n * Compares the TitleCase versions of the two strings for equality.\n *\n * @param {string} str1\n *        The first string to compare\n *\n * @param {string} str2\n *        The second string to compare\n *\n * @return {boolean}\n *         Whether the TitleCase versions of the strings are equal\n */\n\n\nvar titleCaseEquals = function titleCaseEquals(str1, str2) {\n  return toTitleCase(str1) === toTitleCase(str2);\n};\n/**\n * @file merge-options.js\n * @module merge-options\n */\n\n/**\n * Merge two objects recursively.\n *\n * Performs a deep merge like\n * {@link https://lodash.com/docs/4.17.10#merge|lodash.merge}, but only merges\n * plain objects (not arrays, elements, or anything else).\n *\n * Non-plain object values will be copied directly from the right-most\n * argument.\n *\n * @static\n * @param   {Object[]} sources\n *          One or more objects to merge into a new object.\n *\n * @return {Object}\n *          A new object that is the merged result of all sources.\n */\n\n\nfunction mergeOptions() {\n  var result = {};\n\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      if (!isPlain(value)) {\n        result[key] = value;\n        return;\n      }\n\n      if (!isPlain(result[key])) {\n        result[key] = {};\n      }\n\n      result[key] = mergeOptions(result[key], value);\n    });\n  });\n  return result;\n}\n\nvar MapSham = /*#__PURE__*/function () {\n  function MapSham() {\n    this.map_ = {};\n  }\n\n  var _proto = MapSham.prototype;\n\n  _proto.has = function has(key) {\n    return key in this.map_;\n  };\n\n  _proto[\"delete\"] = function _delete(key) {\n    var has = this.has(key);\n    delete this.map_[key];\n    return has;\n  };\n\n  _proto.set = function set(key, value) {\n    this.set_[key] = value;\n    return this;\n  };\n\n  _proto.forEach = function forEach(callback, thisArg) {\n    for (var key in this.map_) {\n      callback.call(thisArg, this.map_[key], key, this);\n    }\n  };\n\n  return MapSham;\n}();\n\nvar Map$1 = window$1.Map ? window$1.Map : MapSham;\n\nvar SetSham = /*#__PURE__*/function () {\n  function SetSham() {\n    this.set_ = {};\n  }\n\n  var _proto = SetSham.prototype;\n\n  _proto.has = function has(key) {\n    return key in this.set_;\n  };\n\n  _proto[\"delete\"] = function _delete(key) {\n    var has = this.has(key);\n    delete this.set_[key];\n    return has;\n  };\n\n  _proto.add = function add(key) {\n    this.set_[key] = 1;\n    return this;\n  };\n\n  _proto.forEach = function forEach(callback, thisArg) {\n    for (var key in this.set_) {\n      callback.call(thisArg, key, key, this);\n    }\n  };\n\n  return SetSham;\n}();\n\nvar Set = window$1.Set ? window$1.Set : SetSham;\n/**\n * Player Component - Base class for all UI objects\n *\n * @file component.js\n */\n\n/**\n * Base class for all UI Components.\n * Components are UI objects which represent both a javascript object and an element\n * in the DOM. They can be children of other components, and can have\n * children themselves.\n *\n * Components can also use methods from {@link EventTarget}\n */\n\nvar Component = /*#__PURE__*/function () {\n  /**\n   * A callback that is called when a component is ready. Does not have any\n   * paramters and any callback value will be ignored.\n   *\n   * @callback Component~ReadyCallback\n   * @this Component\n   */\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Object[]} [options.children]\n   *        An array of children objects to intialize this component with. Children objects have\n   *        a name property that will be used if more than one component of the same type needs to be\n   *        added.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Function that gets called when the `Component` is ready.\n   */\n  function Component(player, options, ready) {\n    // The component might be the player itself and we can't pass `this` to super\n    if (!player && this.play) {\n      this.player_ = player = this; // eslint-disable-line\n    } else {\n      this.player_ = player;\n    }\n\n    this.isDisposed_ = false; // Hold the reference to the parent component via `addChild` method\n\n    this.parentComponent_ = null; // Make a copy of prototype.options_ to protect against overriding defaults\n\n    this.options_ = mergeOptions({}, this.options_); // Updated options with supplied options\n\n    options = this.options_ = mergeOptions(this.options_, options); // Get ID from options or options element if one is supplied\n\n    this.id_ = options.id || options.el && options.el.id; // If there was no ID from the options, generate one\n\n    if (!this.id_) {\n      // Don't require the player ID function in the case of mock players\n      var id = player && player.id && player.id() || 'no_player';\n      this.id_ = id + \"_component_\" + newGUID();\n    }\n\n    this.name_ = options.name || null; // Create element if one wasn't provided in options\n\n    if (options.el) {\n      this.el_ = options.el;\n    } else if (options.createEl !== false) {\n      this.el_ = this.createEl();\n    } // if evented is anything except false, we want to mixin in evented\n\n\n    if (options.evented !== false) {\n      // Make this an evented object and use `el_`, if available, as its event bus\n      evented(this, {\n        eventBusKey: this.el_ ? 'el_' : null\n      });\n    }\n\n    stateful(this, this.constructor.defaultState);\n    this.children_ = [];\n    this.childIndex_ = {};\n    this.childNameIndex_ = {};\n    this.setTimeoutIds_ = new Set();\n    this.setIntervalIds_ = new Set();\n    this.rafIds_ = new Set();\n    this.namedRafs_ = new Map$1();\n    this.clearingTimersOnDispose_ = false; // Add any child components in options\n\n    if (options.initChildren !== false) {\n      this.initChildren();\n    }\n\n    this.ready(ready); // Don't want to trigger ready here or it will before init is actually\n    // finished for all children that run this constructor\n\n    if (options.reportTouchActivity !== false) {\n      this.enableTouchActivity();\n    }\n  }\n  /**\n   * Dispose of the `Component` and all child components.\n   *\n   * @fires Component#dispose\n   */\n\n\n  var _proto = Component.prototype;\n\n  _proto.dispose = function dispose() {\n    // Bail out if the component has already been disposed.\n    if (this.isDisposed_) {\n      return;\n    }\n    /**\n     * Triggered when a `Component` is disposed.\n     *\n     * @event Component#dispose\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the dispose event does not\n     *           bubble up\n     */\n\n\n    this.trigger({\n      type: 'dispose',\n      bubbles: false\n    });\n    this.isDisposed_ = true; // Dispose all children.\n\n    if (this.children_) {\n      for (var i = this.children_.length - 1; i >= 0; i--) {\n        if (this.children_[i].dispose) {\n          this.children_[i].dispose();\n        }\n      }\n    } // Delete child references\n\n\n    this.children_ = null;\n    this.childIndex_ = null;\n    this.childNameIndex_ = null;\n    this.parentComponent_ = null;\n\n    if (this.el_) {\n      // Remove element from DOM\n      if (this.el_.parentNode) {\n        this.el_.parentNode.removeChild(this.el_);\n      }\n\n      if (DomData.has(this.el_)) {\n        DomData[\"delete\"](this.el_);\n      }\n\n      this.el_ = null;\n    } // remove reference to the player after disposing of the element\n\n\n    this.player_ = null;\n  }\n  /**\n   * Determine whether or not this component has been disposed.\n   *\n   * @return {boolean}\n   *         If the component has been disposed, will be `true`. Otherwise, `false`.\n   */\n  ;\n\n  _proto.isDisposed = function isDisposed() {\n    return Boolean(this.isDisposed_);\n  }\n  /**\n   * Return the {@link Player} that the `Component` has attached to.\n   *\n   * @return {Player}\n   *         The player that this `Component` has attached to.\n   */\n  ;\n\n  _proto.player = function player() {\n    return this.player_;\n  }\n  /**\n   * Deep merge of options objects with new options.\n   * > Note: When both `obj` and `options` contain properties whose values are objects.\n   *         The two properties get merged using {@link module:mergeOptions}\n   *\n   * @param {Object} obj\n   *        The object that contains new options.\n   *\n   * @return {Object}\n   *         A new object of `this.options_` and `obj` merged together.\n   */\n  ;\n\n  _proto.options = function options(obj) {\n    if (!obj) {\n      return this.options_;\n    }\n\n    this.options_ = mergeOptions(this.options_, obj);\n    return this.options_;\n  }\n  /**\n   * Get the `Component`s DOM element\n   *\n   * @return {Element}\n   *         The DOM element for this `Component`.\n   */\n  ;\n\n  _proto.el = function el() {\n    return this.el_;\n  }\n  /**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tagName]\n   *        Element's DOM node type. e.g. 'div'\n   *\n   * @param {Object} [properties]\n   *        An object of properties that should be set.\n   *\n   * @param {Object} [attributes]\n   *        An object of attributes that should be set.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  ;\n\n  _proto.createEl = function createEl$1(tagName, properties, attributes) {\n    return createEl(tagName, properties, attributes);\n  }\n  /**\n   * Localize a string given the string in english.\n   *\n   * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n   * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.\n   *\n   * If a `defaultValue` is provided, it'll use that over `string`,\n   * if a value isn't found in provided language files.\n   * This is useful if you want to have a descriptive key for token replacement\n   * but have a succinct localized string and not require `en.json` to be included.\n   *\n   * Currently, it is used for the progress bar timing.\n   * ```js\n   * {\n   *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n   * }\n   * ```\n   * It is then used like so:\n   * ```js\n   * this.localize('progress bar timing: currentTime={1} duration{2}',\n   *               [this.player_.currentTime(), this.player_.duration()],\n   *               '{1} of {2}');\n   * ```\n   *\n   * Which outputs something like: `01:23 of 24:56`.\n   *\n   *\n   * @param {string} string\n   *        The string to localize and the key to lookup in the language files.\n   * @param {string[]} [tokens]\n   *        If the current item has token replacements, provide the tokens here.\n   * @param {string} [defaultValue]\n   *        Defaults to `string`. Can be a default value to use for token replacement\n   *        if the lookup key is needed to be separate.\n   *\n   * @return {string}\n   *         The localized string or if no localization exists the english string.\n   */\n  ;\n\n  _proto.localize = function localize(string, tokens, defaultValue) {\n    if (defaultValue === void 0) {\n      defaultValue = string;\n    }\n\n    var code = this.player_.language && this.player_.language();\n    var languages = this.player_.languages && this.player_.languages();\n    var language = languages && languages[code];\n    var primaryCode = code && code.split('-')[0];\n    var primaryLang = languages && languages[primaryCode];\n    var localizedString = defaultValue;\n\n    if (language && language[string]) {\n      localizedString = language[string];\n    } else if (primaryLang && primaryLang[string]) {\n      localizedString = primaryLang[string];\n    }\n\n    if (tokens) {\n      localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\n        var value = tokens[index - 1];\n        var ret = value;\n\n        if (typeof value === 'undefined') {\n          ret = match;\n        }\n\n        return ret;\n      });\n    }\n\n    return localizedString;\n  }\n  /**\n   * Return the `Component`s DOM element. This is where children get inserted.\n   * This will usually be the the same as the element returned in {@link Component#el}.\n   *\n   * @return {Element}\n   *         The content element for this `Component`.\n   */\n  ;\n\n  _proto.contentEl = function contentEl() {\n    return this.contentEl_ || this.el_;\n  }\n  /**\n   * Get this `Component`s ID\n   *\n   * @return {string}\n   *         The id of this `Component`\n   */\n  ;\n\n  _proto.id = function id() {\n    return this.id_;\n  }\n  /**\n   * Get the `Component`s name. The name gets used to reference the `Component`\n   * and is set during registration.\n   *\n   * @return {string}\n   *         The name of this `Component`.\n   */\n  ;\n\n  _proto.name = function name() {\n    return this.name_;\n  }\n  /**\n   * Get an array of all child components\n   *\n   * @return {Array}\n   *         The children\n   */\n  ;\n\n  _proto.children = function children() {\n    return this.children_;\n  }\n  /**\n   * Returns the child `Component` with the given `id`.\n   *\n   * @param {string} id\n   *        The id of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `id` or undefined.\n   */\n  ;\n\n  _proto.getChildById = function getChildById(id) {\n    return this.childIndex_[id];\n  }\n  /**\n   * Returns the child `Component` with the given `name`.\n   *\n   * @param {string} name\n   *        The name of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `name` or undefined.\n   */\n  ;\n\n  _proto.getChild = function getChild(name) {\n    if (!name) {\n      return;\n    }\n\n    return this.childNameIndex_[name];\n  }\n  /**\n   * Returns the descendant `Component` following the givent\n   * descendant `names`. For instance ['foo', 'bar', 'baz'] would\n   * try to get 'foo' on the current component, 'bar' on the 'foo'\n   * component and 'baz' on the 'bar' component and return undefined\n   * if any of those don't exist.\n   *\n   * @param {...string[]|...string} names\n   *        The name of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The descendant `Component` following the given descendant\n   *         `names` or undefined.\n   */\n  ;\n\n  _proto.getDescendant = function getDescendant() {\n    for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\n      names[_key] = arguments[_key];\n    } // flatten array argument into the main array\n\n\n    names = names.reduce(function (acc, n) {\n      return acc.concat(n);\n    }, []);\n    var currentChild = this;\n\n    for (var i = 0; i < names.length; i++) {\n      currentChild = currentChild.getChild(names[i]);\n\n      if (!currentChild || !currentChild.getChild) {\n        return;\n      }\n    }\n\n    return currentChild;\n  }\n  /**\n   * Add a child `Component` inside the current `Component`.\n   *\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @param {number} [index=this.children_.length]\n   *        The index to attempt to add a child into.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   */\n  ;\n\n  _proto.addChild = function addChild(child, options, index) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (index === void 0) {\n      index = this.children_.length;\n    }\n\n    var component;\n    var componentName; // If child is a string, create component with options\n\n    if (typeof child === 'string') {\n      componentName = toTitleCase(child);\n      var componentClassName = options.componentClass || componentName; // Set name through options\n\n      options.name = componentName; // Create a new object & element for this controls set\n      // If there's no .player_, this is a player\n\n      var ComponentClass = Component.getComponent(componentClassName);\n\n      if (!ComponentClass) {\n        throw new Error(\"Component \" + componentClassName + \" does not exist\");\n      } // data stored directly on the videojs object may be\n      // misidentified as a component to retain\n      // backwards-compatibility with 4.x. check to make sure the\n      // component class can be instantiated.\n\n\n      if (typeof ComponentClass !== 'function') {\n        return null;\n      }\n\n      component = new ComponentClass(this.player_ || this, options); // child is a component instance\n    } else {\n      component = child;\n    }\n\n    if (component.parentComponent_) {\n      component.parentComponent_.removeChild(component);\n    }\n\n    this.children_.splice(index, 0, component);\n    component.parentComponent_ = this;\n\n    if (typeof component.id === 'function') {\n      this.childIndex_[component.id()] = component;\n    } // If a name wasn't used to create the component, check if we can use the\n    // name function of the component\n\n\n    componentName = componentName || component.name && toTitleCase(component.name());\n\n    if (componentName) {\n      this.childNameIndex_[componentName] = component;\n      this.childNameIndex_[toLowerCase(componentName)] = component;\n    } // Add the UI object's element to the container div (box)\n    // Having an element is not required\n\n\n    if (typeof component.el === 'function' && component.el()) {\n      // If inserting before a component, insert before that component's element\n      var refNode = null;\n\n      if (this.children_[index + 1]) {\n        // Most children are components, but the video tech is an HTML element\n        if (this.children_[index + 1].el_) {\n          refNode = this.children_[index + 1].el_;\n        } else if (isEl(this.children_[index + 1])) {\n          refNode = this.children_[index + 1];\n        }\n      }\n\n      this.contentEl().insertBefore(component.el(), refNode);\n    } // Return so it can stored on parent object if desired.\n\n\n    return component;\n  }\n  /**\n   * Remove a child `Component` from this `Component`s list of children. Also removes\n   * the child `Component`s element from this `Component`s element.\n   *\n   * @param {Component} component\n   *        The child `Component` to remove.\n   */\n  ;\n\n  _proto.removeChild = function removeChild(component) {\n    if (typeof component === 'string') {\n      component = this.getChild(component);\n    }\n\n    if (!component || !this.children_) {\n      return;\n    }\n\n    var childFound = false;\n\n    for (var i = this.children_.length - 1; i >= 0; i--) {\n      if (this.children_[i] === component) {\n        childFound = true;\n        this.children_.splice(i, 1);\n        break;\n      }\n    }\n\n    if (!childFound) {\n      return;\n    }\n\n    component.parentComponent_ = null;\n    this.childIndex_[component.id()] = null;\n    this.childNameIndex_[toTitleCase(component.name())] = null;\n    this.childNameIndex_[toLowerCase(component.name())] = null;\n    var compEl = component.el();\n\n    if (compEl && compEl.parentNode === this.contentEl()) {\n      this.contentEl().removeChild(component.el());\n    }\n  }\n  /**\n   * Add and initialize default child `Component`s based upon options.\n   */\n  ;\n\n  _proto.initChildren = function initChildren() {\n    var _this = this;\n\n    var children = this.options_.children;\n\n    if (children) {\n      // `this` is `parent`\n      var parentOptions = this.options_;\n\n      var handleAdd = function handleAdd(child) {\n        var name = child.name;\n        var opts = child.opts; // Allow options for children to be set at the parent options\n        // e.g. videojs(id, { controlBar: false });\n        // instead of videojs(id, { children: { controlBar: false });\n\n        if (parentOptions[name] !== undefined) {\n          opts = parentOptions[name];\n        } // Allow for disabling default components\n        // e.g. options['children']['posterImage'] = false\n\n\n        if (opts === false) {\n          return;\n        } // Allow options to be passed as a simple boolean if no configuration\n        // is necessary.\n\n\n        if (opts === true) {\n          opts = {};\n        } // We also want to pass the original player options\n        // to each component as well so they don't need to\n        // reach back into the player for options later.\n\n\n        opts.playerOptions = _this.options_.playerOptions; // Create and add the child component.\n        // Add a direct reference to the child by name on the parent instance.\n        // If two of the same component are used, different names should be supplied\n        // for each\n\n        var newChild = _this.addChild(name, opts);\n\n        if (newChild) {\n          _this[name] = newChild;\n        }\n      }; // Allow for an array of children details to passed in the options\n\n\n      var workingChildren;\n      var Tech = Component.getComponent('Tech');\n\n      if (Array.isArray(children)) {\n        workingChildren = children;\n      } else {\n        workingChildren = Object.keys(children);\n      }\n\n      workingChildren // children that are in this.options_ but also in workingChildren  would\n      // give us extra children we do not want. So, we want to filter them out.\n      .concat(Object.keys(this.options_).filter(function (child) {\n        return !workingChildren.some(function (wchild) {\n          if (typeof wchild === 'string') {\n            return child === wchild;\n          }\n\n          return child === wchild.name;\n        });\n      })).map(function (child) {\n        var name;\n        var opts;\n\n        if (typeof child === 'string') {\n          name = child;\n          opts = children[name] || _this.options_[name] || {};\n        } else {\n          name = child.name;\n          opts = child;\n        }\n\n        return {\n          name: name,\n          opts: opts\n        };\n      }).filter(function (child) {\n        // we have to make sure that child.name isn't in the techOrder since\n        // techs are registerd as Components but can't aren't compatible\n        // See https://github.com/videojs/video.js/issues/2772\n        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));\n        return c && !Tech.isTech(c);\n      }).forEach(handleAdd);\n    }\n  }\n  /**\n   * Builds the default DOM class name. Should be overriden by sub-components.\n   *\n   * @return {string}\n   *         The DOM class name for this object.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    // Child classes can include a function that does:\n    // return 'CLASS NAME' + this._super();\n    return '';\n  }\n  /**\n   * Bind a listener to the component's ready state.\n   * Different from event listeners in that if the ready event has already happened\n   * it will trigger the function immediately.\n   *\n   * @return {Component}\n   *         Returns itself; method can be chained.\n   */\n  ;\n\n  _proto.ready = function ready(fn, sync) {\n    if (sync === void 0) {\n      sync = false;\n    }\n\n    if (!fn) {\n      return;\n    }\n\n    if (!this.isReady_) {\n      this.readyQueue_ = this.readyQueue_ || [];\n      this.readyQueue_.push(fn);\n      return;\n    }\n\n    if (sync) {\n      fn.call(this);\n    } else {\n      // Call the function asynchronously by default for consistency\n      this.setTimeout(fn, 1);\n    }\n  }\n  /**\n   * Trigger all the ready listeners for this `Component`.\n   *\n   * @fires Component#ready\n   */\n  ;\n\n  _proto.triggerReady = function triggerReady() {\n    this.isReady_ = true; // Ensure ready is triggered asynchronously\n\n    this.setTimeout(function () {\n      var readyQueue = this.readyQueue_; // Reset Ready Queue\n\n      this.readyQueue_ = [];\n\n      if (readyQueue && readyQueue.length > 0) {\n        readyQueue.forEach(function (fn) {\n          fn.call(this);\n        }, this);\n      } // Allow for using event listeners also\n\n      /**\n       * Triggered when a `Component` is ready.\n       *\n       * @event Component#ready\n       * @type {EventTarget~Event}\n       */\n\n\n      this.trigger('ready');\n    }, 1);\n  }\n  /**\n   * Find a single DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelector`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {Element|null}\n   *         the dom element that was found, or null\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n  ;\n\n  _proto.$ = function $$1(selector, context) {\n    return $(selector, context || this.contentEl());\n  }\n  /**\n   * Finds all DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelectorAll`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {NodeList}\n   *         a list of dom elements that were found\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n  ;\n\n  _proto.$$ = function $$$1(selector, context) {\n    return $$(selector, context || this.contentEl());\n  }\n  /**\n   * Check if a component's element has a CSS class name.\n   *\n   * @param {string} classToCheck\n   *        CSS class name to check.\n   *\n   * @return {boolean}\n   *         - True if the `Component` has the class.\n   *         - False if the `Component` does not have the class`\n   */\n  ;\n\n  _proto.hasClass = function hasClass$1(classToCheck) {\n    return hasClass(this.el_, classToCheck);\n  }\n  /**\n   * Add a CSS class name to the `Component`s element.\n   *\n   * @param {string} classToAdd\n   *        CSS class name to add\n   */\n  ;\n\n  _proto.addClass = function addClass$1(classToAdd) {\n    addClass(this.el_, classToAdd);\n  }\n  /**\n   * Remove a CSS class name from the `Component`s element.\n   *\n   * @param {string} classToRemove\n   *        CSS class name to remove\n   */\n  ;\n\n  _proto.removeClass = function removeClass$1(classToRemove) {\n    removeClass(this.el_, classToRemove);\n  }\n  /**\n   * Add or remove a CSS class name from the component's element.\n   * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n   *\n   * @param  {string} classToToggle\n   *         The class to add or remove based on (@link Component#hasClass}\n   *\n   * @param  {boolean|Dom~predicate} [predicate]\n   *         An {@link Dom~predicate} function or a boolean\n   */\n  ;\n\n  _proto.toggleClass = function toggleClass$1(classToToggle, predicate) {\n    toggleClass(this.el_, classToToggle, predicate);\n  }\n  /**\n   * Show the `Component`s element if it is hidden by removing the\n   * 'vjs-hidden' class name from it.\n   */\n  ;\n\n  _proto.show = function show() {\n    this.removeClass('vjs-hidden');\n  }\n  /**\n   * Hide the `Component`s element if it is currently showing by adding the\n   * 'vjs-hidden` class name to it.\n   */\n  ;\n\n  _proto.hide = function hide() {\n    this.addClass('vjs-hidden');\n  }\n  /**\n   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n   * class name to it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n  ;\n\n  _proto.lockShowing = function lockShowing() {\n    this.addClass('vjs-lock-showing');\n  }\n  /**\n   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n   * class name from it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n  ;\n\n  _proto.unlockShowing = function unlockShowing() {\n    this.removeClass('vjs-lock-showing');\n  }\n  /**\n   * Get the value of an attribute on the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to get the value from.\n   *\n   * @return {string|null}\n   *         - The value of the attribute that was asked for.\n   *         - Can be an empty string on some browsers if the attribute does not exist\n   *           or has no value\n   *         - Most browsers will return null if the attibute does not exist or has\n   *           no value.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n   */\n  ;\n\n  _proto.getAttribute = function getAttribute$1(attribute) {\n    return getAttribute(this.el_, attribute);\n  }\n  /**\n   * Set the value of an attribute on the `Component`'s element\n   *\n   * @param {string} attribute\n   *        Name of the attribute to set.\n   *\n   * @param {string} value\n   *        Value to set the attribute to.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n   */\n  ;\n\n  _proto.setAttribute = function setAttribute$1(attribute, value) {\n    setAttribute(this.el_, attribute, value);\n  }\n  /**\n   * Remove an attribute from the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to remove.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n   */\n  ;\n\n  _proto.removeAttribute = function removeAttribute$1(attribute) {\n    removeAttribute(this.el_, attribute);\n  }\n  /**\n   * Get or set the width of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The width that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *           postpixed with '%' or 'px'.\n   */\n  ;\n\n  _proto.width = function width(num, skipListeners) {\n    return this.dimension('width', num, skipListeners);\n  }\n  /**\n   * Get or set the height of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The height that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *         postpixed with '%' or 'px'.\n   */\n  ;\n\n  _proto.height = function height(num, skipListeners) {\n    return this.dimension('height', num, skipListeners);\n  }\n  /**\n   * Set both the width and height of the `Component` element at the same time.\n   *\n   * @param  {number|string} width\n   *         Width to set the `Component`s element to.\n   *\n   * @param  {number|string} height\n   *         Height to set the `Component`s element to.\n   */\n  ;\n\n  _proto.dimensions = function dimensions(width, height) {\n    // Skip componentresize listeners on width for optimization\n    this.width(width, true);\n    this.height(height);\n  }\n  /**\n   * Get or set width or height of the `Component` element. This is the shared code\n   * for the {@link Component#width} and {@link Component#height}.\n   *\n   * Things to know:\n   * - If the width or height in an number this will return the number postfixed with 'px'.\n   * - If the width/height is a percent this will return the percent postfixed with '%'\n   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n   *   for more information\n   * - If you want the computed style of the component, use {@link Component#currentWidth}\n   *   and {@link {Component#currentHeight}\n   *\n   * @fires Component#componentresize\n   *\n   * @param {string} widthOrHeight\n   8        'width' or 'height'\n   *\n   * @param  {number|string} [num]\n   8         New dimension\n   *\n   * @param  {boolean} [skipListeners]\n   *         Skip componentresize event trigger\n   *\n   * @return {number}\n   *         The dimension when getting or 0 if unset\n   */\n  ;\n\n  _proto.dimension = function dimension(widthOrHeight, num, skipListeners) {\n    if (num !== undefined) {\n      // Set to zero if null or literally NaN (NaN !== NaN)\n      if (num === null || num !== num) {\n        num = 0;\n      } // Check if using css width/height (% or px) and adjust\n\n\n      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\n        this.el_.style[widthOrHeight] = num;\n      } else if (num === 'auto') {\n        this.el_.style[widthOrHeight] = '';\n      } else {\n        this.el_.style[widthOrHeight] = num + 'px';\n      } // skipListeners allows us to avoid triggering the resize event when setting both width and height\n\n\n      if (!skipListeners) {\n        /**\n         * Triggered when a component is resized.\n         *\n         * @event Component#componentresize\n         * @type {EventTarget~Event}\n         */\n        this.trigger('componentresize');\n      }\n\n      return;\n    } // Not setting a value, so getting it\n    // Make sure element exists\n\n\n    if (!this.el_) {\n      return 0;\n    } // Get dimension value from style\n\n\n    var val = this.el_.style[widthOrHeight];\n    var pxIndex = val.indexOf('px');\n\n    if (pxIndex !== -1) {\n      // Return the pixel value with no 'px'\n      return parseInt(val.slice(0, pxIndex), 10);\n    } // No px so using % or no style was set, so falling back to offsetWidth/height\n    // If component has display:none, offset will return 0\n    // TODO: handle display:none and no dimension style using px\n\n\n    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);\n  }\n  /**\n   * Get the computed width or the height of the component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @param {string} widthOrHeight\n   *        A string containing 'width' or 'height'. Whichever one you want to get.\n   *\n   * @return {number}\n   *         The dimension that gets asked for or 0 if nothing was set\n   *         for that dimension.\n   */\n  ;\n\n  _proto.currentDimension = function currentDimension(widthOrHeight) {\n    var computedWidthOrHeight = 0;\n\n    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\n      throw new Error('currentDimension only accepts width or height value');\n    }\n\n    computedWidthOrHeight = computedStyle(this.el_, widthOrHeight); // remove 'px' from variable and parse as integer\n\n    computedWidthOrHeight = parseFloat(computedWidthOrHeight); // if the computed value is still 0, it's possible that the browser is lying\n    // and we want to check the offset values.\n    // This code also runs wherever getComputedStyle doesn't exist.\n\n    if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {\n      var rule = \"offset\" + toTitleCase(widthOrHeight);\n      computedWidthOrHeight = this.el_[rule];\n    }\n\n    return computedWidthOrHeight;\n  }\n  /**\n   * An object that contains width and height values of the `Component`s\n   * computed style. Uses `window.getComputedStyle`.\n   *\n   * @typedef {Object} Component~DimensionObject\n   *\n   * @property {number} width\n   *           The width of the `Component`s computed style.\n   *\n   * @property {number} height\n   *           The height of the `Component`s computed style.\n   */\n\n  /**\n   * Get an object that contains computed width and height values of the\n   * component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @return {Component~DimensionObject}\n   *         The computed dimensions of the component's element.\n   */\n  ;\n\n  _proto.currentDimensions = function currentDimensions() {\n    return {\n      width: this.currentDimension('width'),\n      height: this.currentDimension('height')\n    };\n  }\n  /**\n   * Get the computed width of the component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @return {number}\n   *         The computed width of the component's element.\n   */\n  ;\n\n  _proto.currentWidth = function currentWidth() {\n    return this.currentDimension('width');\n  }\n  /**\n   * Get the computed height of the component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @return {number}\n   *         The computed height of the component's element.\n   */\n  ;\n\n  _proto.currentHeight = function currentHeight() {\n    return this.currentDimension('height');\n  }\n  /**\n   * Set the focus to this component\n   */\n  ;\n\n  _proto.focus = function focus() {\n    this.el_.focus();\n  }\n  /**\n   * Remove the focus from this component\n   */\n  ;\n\n  _proto.blur = function blur() {\n    this.el_.blur();\n  }\n  /**\n   * When this Component receives a `keydown` event which it does not process,\n   *  it passes the event to the Player for handling.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    if (this.player_) {\n      // We only stop propagation here because we want unhandled events to fall\n      // back to the browser.\n      event.stopPropagation();\n      this.player_.handleKeyDown(event);\n    }\n  }\n  /**\n   * Many components used to have a `handleKeyPress` method, which was poorly\n   * named because it listened to a `keydown` event. This method name now\n   * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`\n   * will not see their method calls stop working.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to be called.\n   */\n  ;\n\n  _proto.handleKeyPress = function handleKeyPress(event) {\n    this.handleKeyDown(event);\n  }\n  /**\n   * Emit a 'tap' events when touch event support gets detected. This gets used to\n   * support toggling the controls through a tap on the video. They get enabled\n   * because every sub-component would have extra overhead otherwise.\n   *\n   * @private\n   * @fires Component#tap\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchleave\n   * @listens Component#touchcancel\n   * @listens Component#touchend\n    */\n  ;\n\n  _proto.emitTapEvents = function emitTapEvents() {\n    // Track the start time so we can determine how long the touch lasted\n    var touchStart = 0;\n    var firstTouch = null; // Maximum movement allowed during a touch event to still be considered a tap\n    // Other popular libs use anywhere from 2 (hammer.js) to 15,\n    // so 10 seems like a nice, round number.\n\n    var tapMovementThreshold = 10; // The maximum length a touch can be while still being considered a tap\n\n    var touchTimeThreshold = 200;\n    var couldBeTap;\n    this.on('touchstart', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length === 1) {\n        // Copy pageX/pageY from the object\n        firstTouch = {\n          pageX: event.touches[0].pageX,\n          pageY: event.touches[0].pageY\n        }; // Record start time so we can detect a tap vs. \"touch and hold\"\n\n        touchStart = window$1.performance.now(); // Reset couldBeTap tracking\n\n        couldBeTap = true;\n      }\n    });\n    this.on('touchmove', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length > 1) {\n        couldBeTap = false;\n      } else if (firstTouch) {\n        // Some devices will throw touchmoves for all but the slightest of taps.\n        // So, if we moved only a small distance, this could still be a tap\n        var xdiff = event.touches[0].pageX - firstTouch.pageX;\n        var ydiff = event.touches[0].pageY - firstTouch.pageY;\n        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n\n        if (touchDistance > tapMovementThreshold) {\n          couldBeTap = false;\n        }\n      }\n    });\n\n    var noTap = function noTap() {\n      couldBeTap = false;\n    }; // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n\n\n    this.on('touchleave', noTap);\n    this.on('touchcancel', noTap); // When the touch ends, measure how long it took and trigger the appropriate\n    // event\n\n    this.on('touchend', function (event) {\n      firstTouch = null; // Proceed only if the touchmove/leave/cancel event didn't happen\n\n      if (couldBeTap === true) {\n        // Measure how long the touch lasted\n        var touchTime = window$1.performance.now() - touchStart; // Make sure the touch was less than the threshold to be considered a tap\n\n        if (touchTime < touchTimeThreshold) {\n          // Don't let browser turn this into a click\n          event.preventDefault();\n          /**\n           * Triggered when a `Component` is tapped.\n           *\n           * @event Component#tap\n           * @type {EventTarget~Event}\n           */\n\n          this.trigger('tap'); // It may be good to copy the touchend event object and change the\n          // type to tap, if the other event properties aren't exact after\n          // Events.fixEvent runs (e.g. event.target)\n        }\n      }\n    });\n  }\n  /**\n   * This function reports user activity whenever touch events happen. This can get\n   * turned off by any sub-components that wants touch events to act another way.\n   *\n   * Report user touch activity when touch events occur. User activity gets used to\n   * determine when controls should show/hide. It is simple when it comes to mouse\n   * events, because any mouse event should show the controls. So we capture mouse\n   * events that bubble up to the player and report activity when that happens.\n   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n   * controls. So touch events can't help us at the player level either.\n   *\n   * User activity gets checked asynchronously. So what could happen is a tap event\n   * on the video turns the controls off. Then the `touchend` event bubbles up to\n   * the player. Which, if it reported user activity, would turn the controls right\n   * back on. We also don't want to completely block touch events from bubbling up.\n   * Furthermore a `touchmove` event and anything other than a tap, should not turn\n   * controls back on.\n   *\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchend\n   * @listens Component#touchcancel\n   */\n  ;\n\n  _proto.enableTouchActivity = function enableTouchActivity() {\n    // Don't continue if the root player doesn't support reporting user activity\n    if (!this.player() || !this.player().reportUserActivity) {\n      return;\n    } // listener for reporting that the user is active\n\n\n    var report = bind(this.player(), this.player().reportUserActivity);\n    var touchHolding;\n    this.on('touchstart', function () {\n      report(); // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n\n      this.clearInterval(touchHolding); // report at the same interval as activityCheck\n\n      touchHolding = this.setInterval(report, 250);\n    });\n\n    var touchEnd = function touchEnd(event) {\n      report(); // stop the interval that maintains activity if the touch is holding\n\n      this.clearInterval(touchHolding);\n    };\n\n    this.on('touchmove', report);\n    this.on('touchend', touchEnd);\n    this.on('touchcancel', touchEnd);\n  }\n  /**\n   * A callback that has no parameters and is bound into `Component`s context.\n   *\n   * @callback Component~GenericCallback\n   * @this Component\n   */\n\n  /**\n   * Creates a function that runs after an `x` millisecond timeout. This function is a\n   * wrapper around `window.setTimeout`. There are a few reasons to use this one\n   * instead though:\n   * 1. It gets cleared via  {@link Component#clearTimeout} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n   *\n   * > Note: You can't use `window.clearTimeout` on the id returned by this function. This\n   *         will cause its dispose listener not to get cleaned up! Please use\n   *         {@link Component#clearTimeout} or {@link Component#dispose} instead.\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function that will be run after `timeout`.\n   *\n   * @param {number} timeout\n   *        Timeout in milliseconds to delay before executing the specified function.\n   *\n   * @return {number}\n   *         Returns a timeout ID that gets used to identify the timeout. It can also\n   *         get used in {@link Component#clearTimeout} to clear the timeout that\n   *         was set.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n   */\n  ;\n\n  _proto.setTimeout = function setTimeout(fn, timeout) {\n    var _this2 = this; // declare as variables so they are properly available in timeout function\n    // eslint-disable-next-line\n\n\n    var timeoutId;\n    fn = bind(this, fn);\n    this.clearTimersOnDispose_();\n    timeoutId = window$1.setTimeout(function () {\n      if (_this2.setTimeoutIds_.has(timeoutId)) {\n        _this2.setTimeoutIds_[\"delete\"](timeoutId);\n      }\n\n      fn();\n    }, timeout);\n    this.setTimeoutIds_.add(timeoutId);\n    return timeoutId;\n  }\n  /**\n   * Clears a timeout that gets created via `window.setTimeout` or\n   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n   * use this function instead of `window.clearTimout`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} timeoutId\n   *        The id of the timeout to clear. The return value of\n   *        {@link Component#setTimeout} or `window.setTimeout`.\n   *\n   * @return {number}\n   *         Returns the timeout id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n   */\n  ;\n\n  _proto.clearTimeout = function clearTimeout(timeoutId) {\n    if (this.setTimeoutIds_.has(timeoutId)) {\n      this.setTimeoutIds_[\"delete\"](timeoutId);\n      window$1.clearTimeout(timeoutId);\n    }\n\n    return timeoutId;\n  }\n  /**\n   * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n   * around `window.setInterval`. There are a few reasons to use this one instead though.\n   * 1. It gets cleared via  {@link Component#clearInterval} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will be a {@link Component~GenericCallback}\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function to run every `x` seconds.\n   *\n   * @param {number} interval\n   *        Execute the specified function every `x` milliseconds.\n   *\n   * @return {number}\n   *         Returns an id that can be used to identify the interval. It can also be be used in\n   *         {@link Component#clearInterval} to clear the interval.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n   */\n  ;\n\n  _proto.setInterval = function setInterval(fn, interval) {\n    fn = bind(this, fn);\n    this.clearTimersOnDispose_();\n    var intervalId = window$1.setInterval(fn, interval);\n    this.setIntervalIds_.add(intervalId);\n    return intervalId;\n  }\n  /**\n   * Clears an interval that gets created via `window.setInterval` or\n   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\n   * use this function instead of `window.clearInterval`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} intervalId\n   *        The id of the interval to clear. The return value of\n   *        {@link Component#setInterval} or `window.setInterval`.\n   *\n   * @return {number}\n   *         Returns the interval id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n   */\n  ;\n\n  _proto.clearInterval = function clearInterval(intervalId) {\n    if (this.setIntervalIds_.has(intervalId)) {\n      this.setIntervalIds_[\"delete\"](intervalId);\n      window$1.clearInterval(intervalId);\n    }\n\n    return intervalId;\n  }\n  /**\n   * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n   * with a few extra bonuses:\n   *\n   * - Supports browsers that do not support rAF by falling back to\n   *   {@link Component#setTimeout}.\n   *\n   * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n   *   bound to the component).\n   *\n   * - Automatic cancellation of the rAF callback is handled if the component\n   *   is disposed before it is called.\n   *\n   * @param  {Component~GenericCallback} fn\n   *         A function that will be bound to this component and executed just\n   *         before the browser's next repaint.\n   *\n   * @return {number}\n   *         Returns an rAF ID that gets used to identify the timeout. It can\n   *         also be used in {@link Component#cancelAnimationFrame} to cancel\n   *         the animation frame callback.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n   */\n  ;\n\n  _proto.requestAnimationFrame = function requestAnimationFrame(fn) {\n    var _this3 = this; // Fall back to using a timer.\n\n\n    if (!this.supportsRaf_) {\n      return this.setTimeout(fn, 1000 / 60);\n    }\n\n    this.clearTimersOnDispose_(); // declare as variables so they are properly available in rAF function\n    // eslint-disable-next-line\n\n    var id;\n    fn = bind(this, fn);\n    id = window$1.requestAnimationFrame(function () {\n      if (_this3.rafIds_.has(id)) {\n        _this3.rafIds_[\"delete\"](id);\n      }\n\n      fn();\n    });\n    this.rafIds_.add(id);\n    return id;\n  }\n  /**\n   * Request an animation frame, but only one named animation\n   * frame will be queued. Another will never be added until\n   * the previous one finishes.\n   *\n   * @param {string} name\n   *        The name to give this requestAnimationFrame\n   *\n   * @param  {Component~GenericCallback} fn\n   *         A function that will be bound to this component and executed just\n   *         before the browser's next repaint.\n   */\n  ;\n\n  _proto.requestNamedAnimationFrame = function requestNamedAnimationFrame(name, fn) {\n    var _this4 = this;\n\n    if (this.namedRafs_.has(name)) {\n      return;\n    }\n\n    this.clearTimersOnDispose_();\n    fn = bind(this, fn);\n    var id = this.requestAnimationFrame(function () {\n      fn();\n\n      if (_this4.namedRafs_.has(name)) {\n        _this4.namedRafs_[\"delete\"](name);\n      }\n    });\n    this.namedRafs_.set(name, id);\n    return name;\n  }\n  /**\n   * Cancels a current named animation frame if it exists.\n   *\n   * @param {string} name\n   *        The name of the requestAnimationFrame to cancel.\n   */\n  ;\n\n  _proto.cancelNamedAnimationFrame = function cancelNamedAnimationFrame(name) {\n    if (!this.namedRafs_.has(name)) {\n      return;\n    }\n\n    this.cancelAnimationFrame(this.namedRafs_.get(name));\n    this.namedRafs_[\"delete\"](name);\n  }\n  /**\n   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n   * (rAF).\n   *\n   * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n   * use this function instead of `window.cancelAnimationFrame`. If you don't,\n   * your dispose listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} id\n   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n   *\n   * @return {number}\n   *         Returns the rAF ID that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n   */\n  ;\n\n  _proto.cancelAnimationFrame = function cancelAnimationFrame(id) {\n    // Fall back to using a timer.\n    if (!this.supportsRaf_) {\n      return this.clearTimeout(id);\n    }\n\n    if (this.rafIds_.has(id)) {\n      this.rafIds_[\"delete\"](id);\n      window$1.cancelAnimationFrame(id);\n    }\n\n    return id;\n  }\n  /**\n   * A function to setup `requestAnimationFrame`, `setTimeout`,\n   * and `setInterval`, clearing on dispose.\n   *\n   * > Previously each timer added and removed dispose listeners on it's own.\n   * For better performance it was decided to batch them all, and use `Set`s\n   * to track outstanding timer ids.\n   *\n   * @private\n   */\n  ;\n\n  _proto.clearTimersOnDispose_ = function clearTimersOnDispose_() {\n    var _this5 = this;\n\n    if (this.clearingTimersOnDispose_) {\n      return;\n    }\n\n    this.clearingTimersOnDispose_ = true;\n    this.one('dispose', function () {\n      [['namedRafs_', 'cancelNamedAnimationFrame'], ['rafIds_', 'cancelAnimationFrame'], ['setTimeoutIds_', 'clearTimeout'], ['setIntervalIds_', 'clearInterval']].forEach(function (_ref) {\n        var idName = _ref[0],\n            cancelName = _ref[1]; // for a `Set` key will actually be the value again\n        // so forEach((val, val) =>` but for maps we want to use\n        // the key.\n\n        _this5[idName].forEach(function (val, key) {\n          return _this5[cancelName](key);\n        });\n      });\n      _this5.clearingTimersOnDispose_ = false;\n    });\n  }\n  /**\n   * Register a `Component` with `videojs` given the name and the component.\n   *\n   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n   *         should be registered using {@link Tech.registerTech} or\n   *         {@link videojs:videojs.registerTech}.\n   *\n   * > NOTE: This function can also be seen on videojs as\n   *         {@link videojs:videojs.registerComponent}.\n   *\n   * @param {string} name\n   *        The name of the `Component` to register.\n   *\n   * @param {Component} ComponentToRegister\n   *        The `Component` class to register.\n   *\n   * @return {Component}\n   *         The `Component` that was registered.\n   */\n  ;\n\n  Component.registerComponent = function registerComponent(name, ComponentToRegister) {\n    if (typeof name !== 'string' || !name) {\n      throw new Error(\"Illegal component name, \\\"\" + name + \"\\\"; must be a non-empty string.\");\n    }\n\n    var Tech = Component.getComponent('Tech'); // We need to make sure this check is only done if Tech has been registered.\n\n    var isTech = Tech && Tech.isTech(ComponentToRegister);\n    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);\n\n    if (isTech || !isComp) {\n      var reason;\n\n      if (isTech) {\n        reason = 'techs must be registered using Tech.registerTech()';\n      } else {\n        reason = 'must be a Component subclass';\n      }\n\n      throw new Error(\"Illegal component, \\\"\" + name + \"\\\"; \" + reason + \".\");\n    }\n\n    name = toTitleCase(name);\n\n    if (!Component.components_) {\n      Component.components_ = {};\n    }\n\n    var Player = Component.getComponent('Player');\n\n    if (name === 'Player' && Player && Player.players) {\n      var players = Player.players;\n      var playerNames = Object.keys(players); // If we have players that were disposed, then their name will still be\n      // in Players.players. So, we must loop through and verify that the value\n      // for each item is not null. This allows registration of the Player component\n      // after all players have been disposed or before any were created.\n\n      if (players && playerNames.length > 0 && playerNames.map(function (pname) {\n        return players[pname];\n      }).every(Boolean)) {\n        throw new Error('Can not register Player component after player has been created.');\n      }\n    }\n\n    Component.components_[name] = ComponentToRegister;\n    Component.components_[toLowerCase(name)] = ComponentToRegister;\n    return ComponentToRegister;\n  }\n  /**\n   * Get a `Component` based on the name it was registered with.\n   *\n   * @param {string} name\n   *        The Name of the component to get.\n   *\n   * @return {Component}\n   *         The `Component` that got registered under the given name.\n   *\n   * @deprecated In `videojs` 6 this will not return `Component`s that were not\n   *             registered using {@link Component.registerComponent}. Currently we\n   *             check the global `videojs` object for a `Component` name and\n   *             return that if it exists.\n   */\n  ;\n\n  Component.getComponent = function getComponent(name) {\n    if (!name || !Component.components_) {\n      return;\n    }\n\n    return Component.components_[name];\n  };\n\n  return Component;\n}();\n/**\n * Whether or not this component supports `requestAnimationFrame`.\n *\n * This is exposed primarily for testing purposes.\n *\n * @private\n * @type {Boolean}\n */\n\n\nComponent.prototype.supportsRaf_ = typeof window$1.requestAnimationFrame === 'function' && typeof window$1.cancelAnimationFrame === 'function';\nComponent.registerComponent('Component', Component);\n/**\n * @file browser.js\n * @module browser\n */\n\nvar USER_AGENT = window$1.navigator && window$1.navigator.userAgent || '';\nvar webkitVersionMap = /AppleWebKit\\/([\\d.]+)/i.exec(USER_AGENT);\nvar appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;\n/**\n * Whether or not this device is an iPod.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_IPOD = /iPod/i.test(USER_AGENT);\n/**\n * The detected iOS version - or `null`.\n *\n * @static\n * @const\n * @type {string|null}\n */\n\nvar IOS_VERSION = function () {\n  var match = USER_AGENT.match(/OS (\\d+)_/i);\n\n  if (match && match[1]) {\n    return match[1];\n  }\n\n  return null;\n}();\n/**\n * Whether or not this is an Android device.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\n\nvar IS_ANDROID = /Android/i.test(USER_AGENT);\n/**\n * The detected Android version - or `null`.\n *\n * @static\n * @const\n * @type {number|string|null}\n */\n\nvar ANDROID_VERSION = function () {\n  // This matches Android Major.Minor.Patch versions\n  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n  var match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\n\n  if (!match) {\n    return null;\n  }\n\n  var major = match[1] && parseFloat(match[1]);\n  var minor = match[2] && parseFloat(match[2]);\n\n  if (major && minor) {\n    return parseFloat(match[1] + '.' + match[2]);\n  } else if (major) {\n    return major;\n  }\n\n  return null;\n}();\n/**\n * Whether or not this is a native Android browser.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\n\nvar IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;\n/**\n * Whether or not this is Mozilla Firefox.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_FIREFOX = /Firefox/i.test(USER_AGENT);\n/**\n * Whether or not this is Microsoft Edge.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_EDGE = /Edg/i.test(USER_AGENT);\n/**\n * Whether or not this is Google Chrome.\n *\n * This will also be `true` for Chrome on iOS, which will have different support\n * as it is actually Safari under the hood.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));\n/**\n * The detected Google Chrome version - or `null`.\n *\n * @static\n * @const\n * @type {number|null}\n */\n\nvar CHROME_VERSION = function () {\n  var match = USER_AGENT.match(/(Chrome|CriOS)\\/(\\d+)/);\n\n  if (match && match[2]) {\n    return parseFloat(match[2]);\n  }\n\n  return null;\n}();\n/**\n * The detected Internet Explorer version - or `null`.\n *\n * @static\n * @const\n * @type {number|null}\n */\n\n\nvar IE_VERSION = function () {\n  var result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\n  var version = result && parseFloat(result[1]);\n\n  if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\n    // IE 11 has a different user agent string than other IE versions\n    version = 11.0;\n  }\n\n  return version;\n}();\n/**\n * Whether or not this is desktop Safari.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\n\nvar IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\n/**\n * Whether or not this is a Windows machine.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_WINDOWS = /Windows/i.test(USER_AGENT);\n/**\n * Whether or not this device is touch-enabled.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar TOUCH_ENABLED = isReal() && ('ontouchstart' in window$1 || window$1.navigator.maxTouchPoints || window$1.DocumentTouch && window$1.document instanceof window$1.DocumentTouch);\n/**\n * Whether or not this device is an iPad.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);\n/**\n * Whether or not this device is an iPhone.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n// to identify iPhones, we need to exclude iPads.\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\n\nvar IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\n/**\n * Whether or not this is an iOS device.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\n/**\n * Whether or not this is any flavor of Safari - including iOS.\n *\n * @static\n * @const\n * @type {Boolean}\n */\n\nvar IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;\nvar browser = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  IS_IPOD: IS_IPOD,\n  IOS_VERSION: IOS_VERSION,\n  IS_ANDROID: IS_ANDROID,\n  ANDROID_VERSION: ANDROID_VERSION,\n  IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,\n  IS_FIREFOX: IS_FIREFOX,\n  IS_EDGE: IS_EDGE,\n  IS_CHROME: IS_CHROME,\n  CHROME_VERSION: CHROME_VERSION,\n  IE_VERSION: IE_VERSION,\n  IS_SAFARI: IS_SAFARI,\n  IS_WINDOWS: IS_WINDOWS,\n  TOUCH_ENABLED: TOUCH_ENABLED,\n  IS_IPAD: IS_IPAD,\n  IS_IPHONE: IS_IPHONE,\n  IS_IOS: IS_IOS,\n  IS_ANY_SAFARI: IS_ANY_SAFARI\n});\n/**\n * @file time-ranges.js\n * @module time-ranges\n */\n\n/**\n * Returns the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @typedef    {Function} TimeRangeIndex\n *\n * @param      {number} [index=0]\n *             The range number to return the time for.\n *\n * @return     {number}\n *             The time offset at the specified index.\n *\n * @deprecated The index argument must be provided.\n *             In the future, leaving it out will throw an error.\n */\n\n/**\n * An object that contains ranges of time.\n *\n * @typedef  {Object} TimeRange\n *\n * @property {number} length\n *           The number of time ranges represented by this object.\n *\n * @property {module:time-ranges~TimeRangeIndex} start\n *           Returns the time offset at which a specified time range begins.\n *\n * @property {module:time-ranges~TimeRangeIndex} end\n *           Returns the time offset at which a specified time range ends.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n */\n\n/**\n * Check if any of the time ranges are over the maximum index.\n *\n * @private\n * @param   {string} fnName\n *          The function name to use for logging\n *\n * @param   {number} index\n *          The index to check\n *\n * @param   {number} maxIndex\n *          The maximum possible index\n *\n * @throws  {Error} if the timeRanges provided are over the maxIndex\n */\n\nfunction rangeCheck(fnName, index, maxIndex) {\n  if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n    throw new Error(\"Failed to execute '\" + fnName + \"' on 'TimeRanges': The index provided (\" + index + \") is non-numeric or out of bounds (0-\" + maxIndex + \").\");\n  }\n}\n/**\n * Get the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @private\n * @param      {string} fnName\n *             The function name to use for logging\n *\n * @param      {string} valueIndex\n *             The property that should be used to get the time. should be\n *             'start' or 'end'\n *\n * @param      {Array} ranges\n *             An array of time ranges\n *\n * @param      {Array} [rangeIndex=0]\n *             The index to start the search at\n *\n * @return     {number}\n *             The time that offset at the specified index.\n *\n * @deprecated rangeIndex must be set to a value, in the future this will throw an error.\n * @throws     {Error} if rangeIndex is more than the length of ranges\n */\n\n\nfunction getRange(fnName, valueIndex, ranges, rangeIndex) {\n  rangeCheck(fnName, rangeIndex, ranges.length - 1);\n  return ranges[rangeIndex][valueIndex];\n}\n/**\n * Create a time range object given ranges of time.\n *\n * @private\n * @param   {Array} [ranges]\n *          An array of time ranges.\n */\n\n\nfunction createTimeRangesObj(ranges) {\n  if (ranges === undefined || ranges.length === 0) {\n    return {\n      length: 0,\n      start: function start() {\n        throw new Error('This TimeRanges object is empty');\n      },\n      end: function end() {\n        throw new Error('This TimeRanges object is empty');\n      }\n    };\n  }\n\n  return {\n    length: ranges.length,\n    start: getRange.bind(null, 'start', 0, ranges),\n    end: getRange.bind(null, 'end', 1, ranges)\n  };\n}\n/**\n * Create a `TimeRange` object which mimics an\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges|HTML5 TimeRanges instance}.\n *\n * @param {number|Array[]} start\n *        The start of a single range (a number) or an array of ranges (an\n *        array of arrays of two numbers each).\n *\n * @param {number} end\n *        The end of a single range. Cannot be used with the array form of\n *        the `start` argument.\n */\n\n\nfunction createTimeRanges(start, end) {\n  if (Array.isArray(start)) {\n    return createTimeRangesObj(start);\n  } else if (start === undefined || end === undefined) {\n    return createTimeRangesObj();\n  }\n\n  return createTimeRangesObj([[start, end]]);\n}\n/**\n * @file buffer.js\n * @module buffer\n */\n\n/**\n * Compute the percentage of the media that has been buffered.\n *\n * @param {TimeRange} buffered\n *        The current `TimeRange` object representing buffered time ranges\n *\n * @param {number} duration\n *        Total duration of the media\n *\n * @return {number}\n *         Percent buffered of the total duration in decimal form.\n */\n\n\nfunction bufferedPercent(buffered, duration) {\n  var bufferedDuration = 0;\n  var start;\n  var end;\n\n  if (!duration) {\n    return 0;\n  }\n\n  if (!buffered || !buffered.length) {\n    buffered = createTimeRanges(0, 0);\n  }\n\n  for (var i = 0; i < buffered.length; i++) {\n    start = buffered.start(i);\n    end = buffered.end(i); // buffered end can be bigger than duration by a very small fraction\n\n    if (end > duration) {\n      end = duration;\n    }\n\n    bufferedDuration += end - start;\n  }\n\n  return bufferedDuration / duration;\n}\n/**\n * @file fullscreen-api.js\n * @module fullscreen-api\n * @private\n */\n\n/**\n * Store the browser-specific methods for the fullscreen API.\n *\n * @type {Object}\n * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n */\n\n\nvar FullscreenApi = {\n  prefixed: true\n}; // browser API methods\n\nvar apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'], // WebKit\n['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen'], // Mozilla\n['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror', '-moz-full-screen'], // Microsoft\n['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError', '-ms-fullscreen']];\nvar specApi = apiMap[0];\nvar browserApi; // determine the supported set of functions\n\nfor (var i = 0; i < apiMap.length; i++) {\n  // check for exitFullscreen function\n  if (apiMap[i][1] in document) {\n    browserApi = apiMap[i];\n    break;\n  }\n} // map the browser API names to the spec API names\n\n\nif (browserApi) {\n  for (var _i = 0; _i < browserApi.length; _i++) {\n    FullscreenApi[specApi[_i]] = browserApi[_i];\n  }\n\n  FullscreenApi.prefixed = browserApi[0] !== specApi[0];\n}\n/**\n * @file media-error.js\n */\n\n/**\n * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n *\n * @param {number|string|Object|MediaError} value\n *        This can be of multiple types:\n *        - number: should be a standard error code\n *        - string: an error message (the code will be 0)\n *        - Object: arbitrary properties\n *        - `MediaError` (native): used to populate a video.js `MediaError` object\n *        - `MediaError` (video.js): will return itself if it's already a\n *          video.js `MediaError` object.\n *\n * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n *\n * @class MediaError\n */\n\n\nfunction MediaError(value) {\n  // Allow redundant calls to this constructor to avoid having `instanceof`\n  // checks peppered around the code.\n  if (value instanceof MediaError) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    this.code = value;\n  } else if (typeof value === 'string') {\n    // default code is zero, so this is a custom error\n    this.message = value;\n  } else if (isObject(value)) {\n    // We assign the `code` property manually because native `MediaError` objects\n    // do not expose it as an own/enumerable property of the object.\n    if (typeof value.code === 'number') {\n      this.code = value.code;\n    }\n\n    assign(this, value);\n  }\n\n  if (!this.message) {\n    this.message = MediaError.defaultMessages[this.code] || '';\n  }\n}\n/**\n * The error code that refers two one of the defined `MediaError` types\n *\n * @type {Number}\n */\n\n\nMediaError.prototype.code = 0;\n/**\n * An optional message that to show with the error. Message is not part of the HTML5\n * video spec but allows for more informative custom errors.\n *\n * @type {String}\n */\n\nMediaError.prototype.message = '';\n/**\n * An optional status code that can be set by plugins to allow even more detail about\n * the error. For example a plugin might provide a specific HTTP status code and an\n * error message for that code. Then when the plugin gets that error this class will\n * know how to display an error message for it. This allows a custom message to show\n * up on the `Player` error overlay.\n *\n * @type {Array}\n */\n\nMediaError.prototype.status = null;\n/**\n * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n * specification listed under {@link MediaError} for more information.\n *\n * @enum {array}\n * @readonly\n * @property {string} 0 - MEDIA_ERR_CUSTOM\n * @property {string} 1 - MEDIA_ERR_ABORTED\n * @property {string} 2 - MEDIA_ERR_NETWORK\n * @property {string} 3 - MEDIA_ERR_DECODE\n * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n */\n\nMediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\n/**\n * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n *\n * @type {Array}\n * @constant\n */\n\nMediaError.defaultMessages = {\n  1: 'You aborted the media playback',\n  2: 'A network error caused the media download to fail part-way.',\n  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\n  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\n  5: 'The media is encrypted and we do not have the keys to decrypt it.'\n}; // Add types as properties on MediaError\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\n\nfor (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\n  MediaError[MediaError.errorTypes[errNum]] = errNum; // values should be accessible on both the class and instance\n\n  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\n} // jsdocs for instance/static members added above\n\n/**\n * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n *\n * @param  {Object}  value\n *         An object that may or may not be `Promise`-like.\n *\n * @return {boolean}\n *         Whether or not the object is `Promise`-like.\n */\n\n\nfunction isPromise(value) {\n  return value !== undefined && value !== null && typeof value.then === 'function';\n}\n/**\n * Silence a Promise-like object.\n *\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n *\n * @param  {Object} value\n *         An object that may or may not be `Promise`-like.\n */\n\n\nfunction silencePromise(value) {\n  if (isPromise(value)) {\n    value.then(null, function (e) {});\n  }\n}\n/**\n * @file text-track-list-converter.js Utilities for capturing text track state and\n * re-creating tracks based on a capture.\n *\n * @module text-track-list-converter\n */\n\n/**\n * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n * represents the {@link TextTrack}'s state.\n *\n * @param {TextTrack} track\n *        The text track to query.\n *\n * @return {Object}\n *         A serializable javascript representation of the TextTrack.\n * @private\n */\n\n\nvar trackToJson_ = function trackToJson_(track) {\n  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {\n    if (track[prop]) {\n      acc[prop] = track[prop];\n    }\n\n    return acc;\n  }, {\n    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\n      return {\n        startTime: cue.startTime,\n        endTime: cue.endTime,\n        text: cue.text,\n        id: cue.id\n      };\n    })\n  });\n  return ret;\n};\n/**\n * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n * state of all {@link TextTrack}s currently configured. The return array is compatible with\n * {@link text-track-list-converter:jsonToTextTracks}.\n *\n * @param {Tech} tech\n *        The tech object to query\n *\n * @return {Array}\n *         A serializable javascript representation of the {@link Tech}s\n *         {@link TextTrackList}.\n */\n\n\nvar textTracksToJson = function textTracksToJson(tech) {\n  var trackEls = tech.$$('track');\n  var trackObjs = Array.prototype.map.call(trackEls, function (t) {\n    return t.track;\n  });\n  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {\n    var json = trackToJson_(trackEl.track);\n\n    if (trackEl.src) {\n      json.src = trackEl.src;\n    }\n\n    return json;\n  });\n  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\n    return trackObjs.indexOf(track) === -1;\n  }).map(trackToJson_));\n};\n/**\n * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n * object {@link TextTrack} representations.\n *\n * @param {Array} json\n *        An array of `TextTrack` representation objects, like those that would be\n *        produced by `textTracksToJson`.\n *\n * @param {Tech} tech\n *        The `Tech` to create the `TextTrack`s on.\n */\n\n\nvar jsonToTextTracks = function jsonToTextTracks(json, tech) {\n  json.forEach(function (track) {\n    var addedTrack = tech.addRemoteTextTrack(track).track;\n\n    if (!track.src && track.cues) {\n      track.cues.forEach(function (cue) {\n        return addedTrack.addCue(cue);\n      });\n    }\n  });\n  return tech.textTracks();\n};\n\nvar textTrackConverter = {\n  textTracksToJson: textTracksToJson,\n  jsonToTextTracks: jsonToTextTracks,\n  trackToJson_: trackToJson_\n};\nvar MODAL_CLASS_NAME = 'vjs-modal-dialog';\n/**\n * The `ModalDialog` displays over the video and its controls, which blocks\n * interaction with the player until it is closed.\n *\n * Modal dialogs include a \"Close\" button and will close when that button\n * is activated - or when ESC is pressed anywhere.\n *\n * @extends Component\n */\n\nvar ModalDialog = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ModalDialog, _Component);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Mixed} [options.content=undefined]\n   *        Provide customized content for this modal.\n   *\n   * @param {string} [options.description]\n   *        A text description for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.fillAlways=false]\n   *        Normally, modals are automatically filled only the first time\n   *        they open. This tells the modal to refresh its content\n   *        every time it opens.\n   *\n   * @param {string} [options.label]\n   *        A text label for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.pauseOnOpen=true]\n   *        If `true`, playback will will be paused if playing when\n   *        the modal opens, and resumed when it closes.\n   *\n   * @param {boolean} [options.temporary=true]\n   *        If `true`, the modal can only be opened once; it will be\n   *        disposed as soon as it's closed.\n   *\n   * @param {boolean} [options.uncloseable=false]\n   *        If `true`, the user will not be able to close the modal\n   *        through the UI in the normal ways. Programmatic closing is\n   *        still possible.\n   */\n\n\n  function ModalDialog(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;\n\n    _this.closeable(!_this.options_.uncloseable);\n\n    _this.content(_this.options_.content); // Make sure the contentEl is defined AFTER any children are initialized\n    // because we only want the contents of the modal in the contentEl\n    // (not the UI elements like the close button).\n\n\n    _this.contentEl_ = createEl('div', {\n      className: MODAL_CLASS_NAME + \"-content\"\n    }, {\n      role: 'document'\n    });\n    _this.descEl_ = createEl('p', {\n      className: MODAL_CLASS_NAME + \"-description vjs-control-text\",\n      id: _this.el().getAttribute('aria-describedby')\n    });\n    textContent(_this.descEl_, _this.description());\n\n    _this.el_.appendChild(_this.descEl_);\n\n    _this.el_.appendChild(_this.contentEl_);\n\n    return _this;\n  }\n  /**\n   * Create the `ModalDialog`'s DOM element\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n\n\n  var _proto = ModalDialog.prototype;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass(),\n      tabIndex: -1\n    }, {\n      'aria-describedby': this.id() + \"_description\",\n      'aria-hidden': 'true',\n      'aria-label': this.label(),\n      'role': 'dialog'\n    });\n  };\n\n  _proto.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.descEl_ = null;\n    this.previouslyActiveEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  ;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return MODAL_CLASS_NAME + \" vjs-hidden \" + _Component.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Returns the label string for this modal. Primarily used for accessibility.\n   *\n   * @return {string}\n   *         the localized or raw label of this modal.\n   */\n  ;\n\n  _proto.label = function label() {\n    return this.localize(this.options_.label || 'Modal Window');\n  }\n  /**\n   * Returns the description string for this modal. Primarily used for\n   * accessibility.\n   *\n   * @return {string}\n   *         The localized or raw description of this modal.\n   */\n  ;\n\n  _proto.description = function description() {\n    var desc = this.options_.description || this.localize('This is a modal window.'); // Append a universal closeability message if the modal is closeable.\n\n    if (this.closeable()) {\n      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\n    }\n\n    return desc;\n  }\n  /**\n   * Opens the modal.\n   *\n   * @fires ModalDialog#beforemodalopen\n   * @fires ModalDialog#modalopen\n   */\n  ;\n\n  _proto.open = function open() {\n    if (!this.opened_) {\n      var player = this.player();\n      /**\n        * Fired just before a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#beforemodalopen\n        * @type {EventTarget~Event}\n        */\n\n      this.trigger('beforemodalopen');\n      this.opened_ = true; // Fill content if the modal has never opened before and\n      // never been filled.\n\n      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\n        this.fill();\n      } // If the player was playing, pause it and take note of its previously\n      // playing state.\n\n\n      this.wasPlaying_ = !player.paused();\n\n      if (this.options_.pauseOnOpen && this.wasPlaying_) {\n        player.pause();\n      }\n\n      this.on('keydown', this.handleKeyDown); // Hide controls and note if they were enabled.\n\n      this.hadControls_ = player.controls();\n      player.controls(false);\n      this.show();\n      this.conditionalFocus_();\n      this.el().setAttribute('aria-hidden', 'false');\n      /**\n        * Fired just after a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#modalopen\n        * @type {EventTarget~Event}\n        */\n\n      this.trigger('modalopen');\n      this.hasBeenOpened_ = true;\n    }\n  }\n  /**\n   * If the `ModalDialog` is currently open or closed.\n   *\n   * @param  {boolean} [value]\n   *         If given, it will open (`true`) or close (`false`) the modal.\n   *\n   * @return {boolean}\n   *         the current open state of the modaldialog\n   */\n  ;\n\n  _proto.opened = function opened(value) {\n    if (typeof value === 'boolean') {\n      this[value ? 'open' : 'close']();\n    }\n\n    return this.opened_;\n  }\n  /**\n   * Closes the modal, does nothing if the `ModalDialog` is\n   * not open.\n   *\n   * @fires ModalDialog#beforemodalclose\n   * @fires ModalDialog#modalclose\n   */\n  ;\n\n  _proto.close = function close() {\n    if (!this.opened_) {\n      return;\n    }\n\n    var player = this.player();\n    /**\n      * Fired just before a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#beforemodalclose\n      * @type {EventTarget~Event}\n      */\n\n    this.trigger('beforemodalclose');\n    this.opened_ = false;\n\n    if (this.wasPlaying_ && this.options_.pauseOnOpen) {\n      player.play();\n    }\n\n    this.off('keydown', this.handleKeyDown);\n\n    if (this.hadControls_) {\n      player.controls(true);\n    }\n\n    this.hide();\n    this.el().setAttribute('aria-hidden', 'true');\n    /**\n      * Fired just after a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#modalclose\n      * @type {EventTarget~Event}\n      */\n\n    this.trigger('modalclose');\n    this.conditionalBlur_();\n\n    if (this.options_.temporary) {\n      this.dispose();\n    }\n  }\n  /**\n   * Check to see if the `ModalDialog` is closeable via the UI.\n   *\n   * @param  {boolean} [value]\n   *         If given as a boolean, it will set the `closeable` option.\n   *\n   * @return {boolean}\n   *         Returns the final value of the closable option.\n   */\n  ;\n\n  _proto.closeable = function closeable(value) {\n    if (typeof value === 'boolean') {\n      var closeable = this.closeable_ = !!value;\n      var close = this.getChild('closeButton'); // If this is being made closeable and has no close button, add one.\n\n      if (closeable && !close) {\n        // The close button should be a child of the modal - not its\n        // content element, so temporarily change the content element.\n        var temp = this.contentEl_;\n        this.contentEl_ = this.el_;\n        close = this.addChild('closeButton', {\n          controlText: 'Close Modal Dialog'\n        });\n        this.contentEl_ = temp;\n        this.on(close, 'close', this.close);\n      } // If this is being made uncloseable and has a close button, remove it.\n\n\n      if (!closeable && close) {\n        this.off(close, 'close', this.close);\n        this.removeChild(close);\n        close.dispose();\n      }\n    }\n\n    return this.closeable_;\n  }\n  /**\n   * Fill the modal's content element with the modal's \"content\" option.\n   * The content element will be emptied before this change takes place.\n   */\n  ;\n\n  _proto.fill = function fill() {\n    this.fillWith(this.content());\n  }\n  /**\n   * Fill the modal's content element with arbitrary content.\n   * The content element will be emptied before this change takes place.\n   *\n   * @fires ModalDialog#beforemodalfill\n   * @fires ModalDialog#modalfill\n   *\n   * @param {Mixed} [content]\n   *        The same rules apply to this as apply to the `content` option.\n   */\n  ;\n\n  _proto.fillWith = function fillWith(content) {\n    var contentEl = this.contentEl();\n    var parentEl = contentEl.parentNode;\n    var nextSiblingEl = contentEl.nextSibling;\n    /**\n      * Fired just before a `ModalDialog` is filled with content.\n      *\n      * @event ModalDialog#beforemodalfill\n      * @type {EventTarget~Event}\n      */\n\n    this.trigger('beforemodalfill');\n    this.hasBeenFilled_ = true; // Detach the content element from the DOM before performing\n    // manipulation to avoid modifying the live DOM multiple times.\n\n    parentEl.removeChild(contentEl);\n    this.empty();\n    insertContent(contentEl, content);\n    /**\n     * Fired just after a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#modalfill\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('modalfill'); // Re-inject the re-filled content element.\n\n    if (nextSiblingEl) {\n      parentEl.insertBefore(contentEl, nextSiblingEl);\n    } else {\n      parentEl.appendChild(contentEl);\n    } // make sure that the close button is last in the dialog DOM\n\n\n    var closeButton = this.getChild('closeButton');\n\n    if (closeButton) {\n      parentEl.appendChild(closeButton.el_);\n    }\n  }\n  /**\n   * Empties the content element. This happens anytime the modal is filled.\n   *\n   * @fires ModalDialog#beforemodalempty\n   * @fires ModalDialog#modalempty\n   */\n  ;\n\n  _proto.empty = function empty() {\n    /**\n    * Fired just before a `ModalDialog` is emptied.\n    *\n    * @event ModalDialog#beforemodalempty\n    * @type {EventTarget~Event}\n    */\n    this.trigger('beforemodalempty');\n    emptyEl(this.contentEl());\n    /**\n    * Fired just after a `ModalDialog` is emptied.\n    *\n    * @event ModalDialog#modalempty\n    * @type {EventTarget~Event}\n    */\n\n    this.trigger('modalempty');\n  }\n  /**\n   * Gets or sets the modal content, which gets normalized before being\n   * rendered into the DOM.\n   *\n   * This does not update the DOM or fill the modal, but it is called during\n   * that process.\n   *\n   * @param  {Mixed} [value]\n   *         If defined, sets the internal content value to be used on the\n   *         next call(s) to `fill`. This value is normalized before being\n   *         inserted. To \"clear\" the internal content value, pass `null`.\n   *\n   * @return {Mixed}\n   *         The current content of the modal dialog\n   */\n  ;\n\n  _proto.content = function content(value) {\n    if (typeof value !== 'undefined') {\n      this.content_ = value;\n    }\n\n    return this.content_;\n  }\n  /**\n   * conditionally focus the modal dialog if focus was previously on the player.\n   *\n   * @private\n   */\n  ;\n\n  _proto.conditionalFocus_ = function conditionalFocus_() {\n    var activeEl = document.activeElement;\n    var playerEl = this.player_.el_;\n    this.previouslyActiveEl_ = null;\n\n    if (playerEl.contains(activeEl) || playerEl === activeEl) {\n      this.previouslyActiveEl_ = activeEl;\n      this.focus();\n    }\n  }\n  /**\n   * conditionally blur the element and refocus the last focused element\n   *\n   * @private\n   */\n  ;\n\n  _proto.conditionalBlur_ = function conditionalBlur_() {\n    if (this.previouslyActiveEl_) {\n      this.previouslyActiveEl_.focus();\n      this.previouslyActiveEl_ = null;\n    }\n  }\n  /**\n   * Keydown handler. Attached when modal is focused.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // Do not allow keydowns to reach out of the modal dialog.\n    event.stopPropagation();\n\n    if (keycode.isEventKey(event, 'Escape') && this.closeable()) {\n      event.preventDefault();\n      this.close();\n      return;\n    } // exit early if it isn't a tab key\n\n\n    if (!keycode.isEventKey(event, 'Tab')) {\n      return;\n    }\n\n    var focusableEls = this.focusableEls_();\n    var activeEl = this.el_.querySelector(':focus');\n    var focusIndex;\n\n    for (var i = 0; i < focusableEls.length; i++) {\n      if (activeEl === focusableEls[i]) {\n        focusIndex = i;\n        break;\n      }\n    }\n\n    if (document.activeElement === this.el_) {\n      focusIndex = 0;\n    }\n\n    if (event.shiftKey && focusIndex === 0) {\n      focusableEls[focusableEls.length - 1].focus();\n      event.preventDefault();\n    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\n      focusableEls[0].focus();\n      event.preventDefault();\n    }\n  }\n  /**\n   * get all focusable elements\n   *\n   * @private\n   */\n  ;\n\n  _proto.focusableEls_ = function focusableEls_() {\n    var allChildren = this.el_.querySelectorAll('*');\n    return Array.prototype.filter.call(allChildren, function (child) {\n      return (child instanceof window$1.HTMLAnchorElement || child instanceof window$1.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window$1.HTMLInputElement || child instanceof window$1.HTMLSelectElement || child instanceof window$1.HTMLTextAreaElement || child instanceof window$1.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window$1.HTMLIFrameElement || child instanceof window$1.HTMLObjectElement || child instanceof window$1.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\n    });\n  };\n\n  return ModalDialog;\n}(Component);\n/**\n * Default options for `ModalDialog` default options.\n *\n * @type {Object}\n * @private\n */\n\n\nModalDialog.prototype.options_ = {\n  pauseOnOpen: true,\n  temporary: true\n};\nComponent.registerComponent('ModalDialog', ModalDialog);\n/**\n * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n * {@link VideoTrackList}\n *\n * @extends EventTarget\n */\n\nvar TrackList = /*#__PURE__*/function (_EventTarget) {\n  _inheritsLoose(TrackList, _EventTarget);\n  /**\n   * Create an instance of this class\n   *\n   * @param {Track[]} tracks\n   *        A list of tracks to initialize the list with.\n   *\n   * @abstract\n   */\n\n\n  function TrackList(tracks) {\n    var _this;\n\n    if (tracks === void 0) {\n      tracks = [];\n    }\n\n    _this = _EventTarget.call(this) || this;\n    _this.tracks_ = [];\n    /**\n     * @memberof TrackList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'length', {\n      get: function get() {\n        return this.tracks_.length;\n      }\n    });\n\n    for (var i = 0; i < tracks.length; i++) {\n      _this.addTrack(tracks[i]);\n    }\n\n    return _this;\n  }\n  /**\n   * Add a {@link Track} to the `TrackList`\n   *\n   * @param {Track} track\n   *        The audio, video, or text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  var _proto = TrackList.prototype;\n\n  _proto.addTrack = function addTrack(track) {\n    var index = this.tracks_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get() {\n          return this.tracks_[index];\n        }\n      });\n    } // Do not add duplicate tracks\n\n\n    if (this.tracks_.indexOf(track) === -1) {\n      this.tracks_.push(track);\n      /**\n       * Triggered when a track is added to a track list.\n       *\n       * @event TrackList#addtrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was added.\n       */\n\n      this.trigger({\n        track: track,\n        type: 'addtrack',\n        target: this\n      });\n    }\n  }\n  /**\n   * Remove a {@link Track} from the `TrackList`\n   *\n   * @param {Track} rtrack\n   *        The audio, video, or text track to remove from the list.\n   *\n   * @fires TrackList#removetrack\n   */\n  ;\n\n  _proto.removeTrack = function removeTrack(rtrack) {\n    var track;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (this[i] === rtrack) {\n        track = this[i];\n\n        if (track.off) {\n          track.off();\n        }\n\n        this.tracks_.splice(i, 1);\n        break;\n      }\n    }\n\n    if (!track) {\n      return;\n    }\n    /**\n     * Triggered when a track is removed from track list.\n     *\n     * @event TrackList#removetrack\n     * @type {EventTarget~Event}\n     * @property {Track} track\n     *           A reference to track that was removed.\n     */\n\n\n    this.trigger({\n      track: track,\n      type: 'removetrack',\n      target: this\n    });\n  }\n  /**\n   * Get a Track from the TrackList by a tracks id\n   *\n   * @param {string} id - the id of the track to get\n   * @method getTrackById\n   * @return {Track}\n   * @private\n   */\n  ;\n\n  _proto.getTrackById = function getTrackById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var track = this[i];\n\n      if (track.id === id) {\n        result = track;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TrackList;\n}(EventTarget);\n/**\n * Triggered when a different track is selected/enabled.\n *\n * @event TrackList#change\n * @type {EventTarget~Event}\n */\n\n/**\n * Events that can be called with on + eventName. See {@link EventHandler}.\n *\n * @property {Object} TrackList#allowedEvents_\n * @private\n */\n\n\nTrackList.prototype.allowedEvents_ = {\n  change: 'change',\n  addtrack: 'addtrack',\n  removetrack: 'removetrack'\n}; // emulate attribute EventHandler support to allow for feature detection\n\nfor (var event in TrackList.prototype.allowedEvents_) {\n  TrackList.prototype['on' + event] = null;\n}\n/**\n * Anywhere we call this function we diverge from the spec\n * as we only support one enabled audiotrack at a time\n *\n * @param {AudioTrackList} list\n *        list to work on\n *\n * @param {AudioTrack} track\n *        The track to skip\n *\n * @private\n */\n\n\nvar disableOthers = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    } // another audio track is enabled, disable it\n\n\n    list[i].enabled = false;\n  }\n};\n/**\n * The current list of {@link AudioTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n * @extends TrackList\n */\n\n\nvar AudioTrackList = /*#__PURE__*/function (_TrackList) {\n  _inheritsLoose(AudioTrackList, _TrackList);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {AudioTrack[]} [tracks=[]]\n   *        A list of `AudioTrack` to instantiate the list with.\n   */\n\n\n  function AudioTrackList(tracks) {\n    var _this;\n\n    if (tracks === void 0) {\n      tracks = [];\n    } // make sure only 1 track is enabled\n    // sorted from last index to first index\n\n\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].enabled) {\n        disableOthers(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    _this = _TrackList.call(this, tracks) || this;\n    _this.changing_ = false;\n    return _this;\n  }\n  /**\n   * Add an {@link AudioTrack} to the `AudioTrackList`.\n   *\n   * @param {AudioTrack} track\n   *        The AudioTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  var _proto = AudioTrackList.prototype;\n\n  _proto.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.enabled) {\n      disableOthers(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track); // native tracks don't have this\n\n\n    if (!track.addEventListener) {\n      return;\n    }\n\n    track.enabledChange_ = function () {\n      // when we are disabling other tracks (since we don't support\n      // more than one track at a time) we will set changing_\n      // to true so that we don't trigger additional change events\n      if (_this2.changing_) {\n        return;\n      }\n\n      _this2.changing_ = true;\n      disableOthers(_this2, track);\n      _this2.changing_ = false;\n\n      _this2.trigger('change');\n    };\n    /**\n     * @listens AudioTrack#enabledchange\n     * @fires TrackList#change\n     */\n\n\n    track.addEventListener('enabledchange', track.enabledChange_);\n  };\n\n  _proto.removeTrack = function removeTrack(rtrack) {\n    _TrackList.prototype.removeTrack.call(this, rtrack);\n\n    if (rtrack.removeEventListener && rtrack.enabledChange_) {\n      rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);\n      rtrack.enabledChange_ = null;\n    }\n  };\n\n  return AudioTrackList;\n}(TrackList);\n/**\n * Un-select all other {@link VideoTrack}s that are selected.\n *\n * @param {VideoTrackList} list\n *        list to work on\n *\n * @param {VideoTrack} track\n *        The track to skip\n *\n * @private\n */\n\n\nvar disableOthers$1 = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    } // another video track is enabled, disable it\n\n\n    list[i].selected = false;\n  }\n};\n/**\n * The current list of {@link VideoTrack} for a video.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n * @extends TrackList\n */\n\n\nvar VideoTrackList = /*#__PURE__*/function (_TrackList) {\n  _inheritsLoose(VideoTrackList, _TrackList);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {VideoTrack[]} [tracks=[]]\n   *        A list of `VideoTrack` to instantiate the list with.\n   */\n\n\n  function VideoTrackList(tracks) {\n    var _this;\n\n    if (tracks === void 0) {\n      tracks = [];\n    } // make sure only 1 track is enabled\n    // sorted from last index to first index\n\n\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].selected) {\n        disableOthers$1(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    _this = _TrackList.call(this, tracks) || this;\n    _this.changing_ = false;\n    /**\n     * @member {number} VideoTrackList#selectedIndex\n     *         The current index of the selected {@link VideoTrack`}.\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'selectedIndex', {\n      get: function get() {\n        for (var _i = 0; _i < this.length; _i++) {\n          if (this[_i].selected) {\n            return _i;\n          }\n        }\n\n        return -1;\n      },\n      set: function set() {}\n    });\n    return _this;\n  }\n  /**\n   * Add a {@link VideoTrack} to the `VideoTrackList`.\n   *\n   * @param {VideoTrack} track\n   *        The VideoTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  var _proto = VideoTrackList.prototype;\n\n  _proto.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.selected) {\n      disableOthers$1(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track); // native tracks don't have this\n\n\n    if (!track.addEventListener) {\n      return;\n    }\n\n    track.selectedChange_ = function () {\n      if (_this2.changing_) {\n        return;\n      }\n\n      _this2.changing_ = true;\n      disableOthers$1(_this2, track);\n      _this2.changing_ = false;\n\n      _this2.trigger('change');\n    };\n    /**\n     * @listens VideoTrack#selectedchange\n     * @fires TrackList#change\n     */\n\n\n    track.addEventListener('selectedchange', track.selectedChange_);\n  };\n\n  _proto.removeTrack = function removeTrack(rtrack) {\n    _TrackList.prototype.removeTrack.call(this, rtrack);\n\n    if (rtrack.removeEventListener && rtrack.selectedChange_) {\n      rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);\n      rtrack.selectedChange_ = null;\n    }\n  };\n\n  return VideoTrackList;\n}(TrackList);\n/**\n * The current list of {@link TextTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n * @extends TrackList\n */\n\n\nvar TextTrackList = /*#__PURE__*/function (_TrackList) {\n  _inheritsLoose(TextTrackList, _TrackList);\n\n  function TextTrackList() {\n    return _TrackList.apply(this, arguments) || this;\n  }\n\n  var _proto = TextTrackList.prototype;\n  /**\n   * Add a {@link TextTrack} to the `TextTrackList`\n   *\n   * @param {TextTrack} track\n   *        The text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n\n  _proto.addTrack = function addTrack(track) {\n    var _this = this;\n\n    _TrackList.prototype.addTrack.call(this, track);\n\n    if (!this.queueChange_) {\n      this.queueChange_ = function () {\n        return _this.queueTrigger('change');\n      };\n    }\n\n    if (!this.triggerSelectedlanguagechange) {\n      this.triggerSelectedlanguagechange_ = function () {\n        return _this.trigger('selectedlanguagechange');\n      };\n    }\n    /**\n     * @listens TextTrack#modechange\n     * @fires TrackList#change\n     */\n\n\n    track.addEventListener('modechange', this.queueChange_);\n    var nonLanguageTextTrackKind = ['metadata', 'chapters'];\n\n    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\n      track.addEventListener('modechange', this.triggerSelectedlanguagechange_);\n    }\n  };\n\n  _proto.removeTrack = function removeTrack(rtrack) {\n    _TrackList.prototype.removeTrack.call(this, rtrack); // manually remove the event handlers we added\n\n\n    if (rtrack.removeEventListener) {\n      if (this.queueChange_) {\n        rtrack.removeEventListener('modechange', this.queueChange_);\n      }\n\n      if (this.selectedlanguagechange_) {\n        rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);\n      }\n    }\n  };\n\n  return TextTrackList;\n}(TrackList);\n/**\n * @file html-track-element-list.js\n */\n\n/**\n * The current list of {@link HtmlTrackElement}s.\n */\n\n\nvar HtmlTrackElementList = /*#__PURE__*/function () {\n  /**\n   * Create an instance of this class.\n   *\n   * @param {HtmlTrackElement[]} [tracks=[]]\n   *        A list of `HtmlTrackElement` to instantiate the list with.\n   */\n  function HtmlTrackElementList(trackElements) {\n    if (trackElements === void 0) {\n      trackElements = [];\n    }\n\n    this.trackElements_ = [];\n    /**\n     * @memberof HtmlTrackElementList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n\n    Object.defineProperty(this, 'length', {\n      get: function get() {\n        return this.trackElements_.length;\n      }\n    });\n\n    for (var i = 0, length = trackElements.length; i < length; i++) {\n      this.addTrackElement_(trackElements[i]);\n    }\n  }\n  /**\n   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to add to the list.\n   *\n   * @private\n   */\n\n\n  var _proto = HtmlTrackElementList.prototype;\n\n  _proto.addTrackElement_ = function addTrackElement_(trackElement) {\n    var index = this.trackElements_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get() {\n          return this.trackElements_[index];\n        }\n      });\n    } // Do not add duplicate elements\n\n\n    if (this.trackElements_.indexOf(trackElement) === -1) {\n      this.trackElements_.push(trackElement);\n    }\n  }\n  /**\n   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n   * {@link TextTrack}.\n   *\n   * @param {TextTrack} track\n   *        The track associated with a track element.\n   *\n   * @return {HtmlTrackElement|undefined}\n   *         The track element that was found or undefined.\n   *\n   * @private\n   */\n  ;\n\n  _proto.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {\n    var trackElement_;\n\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (track === this.trackElements_[i].track) {\n        trackElement_ = this.trackElements_[i];\n        break;\n      }\n    }\n\n    return trackElement_;\n  }\n  /**\n   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to remove from the list.\n   *\n   * @private\n   */\n  ;\n\n  _proto.removeTrackElement_ = function removeTrackElement_(trackElement) {\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (trackElement === this.trackElements_[i]) {\n        if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {\n          this.trackElements_[i].track.off();\n        }\n\n        if (typeof this.trackElements_[i].off === 'function') {\n          this.trackElements_[i].off();\n        }\n\n        this.trackElements_.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  return HtmlTrackElementList;\n}();\n/**\n * @file text-track-cue-list.js\n */\n\n/**\n * @typedef {Object} TextTrackCueList~TextTrackCue\n *\n * @property {string} id\n *           The unique id for this text track cue\n *\n * @property {number} startTime\n *           The start time for this text track cue\n *\n * @property {number} endTime\n *           The end time for this text track cue\n *\n * @property {boolean} pauseOnExit\n *           Pause when the end time is reached if true.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n */\n\n/**\n * A List of TextTrackCues.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n */\n\n\nvar TextTrackCueList = /*#__PURE__*/function () {\n  /**\n   * Create an instance of this class..\n   *\n   * @param {Array} cues\n   *        A list of cues to be initialized with\n   */\n  function TextTrackCueList(cues) {\n    TextTrackCueList.prototype.setCues_.call(this, cues);\n    /**\n     * @memberof TextTrackCueList\n     * @member {number} length\n     *         The current number of `TextTrackCue`s in the TextTrackCueList.\n     * @instance\n     */\n\n    Object.defineProperty(this, 'length', {\n      get: function get() {\n        return this.length_;\n      }\n    });\n  }\n  /**\n   * A setter for cues in this list. Creates getters\n   * an an index for the cues.\n   *\n   * @param {Array} cues\n   *        An array of cues to set\n   *\n   * @private\n   */\n\n\n  var _proto = TextTrackCueList.prototype;\n\n  _proto.setCues_ = function setCues_(cues) {\n    var oldLength = this.length || 0;\n    var i = 0;\n    var l = cues.length;\n    this.cues_ = cues;\n    this.length_ = cues.length;\n\n    var defineProp = function defineProp(index) {\n      if (!('' + index in this)) {\n        Object.defineProperty(this, '' + index, {\n          get: function get() {\n            return this.cues_[index];\n          }\n        });\n      }\n    };\n\n    if (oldLength < l) {\n      i = oldLength;\n\n      for (; i < l; i++) {\n        defineProp.call(this, i);\n      }\n    }\n  }\n  /**\n   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n   *\n   * @param {string} id\n   *        The id of the cue that should be searched for.\n   *\n   * @return {TextTrackCueList~TextTrackCue|null}\n   *         A single cue or null if none was found.\n   */\n  ;\n\n  _proto.getCueById = function getCueById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var cue = this[i];\n\n      if (cue.id === id) {\n        result = cue;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TextTrackCueList;\n}();\n/**\n * @file track-kinds.js\n */\n\n/**\n * All possible `VideoTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n * @typedef VideoTrack~Kind\n * @enum\n */\n\n\nvar VideoTrackKind = {\n  alternative: 'alternative',\n  captions: 'captions',\n  main: 'main',\n  sign: 'sign',\n  subtitles: 'subtitles',\n  commentary: 'commentary'\n};\n/**\n * All possible `AudioTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n * @typedef AudioTrack~Kind\n * @enum\n */\n\nvar AudioTrackKind = {\n  'alternative': 'alternative',\n  'descriptions': 'descriptions',\n  'main': 'main',\n  'main-desc': 'main-desc',\n  'translation': 'translation',\n  'commentary': 'commentary'\n};\n/**\n * All possible `TextTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n * @typedef TextTrack~Kind\n * @enum\n */\n\nvar TextTrackKind = {\n  subtitles: 'subtitles',\n  captions: 'captions',\n  descriptions: 'descriptions',\n  chapters: 'chapters',\n  metadata: 'metadata'\n};\n/**\n * All possible `TextTrackMode`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n * @typedef TextTrack~Mode\n * @enum\n */\n\nvar TextTrackMode = {\n  disabled: 'disabled',\n  hidden: 'hidden',\n  showing: 'showing'\n};\n/**\n * A Track class that contains all of the common functionality for {@link AudioTrack},\n * {@link VideoTrack}, and {@link TextTrack}.\n *\n * > Note: This class should not be used directly\n *\n * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n * @extends EventTarget\n * @abstract\n */\n\nvar Track = /*#__PURE__*/function (_EventTarget) {\n  _inheritsLoose(Track, _EventTarget);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid kind for the track type you are creating.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @abstract\n   */\n\n\n  function Track(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _EventTarget.call(this) || this;\n    var trackProps = {\n      id: options.id || 'vjs_track_' + newGUID(),\n      kind: options.kind || '',\n      label: options.label || '',\n      language: options.language || ''\n    };\n    /**\n     * @memberof Track\n     * @member {string} id\n     *         The id of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} kind\n     *         The kind of track that this is. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} label\n     *         The label of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} language\n     *         The two letter language code for this track. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    var _loop = function _loop(key) {\n      Object.defineProperty(_assertThisInitialized(_this), key, {\n        get: function get() {\n          return trackProps[key];\n        },\n        set: function set() {}\n      });\n    };\n\n    for (var key in trackProps) {\n      _loop(key);\n    }\n\n    return _this;\n  }\n\n  return Track;\n}(EventTarget);\n/**\n * @file url.js\n * @module url\n */\n\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @function\n * @param    {String} url\n *           The url to parse\n *\n * @return   {url:URLObject}\n *           An object of url details\n */\n\n\nvar parseUrl = function parseUrl(url) {\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host']; // add the url to an anchor and let the browser parse the URL\n\n  var a = document.createElement('a');\n  a.href = url; // IE8 (and 9?) Fix\n  // ie8 doesn't parse the URL correctly until the anchor is actually\n  // added to the body, and an innerHTML is needed to trigger the parsing\n\n  var addToBody = a.host === '' && a.protocol !== 'file:';\n  var div;\n\n  if (addToBody) {\n    div = document.createElement('div');\n    div.innerHTML = \"<a href=\\\"\" + url + \"\\\"></a>\";\n    a = div.firstChild; // prevent the div from affecting layout\n\n    div.setAttribute('style', 'display:none; position:absolute;');\n    document.body.appendChild(div);\n  } // Copy the specific URL properties to a new object\n  // This is also needed for IE8 because the anchor loses its\n  // properties when it's removed from the dom\n\n\n  var details = {};\n\n  for (var i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  } // IE9 adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n\n\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n\n  if (!details.protocol) {\n    details.protocol = window$1.location.protocol;\n  }\n\n  if (addToBody) {\n    document.body.removeChild(div);\n  }\n\n  return details;\n};\n/**\n * Get absolute version of relative URL. Used to tell Flash the correct URL.\n *\n * @function\n * @param    {string} url\n *           URL to make absolute\n *\n * @return   {string}\n *           Absolute URL\n *\n * @see      http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\n\n\nvar getAbsoluteURL = function getAbsoluteURL(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    var div = document.createElement('div');\n    div.innerHTML = \"<a href=\\\"\" + url + \"\\\">x</a>\";\n    url = div.firstChild.href;\n  }\n\n  return url;\n};\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @function\n * @param    {string} path\n *           The fileName path like '/path/to/file.mp4'\n *\n * @return  {string}\n *           The extension in lower case or an empty string if no\n *           extension could be found.\n */\n\n\nvar getFileExtension = function getFileExtension(path) {\n  if (typeof path === 'string') {\n    var splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\n    var pathParts = splitPathRe.exec(path);\n\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n\n  return '';\n};\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @function\n * @param    {string} url\n *           The url to check.\n *\n * @param    {Object} [winLoc]\n *           the domain to check the url against, defaults to window.location\n *\n * @param    {string} [winLoc.protocol]\n *           The window location protocol defaults to window.location.protocol\n *\n * @param    {string} [winLoc.host]\n *           The window location host defaults to window.location.host\n *\n * @return   {boolean}\n *           Whether it is a cross domain request or not.\n */\n\n\nvar isCrossOrigin = function isCrossOrigin(url, winLoc) {\n  if (winLoc === void 0) {\n    winLoc = window$1.location;\n  }\n\n  var urlInfo = parseUrl(url); // IE8 protocol relative urls will return ':' for protocol\n\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol; // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n  return crossOrigin;\n};\n\nvar Url = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  parseUrl: parseUrl,\n  getAbsoluteURL: getAbsoluteURL,\n  getFileExtension: getFileExtension,\n  isCrossOrigin: isCrossOrigin\n});\n/**\n * Takes a webvtt file contents and parses it into cues\n *\n * @param {string} srcContent\n *        webVTT file contents\n *\n * @param {TextTrack} track\n *        TextTrack to add cues to. Cues come from the srcContent.\n *\n * @private\n */\n\nvar parseCues = function parseCues(srcContent, track) {\n  var parser = new window$1.WebVTT.Parser(window$1, window$1.vttjs, window$1.WebVTT.StringDecoder());\n  var errors = [];\n\n  parser.oncue = function (cue) {\n    track.addCue(cue);\n  };\n\n  parser.onparsingerror = function (error) {\n    errors.push(error);\n  };\n\n  parser.onflush = function () {\n    track.trigger({\n      type: 'loadeddata',\n      target: track\n    });\n  };\n\n  parser.parse(srcContent);\n\n  if (errors.length > 0) {\n    if (window$1.console && window$1.console.groupCollapsed) {\n      window$1.console.groupCollapsed(\"Text Track parsing errors for \" + track.src);\n    }\n\n    errors.forEach(function (error) {\n      return log.error(error);\n    });\n\n    if (window$1.console && window$1.console.groupEnd) {\n      window$1.console.groupEnd();\n    }\n  }\n\n  parser.flush();\n};\n/**\n * Load a `TextTrack` from a specified url.\n *\n * @param {string} src\n *        Url to load track from.\n *\n * @param {TextTrack} track\n *        Track to add cues to. Comes from the content at the end of `url`.\n *\n * @private\n */\n\n\nvar loadTrack = function loadTrack(src, track) {\n  var opts = {\n    uri: src\n  };\n  var crossOrigin = isCrossOrigin(src);\n\n  if (crossOrigin) {\n    opts.cors = crossOrigin;\n  }\n\n  var withCredentials = track.tech_.crossOrigin() === 'use-credentials';\n\n  if (withCredentials) {\n    opts.withCredentials = withCredentials;\n  }\n\n  XHR(opts, bind(this, function (err, response, responseBody) {\n    if (err) {\n      return log.error(err, response);\n    }\n\n    track.loaded_ = true; // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n    // NOTE: this is only used for the alt/video.novtt.js build\n\n    if (typeof window$1.WebVTT !== 'function') {\n      if (track.tech_) {\n        // to prevent use before define eslint error, we define loadHandler\n        // as a let here\n        track.tech_.any(['vttjsloaded', 'vttjserror'], function (event) {\n          if (event.type === 'vttjserror') {\n            log.error(\"vttjs failed to load, stopping trying to process \" + track.src);\n            return;\n          }\n\n          return parseCues(responseBody, track);\n        });\n      }\n    } else {\n      parseCues(responseBody, track);\n    }\n  }));\n};\n/**\n * A representation of a single `TextTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n * @extends Track\n */\n\n\nvar TextTrack = /*#__PURE__*/function (_Track) {\n  _inheritsLoose(TextTrack, _Track);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this TextTrack.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        version of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n\n\n  function TextTrack(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!options.tech) {\n      throw new Error('A tech was not provided.');\n    }\n\n    var settings = mergeOptions(options, {\n      kind: TextTrackKind[options.kind] || 'subtitles',\n      language: options.language || options.srclang || ''\n    });\n    var mode = TextTrackMode[settings.mode] || 'disabled';\n    var default_ = settings[\"default\"];\n\n    if (settings.kind === 'metadata' || settings.kind === 'chapters') {\n      mode = 'hidden';\n    }\n\n    _this = _Track.call(this, settings) || this;\n    _this.tech_ = settings.tech;\n    _this.cues_ = [];\n    _this.activeCues_ = [];\n    _this.preload_ = _this.tech_.preloadTextTracks !== false;\n    var cues = new TextTrackCueList(_this.cues_);\n    var activeCues = new TextTrackCueList(_this.activeCues_);\n    var changed = false;\n    var timeupdateHandler = bind(_assertThisInitialized(_this), function () {\n      // Accessing this.activeCues for the side-effects of updating itself\n      // due to its nature as a getter function. Do not remove or cues will\n      // stop updating!\n      // Use the setter to prevent deletion from uglify (pure_getters rule)\n      this.activeCues = this.activeCues;\n\n      if (changed) {\n        this.trigger('cuechange');\n        changed = false;\n      }\n    });\n\n    if (mode !== 'disabled') {\n      _this.tech_.ready(function () {\n        _this.tech_.on('timeupdate', timeupdateHandler);\n      }, true);\n    }\n\n    Object.defineProperties(_assertThisInitialized(_this), {\n      /**\n       * @memberof TextTrack\n       * @member {boolean} default\n       *         If this track was set to be on or off by default. Cannot be changed after\n       *         creation.\n       * @instance\n       *\n       * @readonly\n       */\n      \"default\": {\n        get: function get() {\n          return default_;\n        },\n        set: function set() {}\n      },\n\n      /**\n       * @memberof TextTrack\n       * @member {string} mode\n       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n       *         not be set if setting to an invalid mode.\n       * @instance\n       *\n       * @fires TextTrack#modechange\n       */\n      mode: {\n        get: function get() {\n          return mode;\n        },\n        set: function set(newMode) {\n          var _this2 = this;\n\n          if (!TextTrackMode[newMode]) {\n            return;\n          }\n\n          mode = newMode;\n\n          if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {\n            // On-demand load.\n            loadTrack(this.src, this);\n          }\n\n          if (mode !== 'disabled') {\n            this.tech_.ready(function () {\n              _this2.tech_.on('timeupdate', timeupdateHandler);\n            }, true);\n          } else {\n            this.tech_.off('timeupdate', timeupdateHandler);\n          }\n          /**\n           * An event that fires when mode changes on this track. This allows\n           * the TextTrackList that holds this track to act accordingly.\n           *\n           * > Note: This is not part of the spec!\n           *\n           * @event TextTrack#modechange\n           * @type {EventTarget~Event}\n           */\n\n\n          this.trigger('modechange');\n        }\n      },\n\n      /**\n       * @memberof TextTrack\n       * @member {TextTrackCueList} cues\n       *         The text track cue list for this TextTrack.\n       * @instance\n       */\n      cues: {\n        get: function get() {\n          if (!this.loaded_) {\n            return null;\n          }\n\n          return cues;\n        },\n        set: function set() {}\n      },\n\n      /**\n       * @memberof TextTrack\n       * @member {TextTrackCueList} activeCues\n       *         The list text track cues that are currently active for this TextTrack.\n       * @instance\n       */\n      activeCues: {\n        get: function get() {\n          if (!this.loaded_) {\n            return null;\n          } // nothing to do\n\n\n          if (this.cues.length === 0) {\n            return activeCues;\n          }\n\n          var ct = this.tech_.currentTime();\n          var active = [];\n\n          for (var i = 0, l = this.cues.length; i < l; i++) {\n            var cue = this.cues[i];\n\n            if (cue.startTime <= ct && cue.endTime >= ct) {\n              active.push(cue);\n            } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {\n              active.push(cue);\n            }\n          }\n\n          changed = false;\n\n          if (active.length !== this.activeCues_.length) {\n            changed = true;\n          } else {\n            for (var _i = 0; _i < active.length; _i++) {\n              if (this.activeCues_.indexOf(active[_i]) === -1) {\n                changed = true;\n              }\n            }\n          }\n\n          this.activeCues_ = active;\n          activeCues.setCues_(this.activeCues_);\n          return activeCues;\n        },\n        // /!\\ Keep this setter empty (see the timeupdate handler above)\n        set: function set() {}\n      }\n    });\n\n    if (settings.src) {\n      _this.src = settings.src;\n\n      if (!_this.preload_) {\n        // Tracks will load on-demand.\n        // Act like we're loaded for other purposes.\n        _this.loaded_ = true;\n      }\n\n      if (_this.preload_ || default_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {\n        loadTrack(_this.src, _assertThisInitialized(_this));\n      }\n    } else {\n      _this.loaded_ = true;\n    }\n\n    return _this;\n  }\n  /**\n   * Add a cue to the internal list of cues.\n   *\n   * @param {TextTrack~Cue} cue\n   *        The cue to add to our internal list\n   */\n\n\n  var _proto = TextTrack.prototype;\n\n  _proto.addCue = function addCue(originalCue) {\n    var cue = originalCue;\n\n    if (window$1.vttjs && !(originalCue instanceof window$1.vttjs.VTTCue)) {\n      cue = new window$1.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\n\n      for (var prop in originalCue) {\n        if (!(prop in cue)) {\n          cue[prop] = originalCue[prop];\n        }\n      } // make sure that `id` is copied over\n\n\n      cue.id = originalCue.id;\n      cue.originalCue_ = originalCue;\n    }\n\n    var tracks = this.tech_.textTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      if (tracks[i] !== this) {\n        tracks[i].removeCue(cue);\n      }\n    }\n\n    this.cues_.push(cue);\n    this.cues.setCues_(this.cues_);\n  }\n  /**\n   * Remove a cue from our internal list\n   *\n   * @param {TextTrack~Cue} removeCue\n   *        The cue to remove from our internal list\n   */\n  ;\n\n  _proto.removeCue = function removeCue(_removeCue) {\n    var i = this.cues_.length;\n\n    while (i--) {\n      var cue = this.cues_[i];\n\n      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {\n        this.cues_.splice(i, 1);\n        this.cues.setCues_(this.cues_);\n        break;\n      }\n    }\n  };\n\n  return TextTrack;\n}(Track);\n/**\n * cuechange - One or more cues in the track have become active or stopped being active.\n */\n\n\nTextTrack.prototype.allowedEvents_ = {\n  cuechange: 'cuechange'\n};\n/**\n * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n * only one `AudioTrack` in the list will be enabled at a time.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n * @extends Track\n */\n\nvar AudioTrack = /*#__PURE__*/function (_Track) {\n  _inheritsLoose(AudioTrack, _Track);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {AudioTrack~Kind} [options.kind='']\n   *        A valid audio track kind\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.enabled]\n   *        If this track is the one that is currently playing. If this track is part of\n   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n   */\n\n\n  function AudioTrack(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var settings = mergeOptions(options, {\n      kind: AudioTrackKind[options.kind] || ''\n    });\n    _this = _Track.call(this, settings) || this;\n    var enabled = false;\n    /**\n     * @memberof AudioTrack\n     * @member {boolean} enabled\n     *         If this `AudioTrack` is enabled or not. When setting this will\n     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'enabled', {\n      get: function get() {\n        return enabled;\n      },\n      set: function set(newEnabled) {\n        // an invalid or unchanged value\n        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\n          return;\n        }\n\n        enabled = newEnabled;\n        /**\n         * An event that fires when enabled changes on this track. This allows\n         * the AudioTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event AudioTrack#enabledchange\n         * @type {EventTarget~Event}\n         */\n\n        this.trigger('enabledchange');\n      }\n    }); // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n\n    if (settings.enabled) {\n      _this.enabled = settings.enabled;\n    }\n\n    _this.loaded_ = true;\n    return _this;\n  }\n\n  return AudioTrack;\n}(Track);\n/**\n * A representation of a single `VideoTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n * @extends Track\n */\n\n\nvar VideoTrack = /*#__PURE__*/function (_Track) {\n  _inheritsLoose(VideoTrack, _Track);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid {@link VideoTrack~Kind}\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.selected]\n   *        If this track is the one that is currently playing.\n   */\n\n\n  function VideoTrack(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var settings = mergeOptions(options, {\n      kind: VideoTrackKind[options.kind] || ''\n    });\n    _this = _Track.call(this, settings) || this;\n    var selected = false;\n    /**\n     * @memberof VideoTrack\n     * @member {boolean} selected\n     *         If this `VideoTrack` is selected or not. When setting this will\n     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'selected', {\n      get: function get() {\n        return selected;\n      },\n      set: function set(newSelected) {\n        // an invalid or unchanged value\n        if (typeof newSelected !== 'boolean' || newSelected === selected) {\n          return;\n        }\n\n        selected = newSelected;\n        /**\n         * An event that fires when selected changes on this track. This allows\n         * the VideoTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event VideoTrack#selectedchange\n         * @type {EventTarget~Event}\n         */\n\n        this.trigger('selectedchange');\n      }\n    }); // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n\n    if (settings.selected) {\n      _this.selected = settings.selected;\n    }\n\n    return _this;\n  }\n\n  return VideoTrack;\n}(Track);\n/**\n * @memberof HTMLTrackElement\n * @typedef {HTMLTrackElement~ReadyState}\n * @enum {number}\n */\n\n\nvar NONE = 0;\nvar LOADING = 1;\nvar LOADED = 2;\nvar ERROR = 3;\n/**\n * A single track represented in the DOM.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n * @extends EventTarget\n */\n\nvar HTMLTrackElement = /*#__PURE__*/function (_EventTarget) {\n  _inheritsLoose(HTMLTrackElement, _EventTarget);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this HTMLTrackElement.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n\n\n  function HTMLTrackElement(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _EventTarget.call(this) || this;\n    var readyState;\n    var track = new TextTrack(options);\n    _this.kind = track.kind;\n    _this.src = track.src;\n    _this.srclang = track.language;\n    _this.label = track.label;\n    _this[\"default\"] = track[\"default\"];\n    Object.defineProperties(_assertThisInitialized(_this), {\n      /**\n       * @memberof HTMLTrackElement\n       * @member {HTMLTrackElement~ReadyState} readyState\n       *         The current ready state of the track element.\n       * @instance\n       */\n      readyState: {\n        get: function get() {\n          return readyState;\n        }\n      },\n\n      /**\n       * @memberof HTMLTrackElement\n       * @member {TextTrack} track\n       *         The underlying TextTrack object.\n       * @instance\n       *\n       */\n      track: {\n        get: function get() {\n          return track;\n        }\n      }\n    });\n    readyState = NONE;\n    /**\n     * @listens TextTrack#loadeddata\n     * @fires HTMLTrackElement#load\n     */\n\n    track.addEventListener('loadeddata', function () {\n      readyState = LOADED;\n\n      _this.trigger({\n        type: 'load',\n        target: _assertThisInitialized(_this)\n      });\n    });\n    return _this;\n  }\n\n  return HTMLTrackElement;\n}(EventTarget);\n\nHTMLTrackElement.prototype.allowedEvents_ = {\n  load: 'load'\n};\nHTMLTrackElement.NONE = NONE;\nHTMLTrackElement.LOADING = LOADING;\nHTMLTrackElement.LOADED = LOADED;\nHTMLTrackElement.ERROR = ERROR;\n/*\n * This file contains all track properties that are used in\n * player.js, tech.js, html5.js and possibly other techs in the future.\n */\n\nvar NORMAL = {\n  audio: {\n    ListClass: AudioTrackList,\n    TrackClass: AudioTrack,\n    capitalName: 'Audio'\n  },\n  video: {\n    ListClass: VideoTrackList,\n    TrackClass: VideoTrack,\n    capitalName: 'Video'\n  },\n  text: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'Text'\n  }\n};\nObject.keys(NORMAL).forEach(function (type) {\n  NORMAL[type].getterName = type + \"Tracks\";\n  NORMAL[type].privateName = type + \"Tracks_\";\n});\nvar REMOTE = {\n  remoteText: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'RemoteText',\n    getterName: 'remoteTextTracks',\n    privateName: 'remoteTextTracks_'\n  },\n  remoteTextEl: {\n    ListClass: HtmlTrackElementList,\n    TrackClass: HTMLTrackElement,\n    capitalName: 'RemoteTextTrackEls',\n    getterName: 'remoteTextTrackEls',\n    privateName: 'remoteTextTrackEls_'\n  }\n};\n\nvar ALL = _extends({}, NORMAL, REMOTE);\n\nREMOTE.names = Object.keys(REMOTE);\nNORMAL.names = Object.keys(NORMAL);\nALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\n/**\n * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n * that just contains the src url alone.\n * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n   * `var SourceString = 'http://example.com/some-video.mp4';`\n *\n * @typedef {Object|string} Tech~SourceObject\n *\n * @property {string} src\n *           The url to the source\n *\n * @property {string} type\n *           The mime type of the source\n */\n\n/**\n * A function used by {@link Tech} to create a new {@link TextTrack}.\n *\n * @private\n *\n * @param {Tech} self\n *        An instance of the Tech class.\n *\n * @param {string} kind\n *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n *\n * @param {string} [label]\n *        Label to identify the text track\n *\n * @param {string} [language]\n *        Two letter language abbreviation\n *\n * @param {Object} [options={}]\n *        An object with additional text track options\n *\n * @return {TextTrack}\n *          The text track that was created.\n */\n\nfunction createTrackHelper(self, kind, label, language, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var tracks = self.textTracks();\n  options.kind = kind;\n\n  if (label) {\n    options.label = label;\n  }\n\n  if (language) {\n    options.language = language;\n  }\n\n  options.tech = self;\n  var track = new ALL.text.TrackClass(options);\n  tracks.addTrack(track);\n  return track;\n}\n/**\n * This is the base class for media playback technology controllers, such as\n * {@link Flash} and {@link HTML5}\n *\n * @extends Component\n */\n\n\nvar Tech = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Tech, _Component);\n  /**\n  * Create an instance of this Tech.\n  *\n  * @param {Object} [options]\n  *        The key/value store of player options.\n  *\n  * @param {Component~ReadyCallback} ready\n  *        Callback function to call when the `HTML5` Tech is ready.\n  */\n\n\n  function Tech(options, ready) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (ready === void 0) {\n      ready = function ready() {};\n    } // we don't want the tech to report user activity automatically.\n    // This is done manually in addControlsListeners\n\n\n    options.reportTouchActivity = false;\n    _this = _Component.call(this, null, options, ready) || this; // keep track of whether the current source has played at all to\n    // implement a very limited played()\n\n    _this.hasStarted_ = false;\n\n    _this.on('playing', function () {\n      this.hasStarted_ = true;\n    });\n\n    _this.on('loadstart', function () {\n      this.hasStarted_ = false;\n    });\n\n    ALL.names.forEach(function (name) {\n      var props = ALL[name];\n\n      if (options && options[props.getterName]) {\n        _this[props.privateName] = options[props.getterName];\n      }\n    }); // Manually track progress in cases where the browser/flash player doesn't report it.\n\n    if (!_this.featuresProgressEvents) {\n      _this.manualProgressOn();\n    } // Manually track timeupdates in cases where the browser/flash player doesn't report it.\n\n\n    if (!_this.featuresTimeupdateEvents) {\n      _this.manualTimeUpdatesOn();\n    }\n\n    ['Text', 'Audio', 'Video'].forEach(function (track) {\n      if (options[\"native\" + track + \"Tracks\"] === false) {\n        _this[\"featuresNative\" + track + \"Tracks\"] = false;\n      }\n    });\n\n    if (options.nativeCaptions === false || options.nativeTextTracks === false) {\n      _this.featuresNativeTextTracks = false;\n    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\n      _this.featuresNativeTextTracks = true;\n    }\n\n    if (!_this.featuresNativeTextTracks) {\n      _this.emulateTextTracks();\n    }\n\n    _this.preloadTextTracks = options.preloadTextTracks !== false;\n    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();\n\n    _this.initTrackListeners(); // Turn on component tap events only if not using native controls\n\n\n    if (!options.nativeControlsForTouch) {\n      _this.emitTapEvents();\n    }\n\n    if (_this.constructor) {\n      _this.name_ = _this.constructor.name || 'Unknown Tech';\n    }\n\n    return _this;\n  }\n  /**\n   * A special function to trigger source set in a way that will allow player\n   * to re-trigger if the player or tech are not ready yet.\n   *\n   * @fires Tech#sourceset\n   * @param {string} src The source string at the time of the source changing.\n   */\n\n\n  var _proto = Tech.prototype;\n\n  _proto.triggerSourceset = function triggerSourceset(src) {\n    var _this2 = this;\n\n    if (!this.isReady_) {\n      // on initial ready we have to trigger source set\n      // 1ms after ready so that player can watch for it.\n      this.one('ready', function () {\n        return _this2.setTimeout(function () {\n          return _this2.triggerSourceset(src);\n        }, 1);\n      });\n    }\n    /**\n     * Fired when the source is set on the tech causing the media element\n     * to reload.\n     *\n     * @see {@link Player#event:sourceset}\n     * @event Tech#sourceset\n     * @type {EventTarget~Event}\n     */\n\n\n    this.trigger({\n      src: src,\n      type: 'sourceset'\n    });\n  }\n  /* Fallbacks for unsupported event types\n  ================================================================================ */\n\n  /**\n   * Polyfill the `progress` event for browsers that don't support it natively.\n   *\n   * @see {@link Tech#trackProgress}\n   */\n  ;\n\n  _proto.manualProgressOn = function manualProgressOn() {\n    this.on('durationchange', this.onDurationChange);\n    this.manualProgress = true; // Trigger progress watching when a source begins loading\n\n    this.one('ready', this.trackProgress);\n  }\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   */\n  ;\n\n  _proto.manualProgressOff = function manualProgressOff() {\n    this.manualProgress = false;\n    this.stopTrackingProgress();\n    this.off('durationchange', this.onDurationChange);\n  }\n  /**\n   * This is used to trigger a `progress` event when the buffered percent changes. It\n   * sets an interval function that will be called every 500 milliseconds to check if the\n   * buffer end percent has changed.\n   *\n   * > This function is called by {@link Tech#manualProgressOn}\n   *\n   * @param {EventTarget~Event} event\n   *        The `ready` event that caused this to run.\n   *\n   * @listens Tech#ready\n   * @fires Tech#progress\n   */\n  ;\n\n  _proto.trackProgress = function trackProgress(event) {\n    this.stopTrackingProgress();\n    this.progressInterval = this.setInterval(bind(this, function () {\n      // Don't trigger unless buffered amount is greater than last time\n      var numBufferedPercent = this.bufferedPercent();\n\n      if (this.bufferedPercent_ !== numBufferedPercent) {\n        /**\n         * See {@link Player#progress}\n         *\n         * @event Tech#progress\n         * @type {EventTarget~Event}\n         */\n        this.trigger('progress');\n      }\n\n      this.bufferedPercent_ = numBufferedPercent;\n\n      if (numBufferedPercent === 1) {\n        this.stopTrackingProgress();\n      }\n    }), 500);\n  }\n  /**\n   * Update our internal duration on a `durationchange` event by calling\n   * {@link Tech#duration}.\n   *\n   * @param {EventTarget~Event} event\n   *        The `durationchange` event that caused this to run.\n   *\n   * @listens Tech#durationchange\n   */\n  ;\n\n  _proto.onDurationChange = function onDurationChange(event) {\n    this.duration_ = this.duration();\n  }\n  /**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */\n  ;\n\n  _proto.buffered = function buffered() {\n    return createTimeRanges(0, 0);\n  }\n  /**\n   * Get the percentage of the current video that is currently buffered.\n   *\n   * @return {number}\n   *         A number from 0 to 1 that represents the decimal percentage of the\n   *         video that is buffered.\n   *\n   */\n  ;\n\n  _proto.bufferedPercent = function bufferedPercent$1() {\n    return bufferedPercent(this.buffered(), this.duration_);\n  }\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   * Stop manually tracking progress events by clearing the interval that was set in\n   * {@link Tech#trackProgress}.\n   */\n  ;\n\n  _proto.stopTrackingProgress = function stopTrackingProgress() {\n    this.clearInterval(this.progressInterval);\n  }\n  /**\n   * Polyfill the `timeupdate` event for browsers that don't support it.\n   *\n   * @see {@link Tech#trackCurrentTime}\n   */\n  ;\n\n  _proto.manualTimeUpdatesOn = function manualTimeUpdatesOn() {\n    this.manualTimeUpdates = true;\n    this.on('play', this.trackCurrentTime);\n    this.on('pause', this.stopTrackingCurrentTime);\n  }\n  /**\n   * Turn off the polyfill for `timeupdate` events that was created in\n   * {@link Tech#manualTimeUpdatesOn}\n   */\n  ;\n\n  _proto.manualTimeUpdatesOff = function manualTimeUpdatesOff() {\n    this.manualTimeUpdates = false;\n    this.stopTrackingCurrentTime();\n    this.off('play', this.trackCurrentTime);\n    this.off('pause', this.stopTrackingCurrentTime);\n  }\n  /**\n   * Sets up an interval function to track current time and trigger `timeupdate` every\n   * 250 milliseconds.\n   *\n   * @listens Tech#play\n   * @triggers Tech#timeupdate\n   */\n  ;\n\n  _proto.trackCurrentTime = function trackCurrentTime() {\n    if (this.currentTimeInterval) {\n      this.stopTrackingCurrentTime();\n    }\n\n    this.currentTimeInterval = this.setInterval(function () {\n      /**\n       * Triggered at an interval of 250ms to indicated that time is passing in the video.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({\n        type: 'timeupdate',\n        target: this,\n        manuallyTriggered: true\n      }); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n    }, 250);\n  }\n  /**\n   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n   * `timeupdate` event is no longer triggered.\n   *\n   * @listens {Tech#pause}\n   */\n  ;\n\n  _proto.stopTrackingCurrentTime = function stopTrackingCurrentTime() {\n    this.clearInterval(this.currentTimeInterval); // #1002 - if the video ends right before the next timeupdate would happen,\n    // the progress bar won't make it all the way to the end\n\n    this.trigger({\n      type: 'timeupdate',\n      target: this,\n      manuallyTriggered: true\n    });\n  }\n  /**\n   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n   *\n   * @fires Component#dispose\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    // clear out all tracks because we can't reuse them between techs\n    this.clearTracks(NORMAL.names); // Turn off any manual progress or timeupdate tracking\n\n    if (this.manualProgress) {\n      this.manualProgressOff();\n    }\n\n    if (this.manualTimeUpdates) {\n      this.manualTimeUpdatesOff();\n    }\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n   *\n   * > Note: Techs without source handlers should call this between sources for `video`\n   *         & `audio` tracks. You don't want to use them between tracks!\n   *\n   * @param {string[]|string} types\n   *        TrackList names to clear, valid names are `video`, `audio`, and\n   *        `text`.\n   */\n  ;\n\n  _proto.clearTracks = function clearTracks(types) {\n    var _this3 = this;\n\n    types = [].concat(types); // clear out all tracks because we can't reuse them between techs\n\n    types.forEach(function (type) {\n      var list = _this3[type + \"Tracks\"]() || [];\n      var i = list.length;\n\n      while (i--) {\n        var track = list[i];\n\n        if (type === 'text') {\n          _this3.removeRemoteTextTrack(track);\n        }\n\n        list.removeTrack(track);\n      }\n    });\n  }\n  /**\n   * Remove any TextTracks added via addRemoteTextTrack that are\n   * flagged for automatic garbage collection\n   */\n  ;\n\n  _proto.cleanupAutoTextTracks = function cleanupAutoTextTracks() {\n    var list = this.autoRemoteTextTracks_ || [];\n    var i = list.length;\n\n    while (i--) {\n      var track = list[i];\n      this.removeRemoteTextTrack(track);\n    }\n  }\n  /**\n   * Reset the tech, which will removes all sources and reset the internal readyState.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.reset = function reset() {}\n  /**\n   * Get the value of `crossOrigin` from the tech.\n   *\n   * @abstract\n   *\n   * @see {Html5#crossOrigin}\n   */\n  ;\n\n  _proto.crossOrigin = function crossOrigin() {}\n  /**\n   * Set the value of `crossOrigin` on the tech.\n   *\n   * @abstract\n   *\n   * @param {string} crossOrigin the crossOrigin value\n   * @see {Html5#setCrossOrigin}\n   */\n  ;\n\n  _proto.setCrossOrigin = function setCrossOrigin() {}\n  /**\n   * Get or set an error on the Tech.\n   *\n   * @param {MediaError} [err]\n   *        Error to set on the Tech\n   *\n   * @return {MediaError|null}\n   *         The current error object on the tech, or null if there isn't one.\n   */\n  ;\n\n  _proto.error = function error(err) {\n    if (err !== undefined) {\n      this.error_ = new MediaError(err);\n      this.trigger('error');\n    }\n\n    return this.error_;\n  }\n  /**\n   * Returns the `TimeRange`s that have been played through for the current source.\n   *\n   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n   *         It only checks whether the source has played at all or not.\n   *\n   * @return {TimeRange}\n   *         - A single time range if this video has played\n   *         - An empty set of ranges if not.\n   */\n  ;\n\n  _proto.played = function played() {\n    if (this.hasStarted_) {\n      return createTimeRanges(0, 0);\n    }\n\n    return createTimeRanges();\n  }\n  /**\n   * Set whether we are scrubbing or not\n   *\n   * @abstract\n   *\n   * @see {Html5#setScrubbing}\n   */\n  ;\n\n  _proto.setScrubbing = function setScrubbing() {}\n  /**\n   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n   * previously called.\n   *\n   * @fires Tech#timeupdate\n   */\n  ;\n\n  _proto.setCurrentTime = function setCurrentTime() {\n    // improve the accuracy of manual timeupdates\n    if (this.manualTimeUpdates) {\n      /**\n       * A manual `timeupdate` event.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({\n        type: 'timeupdate',\n        target: this,\n        manuallyTriggered: true\n      });\n    }\n  }\n  /**\n   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n   * {@link TextTrackList} events.\n   *\n   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n   *\n   * @fires Tech#audiotrackchange\n   * @fires Tech#videotrackchange\n   * @fires Tech#texttrackchange\n   */\n  ;\n\n  _proto.initTrackListeners = function initTrackListeners() {\n    var _this4 = this;\n    /**\n      * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n      *\n      * @event Tech#audiotrackchange\n      * @type {EventTarget~Event}\n      */\n\n    /**\n      * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n      *\n      * @event Tech#videotrackchange\n      * @type {EventTarget~Event}\n      */\n\n    /**\n      * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n      *\n      * @event Tech#texttrackchange\n      * @type {EventTarget~Event}\n      */\n\n\n    NORMAL.names.forEach(function (name) {\n      var props = NORMAL[name];\n\n      var trackListChanges = function trackListChanges() {\n        _this4.trigger(name + \"trackchange\");\n      };\n\n      var tracks = _this4[props.getterName]();\n\n      tracks.addEventListener('removetrack', trackListChanges);\n      tracks.addEventListener('addtrack', trackListChanges);\n\n      _this4.on('dispose', function () {\n        tracks.removeEventListener('removetrack', trackListChanges);\n        tracks.removeEventListener('addtrack', trackListChanges);\n      });\n    });\n  }\n  /**\n   * Emulate TextTracks using vtt.js if necessary\n   *\n   * @fires Tech#vttjsloaded\n   * @fires Tech#vttjserror\n   */\n  ;\n\n  _proto.addWebVttScript_ = function addWebVttScript_() {\n    var _this5 = this;\n\n    if (window$1.WebVTT) {\n      return;\n    } // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n    // signals that the Tech is ready at which point Tech.el_ is part of the DOM\n    // before inserting the WebVTT script\n\n\n    if (document.body.contains(this.el())) {\n      // load via require if available and vtt.js script location was not passed in\n      // as an option. novtt builds will turn the above require call into an empty object\n      // which will cause this if check to always fail.\n      if (!this.options_['vtt.js'] && isPlain(vtt) && Object.keys(vtt).length > 0) {\n        this.trigger('vttjsloaded');\n        return;\n      } // load vtt.js via the script location option or the cdn of no location was\n      // passed in\n\n\n      var script = document.createElement('script');\n      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';\n\n      script.onload = function () {\n        /**\n         * Fired when vtt.js is loaded.\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this5.trigger('vttjsloaded');\n      };\n\n      script.onerror = function () {\n        /**\n         * Fired when vtt.js was not loaded due to an error\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this5.trigger('vttjserror');\n      };\n\n      this.on('dispose', function () {\n        script.onload = null;\n        script.onerror = null;\n      }); // but have not loaded yet and we set it to true before the inject so that\n      // we don't overwrite the injected window.WebVTT if it loads right away\n\n      window$1.WebVTT = true;\n      this.el().parentNode.appendChild(script);\n    } else {\n      this.ready(this.addWebVttScript_);\n    }\n  }\n  /**\n   * Emulate texttracks\n   *\n   */\n  ;\n\n  _proto.emulateTextTracks = function emulateTextTracks() {\n    var _this6 = this;\n\n    var tracks = this.textTracks();\n    var remoteTracks = this.remoteTextTracks();\n\n    var handleAddTrack = function handleAddTrack(e) {\n      return tracks.addTrack(e.track);\n    };\n\n    var handleRemoveTrack = function handleRemoveTrack(e) {\n      return tracks.removeTrack(e.track);\n    };\n\n    remoteTracks.on('addtrack', handleAddTrack);\n    remoteTracks.on('removetrack', handleRemoveTrack);\n    this.addWebVttScript_();\n\n    var updateDisplay = function updateDisplay() {\n      return _this6.trigger('texttrackchange');\n    };\n\n    var textTracksChanges = function textTracksChanges() {\n      updateDisplay();\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n        track.removeEventListener('cuechange', updateDisplay);\n\n        if (track.mode === 'showing') {\n          track.addEventListener('cuechange', updateDisplay);\n        }\n      }\n    };\n\n    textTracksChanges();\n    tracks.addEventListener('change', textTracksChanges);\n    tracks.addEventListener('addtrack', textTracksChanges);\n    tracks.addEventListener('removetrack', textTracksChanges);\n    this.on('dispose', function () {\n      remoteTracks.off('addtrack', handleAddTrack);\n      remoteTracks.off('removetrack', handleRemoveTrack);\n      tracks.removeEventListener('change', textTracksChanges);\n      tracks.removeEventListener('addtrack', textTracksChanges);\n      tracks.removeEventListener('removetrack', textTracksChanges);\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n        track.removeEventListener('cuechange', updateDisplay);\n      }\n    });\n  }\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n  ;\n\n  _proto.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!kind) {\n      throw new Error('TextTrack kind is required but was not provided');\n    }\n\n    return createTrackHelper(this, kind, label, language);\n  }\n  /**\n   * Create an emulated TextTrack for use by addRemoteTextTrack\n   *\n   * This is intended to be overridden by classes that inherit from\n   * Tech in order to create native or custom TextTracks.\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n  ;\n\n  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    var track = mergeOptions(options, {\n      tech: this\n    });\n    return new REMOTE.remoteTextEl.TrackClass(track);\n  }\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n   *\n   * @param {Object} options\n   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n   *\n   * @param {boolean} [manualCleanup=true]\n   *        - When false: the TextTrack will be automatically removed from the video\n   *          element whenever the source changes\n   *        - When True: The TextTrack will have to be cleaned up manually\n   *\n   * @return {HTMLTrackElement}\n   *         An Html Track Element.\n   *\n   * @deprecated The default functionality for this function will be equivalent\n   *             to \"manualCleanup=false\" in the future. The manualCleanup parameter will\n   *             also be removed.\n   */\n  ;\n\n  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    var _this7 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var htmlTrackElement = this.createRemoteTextTrack(options);\n\n    if (manualCleanup !== true && manualCleanup !== false) {\n      // deprecation warning\n      log.warn('Calling addRemoteTextTrack without explicitly setting the \"manualCleanup\" parameter to `true` is deprecated and default to `false` in future version of video.js');\n      manualCleanup = true;\n    } // store HTMLTrackElement and TextTrack to remote list\n\n\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\n    this.remoteTextTracks().addTrack(htmlTrackElement.track);\n\n    if (manualCleanup !== true) {\n      // create the TextTrackList if it doesn't exist\n      this.ready(function () {\n        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);\n      });\n    }\n\n    return htmlTrackElement;\n  }\n  /**\n   * Remove a remote text track from the remote `TextTrackList`.\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` to remove from the `TextTrackList`\n   */\n  ;\n\n  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track); // remove HTMLTrackElement and TextTrack from remote list\n\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\n    this.remoteTextTracks().removeTrack(track);\n    this.autoRemoteTextTracks_.removeTrack(track);\n  }\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return {};\n  }\n  /**\n   * Attempt to create a floating video window always on top of other windows\n   * so that users may continue consuming media while they interact with other\n   * content sites, or applications on their device.\n   *\n   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n   *\n   * @return {Promise|undefined}\n   *         A promise with a Picture-in-Picture window if the browser supports\n   *         Promises (or one was passed in as an option). It returns undefined\n   *         otherwise.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.requestPictureInPicture = function requestPictureInPicture() {\n    var PromiseClass = this.options_.Promise || window$1.Promise;\n\n    if (PromiseClass) {\n      return PromiseClass.reject();\n    }\n  }\n  /**\n   * A method to check for the value of the 'disablePictureInPicture' <video> property.\n   * Defaults to true, as it should be considered disabled if the tech does not support pip\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.disablePictureInPicture = function disablePictureInPicture() {\n    return true;\n  }\n  /**\n   * A method to set or unset the 'disablePictureInPicture' <video> property.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.setDisablePictureInPicture = function setDisablePictureInPicture() {}\n  /**\n   * A method to set a poster from a `Tech`.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.setPoster = function setPoster() {}\n  /**\n   * A method to check for the presence of the 'playsinline' <video> attribute.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.playsinline = function playsinline() {}\n  /**\n   * A method to set or unset the 'playsinline' <video> attribute.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.setPlaysinline = function setPlaysinline() {}\n  /**\n   * Attempt to force override of native audio tracks.\n   *\n   * @param {boolean} override - If set to true native audio will be overridden,\n   * otherwise native audio will potentially be used.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks() {}\n  /**\n   * Attempt to force override of native video tracks.\n   *\n   * @param {boolean} override - If set to true native video will be overridden,\n   * otherwise native video will potentially be used.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks() {}\n  /*\n   * Check if the tech can support the given mime-type.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param  {string} type\n   *         The mimetype to check for support\n   *\n   * @return {string}\n   *         'probably', 'maybe', or empty string\n   *\n   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.canPlayType = function canPlayType() {\n    return '';\n  }\n  /**\n   * Check if the type is supported by this tech.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param {string} type\n   *        The media type to check\n   * @return {string} Returns the native video element's response\n   */\n  ;\n\n  Tech.canPlayType = function canPlayType() {\n    return '';\n  }\n  /**\n   * Check if the tech can support the given source\n   *\n   * @param {Object} srcObj\n   *        The source object\n   * @param {Object} options\n   *        The options passed to the tech\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */\n  ;\n\n  Tech.canPlaySource = function canPlaySource(srcObj, options) {\n    return Tech.canPlayType(srcObj.type);\n  }\n  /*\n   * Return whether the argument is a Tech or not.\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n   *\n   * @param {Object} component\n   *        The item to check\n   *\n   * @return {boolean}\n   *         Whether it is a tech or not\n   *         - True if it is a tech\n   *         - False if it is not\n   */\n  ;\n\n  Tech.isTech = function isTech(component) {\n    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\n  }\n  /**\n   * Registers a `Tech` into a shared list for videojs.\n   *\n   * @param {string} name\n   *        Name of the `Tech` to register.\n   *\n   * @param {Object} tech\n   *        The `Tech` class to register.\n   */\n  ;\n\n  Tech.registerTech = function registerTech(name, tech) {\n    if (!Tech.techs_) {\n      Tech.techs_ = {};\n    }\n\n    if (!Tech.isTech(tech)) {\n      throw new Error(\"Tech \" + name + \" must be a Tech\");\n    }\n\n    if (!Tech.canPlayType) {\n      throw new Error('Techs must have a static canPlayType method on them');\n    }\n\n    if (!Tech.canPlaySource) {\n      throw new Error('Techs must have a static canPlaySource method on them');\n    }\n\n    name = toTitleCase(name);\n    Tech.techs_[name] = tech;\n    Tech.techs_[toLowerCase(name)] = tech;\n\n    if (name !== 'Tech') {\n      // camel case the techName for use in techOrder\n      Tech.defaultTechOrder_.push(name);\n    }\n\n    return tech;\n  }\n  /**\n   * Get a `Tech` from the shared list by name.\n   *\n   * @param {string} name\n   *        `camelCase` or `TitleCase` name of the Tech to get\n   *\n   * @return {Tech|undefined}\n   *         The `Tech` or undefined if there was no tech with the name requested.\n   */\n  ;\n\n  Tech.getTech = function getTech(name) {\n    if (!name) {\n      return;\n    }\n\n    if (Tech.techs_ && Tech.techs_[name]) {\n      return Tech.techs_[name];\n    }\n\n    name = toTitleCase(name);\n\n    if (window$1 && window$1.videojs && window$1.videojs[name]) {\n      log.warn(\"The \" + name + \" tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)\");\n      return window$1.videojs[name];\n    }\n  };\n\n  return Tech;\n}(Component);\n/**\n * Get the {@link VideoTrackList}\n *\n * @returns {VideoTrackList}\n * @method Tech.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n *\n * @returns {AudioTrackList}\n * @method Tech.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.textTracks\n */\n\n/**\n * Get the remote element {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote element {@link HtmlTrackElementList}\n *\n * @returns {HtmlTrackElementList}\n * @method Tech.prototype.remoteTextTrackEls\n */\n\n\nALL.names.forEach(function (name) {\n  var props = ALL[name];\n\n  Tech.prototype[props.getterName] = function () {\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n/**\n * List of associated text tracks\n *\n * @type {TextTrackList}\n * @private\n * @property Tech#textTracks_\n */\n\n/**\n * List of associated audio tracks.\n *\n * @type {AudioTrackList}\n * @private\n * @property Tech#audioTracks_\n */\n\n/**\n * List of associated video tracks.\n *\n * @type {VideoTrackList}\n * @private\n * @property Tech#videoTracks_\n */\n\n/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default\n */\n\nTech.prototype.featuresVolumeControl = true;\n/**\n * Boolean indicating whether the `Tech` supports muting volume.\n *\n * @type {bolean}\n * @default\n */\n\nTech.prototype.featuresMuteControl = true;\n/**\n * Boolean indicating whether the `Tech` supports fullscreen resize control.\n * Resizing plugins using request fullscreen reloads the plugin\n *\n * @type {boolean}\n * @default\n */\n\nTech.prototype.featuresFullscreenResize = false;\n/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the video\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default\n */\n\nTech.prototype.featuresPlaybackRate = false;\n/**\n * Boolean indicating whether the `Tech` supports the `progress` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualProgressOn} should be called.\n *\n * @type {boolean}\n * @default\n */\n\nTech.prototype.featuresProgressEvents = false;\n/**\n * Boolean indicating whether the `Tech` supports the `sourceset` event.\n *\n * A tech should set this to `true` and then use {@link Tech#triggerSourceset}\n * to trigger a {@link Tech#event:sourceset} at the earliest time after getting\n * a new source.\n *\n * @type {boolean}\n * @default\n */\n\nTech.prototype.featuresSourceset = false;\n/**\n * Boolean indicating whether the `Tech` supports the `timeupdate` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualTimeUpdates} should be called.\n *\n * @type {boolean}\n * @default\n */\n\nTech.prototype.featuresTimeupdateEvents = false;\n/**\n * Boolean indicating whether the `Tech` supports the native `TextTrack`s.\n * This will help us integrate with native `TextTrack`s if the browser supports them.\n *\n * @type {boolean}\n * @default\n */\n\nTech.prototype.featuresNativeTextTracks = false;\n/**\n * A functional mixin for techs that want to use the Source Handler pattern.\n * Source handlers are scripts for handling specific formats.\n * The source handler pattern is used for adaptive formats (HLS, DASH) that\n * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n * Example: `Tech.withSourceHandlers.call(MyTech);`\n *\n * @param {Tech} _Tech\n *        The tech to add source handler functions to.\n *\n * @mixes Tech~SourceHandlerAdditions\n */\n\nTech.withSourceHandlers = function (_Tech) {\n  /**\n   * Register a source handler\n   *\n   * @param {Function} handler\n   *        The source handler class\n   *\n   * @param {number} [index]\n   *        Register it at the following index\n   */\n  _Tech.registerSourceHandler = function (handler, index) {\n    var handlers = _Tech.sourceHandlers;\n\n    if (!handlers) {\n      handlers = _Tech.sourceHandlers = [];\n    }\n\n    if (index === undefined) {\n      // add to the end of the list\n      index = handlers.length;\n    }\n\n    handlers.splice(index, 0, handler);\n  };\n  /**\n   * Check if the tech can support the given type. Also checks the\n   * Techs sourceHandlers.\n   *\n   * @param {string} type\n   *         The mimetype to check.\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n\n\n  _Tech.canPlayType = function (type) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canPlayType(type);\n\n      if (can) {\n        return can;\n      }\n    }\n\n    return '';\n  };\n  /**\n   * Returns the first source handler that supports the source.\n   *\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {SourceHandler|null}\n   *          The first source handler that supports the source or null if\n   *          no SourceHandler supports the source\n   */\n\n\n  _Tech.selectSourceHandler = function (source, options) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canHandleSource(source, options);\n\n      if (can) {\n        return handlers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Check if the tech can support the given source.\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n\n\n  _Tech.canPlaySource = function (srcObj, options) {\n    var sh = _Tech.selectSourceHandler(srcObj, options);\n\n    if (sh) {\n      return sh.canHandleSource(srcObj, options);\n    }\n\n    return '';\n  };\n  /**\n   * When using a source handler, prefer its implementation of\n   * any function normally provided by the tech.\n   */\n\n\n  var deferrable = ['seekable', 'seeking', 'duration'];\n  /**\n   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n   * function if it exists, with a fallback to the Techs seekable function.\n   *\n   * @method _Tech.seekable\n   */\n\n  /**\n   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n   * function if it exists, otherwise it will fallback to the techs duration function.\n   *\n   * @method _Tech.duration\n   */\n\n  deferrable.forEach(function (fnName) {\n    var originalFn = this[fnName];\n\n    if (typeof originalFn !== 'function') {\n      return;\n    }\n\n    this[fnName] = function () {\n      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\n        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\n      }\n\n      return originalFn.apply(this, arguments);\n    };\n  }, _Tech.prototype);\n  /**\n   * Create a function for setting the source using a source object\n   * and source handlers.\n   * Should never be called unless a source handler was found.\n   *\n   * @param {Tech~SourceObject} source\n   *        A source object with src and type keys\n   */\n\n  _Tech.prototype.setSource = function (source) {\n    var sh = _Tech.selectSourceHandler(source, this.options_);\n\n    if (!sh) {\n      // Fall back to a native source hander when unsupported sources are\n      // deliberately set\n      if (_Tech.nativeSourceHandler) {\n        sh = _Tech.nativeSourceHandler;\n      } else {\n        log.error('No source handler found for the current source.');\n      }\n    } // Dispose any existing source handler\n\n\n    this.disposeSourceHandler();\n    this.off('dispose', this.disposeSourceHandler);\n\n    if (sh !== _Tech.nativeSourceHandler) {\n      this.currentSource_ = source;\n    }\n\n    this.sourceHandler_ = sh.handleSource(source, this, this.options_);\n    this.one('dispose', this.disposeSourceHandler);\n  };\n  /**\n   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n   *\n   * @listens Tech#dispose\n   */\n\n\n  _Tech.prototype.disposeSourceHandler = function () {\n    // if we have a source and get another one\n    // then we are loading something new\n    // than clear all of our current tracks\n    if (this.currentSource_) {\n      this.clearTracks(['audio', 'video']);\n      this.currentSource_ = null;\n    } // always clean up auto-text tracks\n\n\n    this.cleanupAutoTextTracks();\n\n    if (this.sourceHandler_) {\n      if (this.sourceHandler_.dispose) {\n        this.sourceHandler_.dispose();\n      }\n\n      this.sourceHandler_ = null;\n    }\n  };\n}; // The base Tech class needs to be registered as a Component. It is the only\n// Tech that can be registered as a Component.\n\n\nComponent.registerComponent('Tech', Tech);\nTech.registerTech('Tech', Tech);\n/**\n * A list of techs that should be added to techOrder on Players\n *\n * @private\n */\n\nTech.defaultTechOrder_ = [];\n/**\n * @file middleware.js\n * @module middleware\n */\n\nvar middlewares = {};\nvar middlewareInstances = {};\nvar TERMINATOR = {};\n/**\n * A middleware object is a plain JavaScript object that has methods that\n * match the {@link Tech} methods found in the lists of allowed\n * {@link module:middleware.allowedGetters|getters},\n * {@link module:middleware.allowedSetters|setters}, and\n * {@link module:middleware.allowedMediators|mediators}.\n *\n * @typedef {Object} MiddlewareObject\n */\n\n/**\n * A middleware factory function that should return a\n * {@link module:middleware~MiddlewareObject|MiddlewareObject}.\n *\n * This factory will be called for each player when needed, with the player\n * passed in as an argument.\n *\n * @callback MiddlewareFactory\n * @param {Player} player\n *        A Video.js player.\n */\n\n/**\n * Define a middleware that the player should use by way of a factory function\n * that returns a middleware object.\n *\n * @param  {string} type\n *         The MIME type to match or `\"*\"` for all MIME types.\n *\n * @param  {MiddlewareFactory} middleware\n *         A middleware factory function that will be executed for\n *         matching types.\n */\n\nfunction use(type, middleware) {\n  middlewares[type] = middlewares[type] || [];\n  middlewares[type].push(middleware);\n}\n/**\n * Asynchronously sets a source using middleware by recursing through any\n * matching middlewares and calling `setSource` on each, passing along the\n * previous returned value each time.\n *\n * @param  {Player} player\n *         A {@link Player} instance.\n *\n * @param  {Tech~SourceObject} src\n *         A source object.\n *\n * @param  {Function}\n *         The next middleware to run.\n */\n\n\nfunction setSource(player, src, next) {\n  player.setTimeout(function () {\n    return setSourceHelper(src, middlewares[src.type], next, player);\n  }, 1);\n}\n/**\n * When the tech is set, passes the tech to each middleware's `setTech` method.\n *\n * @param {Object[]} middleware\n *        An array of middleware instances.\n *\n * @param {Tech} tech\n *        A Video.js tech.\n */\n\n\nfunction setTech(middleware, tech) {\n  middleware.forEach(function (mw) {\n    return mw.setTech && mw.setTech(tech);\n  });\n}\n/**\n * Calls a getter on the tech first, through each middleware\n * from right to left to the player.\n *\n * @param  {Object[]} middleware\n *         An array of middleware instances.\n *\n * @param  {Tech} tech\n *         The current tech.\n *\n * @param  {string} method\n *         A method name.\n *\n * @return {Mixed}\n *         The final value from the tech after middleware has intercepted it.\n */\n\n\nfunction get(middleware, tech, method) {\n  return middleware.reduceRight(middlewareIterator(method), tech[method]());\n}\n/**\n * Takes the argument given to the player and calls the setter method on each\n * middleware from left to right to the tech.\n *\n * @param  {Object[]} middleware\n *         An array of middleware instances.\n *\n * @param  {Tech} tech\n *         The current tech.\n *\n * @param  {string} method\n *         A method name.\n *\n * @param  {Mixed} arg\n *         The value to set on the tech.\n *\n * @return {Mixed}\n *         The return value of the `method` of the `tech`.\n */\n\n\nfunction set(middleware, tech, method, arg) {\n  return tech[method](middleware.reduce(middlewareIterator(method), arg));\n}\n/**\n * Takes the argument given to the player and calls the `call` version of the\n * method on each middleware from left to right.\n *\n * Then, call the passed in method on the tech and return the result unchanged\n * back to the player, through middleware, this time from right to left.\n *\n * @param  {Object[]} middleware\n *         An array of middleware instances.\n *\n * @param  {Tech} tech\n *         The current tech.\n *\n * @param  {string} method\n *         A method name.\n *\n * @param  {Mixed} arg\n *         The value to set on the tech.\n *\n * @return {Mixed}\n *         The return value of the `method` of the `tech`, regardless of the\n *         return values of middlewares.\n */\n\n\nfunction mediate(middleware, tech, method, arg) {\n  if (arg === void 0) {\n    arg = null;\n  }\n\n  var callMethod = 'call' + toTitleCase(method);\n  var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);\n  var terminated = middlewareValue === TERMINATOR; // deprecated. The `null` return value should instead return TERMINATOR to\n  // prevent confusion if a techs method actually returns null.\n\n  var returnValue = terminated ? null : tech[method](middlewareValue);\n  executeRight(middleware, method, returnValue, terminated);\n  return returnValue;\n}\n/**\n * Enumeration of allowed getters where the keys are method names.\n *\n * @type {Object}\n */\n\n\nvar allowedGetters = {\n  buffered: 1,\n  currentTime: 1,\n  duration: 1,\n  muted: 1,\n  played: 1,\n  paused: 1,\n  seekable: 1,\n  volume: 1\n};\n/**\n * Enumeration of allowed setters where the keys are method names.\n *\n * @type {Object}\n */\n\nvar allowedSetters = {\n  setCurrentTime: 1,\n  setMuted: 1,\n  setVolume: 1\n};\n/**\n * Enumeration of allowed mediators where the keys are method names.\n *\n * @type {Object}\n */\n\nvar allowedMediators = {\n  play: 1,\n  pause: 1\n};\n\nfunction middlewareIterator(method) {\n  return function (value, mw) {\n    // if the previous middleware terminated, pass along the termination\n    if (value === TERMINATOR) {\n      return TERMINATOR;\n    }\n\n    if (mw[method]) {\n      return mw[method](value);\n    }\n\n    return value;\n  };\n}\n\nfunction executeRight(mws, method, value, terminated) {\n  for (var i = mws.length - 1; i >= 0; i--) {\n    var mw = mws[i];\n\n    if (mw[method]) {\n      mw[method](terminated, value);\n    }\n  }\n}\n/**\n * Clear the middleware cache for a player.\n *\n * @param  {Player} player\n *         A {@link Player} instance.\n */\n\n\nfunction clearCacheForPlayer(player) {\n  middlewareInstances[player.id()] = null;\n}\n/**\n * {\n *  [playerId]: [[mwFactory, mwInstance], ...]\n * }\n *\n * @private\n */\n\n\nfunction getOrCreateFactory(player, mwFactory) {\n  var mws = middlewareInstances[player.id()];\n  var mw = null;\n\n  if (mws === undefined || mws === null) {\n    mw = mwFactory(player);\n    middlewareInstances[player.id()] = [[mwFactory, mw]];\n    return mw;\n  }\n\n  for (var i = 0; i < mws.length; i++) {\n    var _mws$i = mws[i],\n        mwf = _mws$i[0],\n        mwi = _mws$i[1];\n\n    if (mwf !== mwFactory) {\n      continue;\n    }\n\n    mw = mwi;\n  }\n\n  if (mw === null) {\n    mw = mwFactory(player);\n    mws.push([mwFactory, mw]);\n  }\n\n  return mw;\n}\n\nfunction setSourceHelper(src, middleware, next, player, acc, lastRun) {\n  if (src === void 0) {\n    src = {};\n  }\n\n  if (middleware === void 0) {\n    middleware = [];\n  }\n\n  if (acc === void 0) {\n    acc = [];\n  }\n\n  if (lastRun === void 0) {\n    lastRun = false;\n  }\n\n  var _middleware = middleware,\n      mwFactory = _middleware[0],\n      mwrest = _middleware.slice(1); // if mwFactory is a string, then we're at a fork in the road\n\n\n  if (typeof mwFactory === 'string') {\n    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun); // if we have an mwFactory, call it with the player to get the mw,\n    // then call the mw's setSource method\n  } else if (mwFactory) {\n    var mw = getOrCreateFactory(player, mwFactory); // if setSource isn't present, implicitly select this middleware\n\n    if (!mw.setSource) {\n      acc.push(mw);\n      return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n    }\n\n    mw.setSource(assign({}, src), function (err, _src) {\n      // something happened, try the next middleware on the current level\n      // make sure to use the old src\n      if (err) {\n        return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n      } // we've succeeded, now we need to go deeper\n\n\n      acc.push(mw); // if it's the same type, continue down the current chain\n      // otherwise, we want to go down the new chain\n\n      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\n    });\n  } else if (mwrest.length) {\n    setSourceHelper(src, mwrest, next, player, acc, lastRun);\n  } else if (lastRun) {\n    next(src, acc);\n  } else {\n    setSourceHelper(src, middlewares['*'], next, player, acc, true);\n  }\n}\n/**\n * Mimetypes\n *\n * @see http://hul.harvard.edu/ois/////systems/wax/wax-public-help/mimetypes.htm\n * @typedef Mimetypes~Kind\n * @enum\n */\n\n\nvar MimetypesKind = {\n  opus: 'video/ogg',\n  ogv: 'video/ogg',\n  mp4: 'video/mp4',\n  mov: 'video/mp4',\n  m4v: 'video/mp4',\n  mkv: 'video/x-matroska',\n  m4a: 'audio/mp4',\n  mp3: 'audio/mpeg',\n  aac: 'audio/aac',\n  caf: 'audio/x-caf',\n  flac: 'audio/flac',\n  oga: 'audio/ogg',\n  wav: 'audio/wav',\n  m3u8: 'application/x-mpegURL',\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  gif: 'image/gif',\n  png: 'image/png',\n  svg: 'image/svg+xml',\n  webp: 'image/webp'\n};\n/**\n * Get the mimetype of a given src url if possible\n *\n * @param {string} src\n *        The url to the src\n *\n * @return {string}\n *         return the mimetype if it was known or empty string otherwise\n */\n\nvar getMimetype = function getMimetype(src) {\n  if (src === void 0) {\n    src = '';\n  }\n\n  var ext = getFileExtension(src);\n  var mimetype = MimetypesKind[ext.toLowerCase()];\n  return mimetype || '';\n};\n/**\n * Find the mime type of a given source string if possible. Uses the player\n * source cache.\n *\n * @param {Player} player\n *        The player object\n *\n * @param {string} src\n *        The source string\n *\n * @return {string}\n *         The type that was found\n */\n\n\nvar findMimetype = function findMimetype(player, src) {\n  if (!src) {\n    return '';\n  } // 1. check for the type in the `source` cache\n\n\n  if (player.cache_.source.src === src && player.cache_.source.type) {\n    return player.cache_.source.type;\n  } // 2. see if we have this source in our `currentSources` cache\n\n\n  var matchingSources = player.cache_.sources.filter(function (s) {\n    return s.src === src;\n  });\n\n  if (matchingSources.length) {\n    return matchingSources[0].type;\n  } // 3. look for the src url in source elements and use the type there\n\n\n  var sources = player.$$('source');\n\n  for (var i = 0; i < sources.length; i++) {\n    var s = sources[i];\n\n    if (s.type && s.src && s.src === src) {\n      return s.type;\n    }\n  } // 4. finally fallback to our list of mime types based on src url extension\n\n\n  return getMimetype(src);\n};\n/**\n * @module filter-source\n */\n\n/**\n * Filter out single bad source objects or multiple source objects in an\n * array. Also flattens nested source object arrays into a 1 dimensional\n * array of source objects.\n *\n * @param {Tech~SourceObject|Tech~SourceObject[]} src\n *        The src object to filter\n *\n * @return {Tech~SourceObject[]}\n *         An array of sourceobjects containing only valid sources\n *\n * @private\n */\n\n\nvar filterSource = function filterSource(src) {\n  // traverse array\n  if (Array.isArray(src)) {\n    var newsrc = [];\n    src.forEach(function (srcobj) {\n      srcobj = filterSource(srcobj);\n\n      if (Array.isArray(srcobj)) {\n        newsrc = newsrc.concat(srcobj);\n      } else if (isObject(srcobj)) {\n        newsrc.push(srcobj);\n      }\n    });\n    src = newsrc;\n  } else if (typeof src === 'string' && src.trim()) {\n    // convert string into object\n    src = [fixSource({\n      src: src\n    })];\n  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\n    // src is already valid\n    src = [fixSource(src)];\n  } else {\n    // invalid source, turn it into an empty array\n    src = [];\n  }\n\n  return src;\n};\n/**\n * Checks src mimetype, adding it when possible\n *\n * @param {Tech~SourceObject} src\n *        The src object to check\n * @return {Tech~SourceObject}\n *        src Object with known type\n */\n\n\nfunction fixSource(src) {\n  if (!src.type) {\n    var mimetype = getMimetype(src.src);\n\n    if (mimetype) {\n      src.type = mimetype;\n    }\n  }\n\n  return src;\n}\n/**\n * The `MediaLoader` is the `Component` that decides which playback technology to load\n * when a player is initialized.\n *\n * @extends Component\n */\n\n\nvar MediaLoader = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(MediaLoader, _Component);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function that is run when this component is ready.\n   */\n\n\n  function MediaLoader(player, options, ready) {\n    var _this; // MediaLoader has no element\n\n\n    var options_ = mergeOptions({\n      createEl: false\n    }, options);\n    _this = _Component.call(this, player, options_, ready) || this; // If there are no sources when the player is initialized,\n    // load the first supported playback technology.\n\n    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\n      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\n        var techName = toTitleCase(j[i]);\n        var tech = Tech.getTech(techName); // Support old behavior of techs being registered as components.\n        // Remove once that deprecated behavior is removed.\n\n        if (!techName) {\n          tech = Component.getComponent(techName);\n        } // Check if the browser supports this technology\n\n\n        if (tech && tech.isSupported()) {\n          player.loadTech_(techName);\n          break;\n        }\n      }\n    } else {\n      // Loop through playback technologies (HTML5, Flash) and check for support.\n      // Then load the best source.\n      // A few assumptions here:\n      //   All playback technologies respect preload false.\n      player.src(options.playerOptions.sources);\n    }\n\n    return _this;\n  }\n\n  return MediaLoader;\n}(Component);\n\nComponent.registerComponent('MediaLoader', MediaLoader);\n/**\n * Component which is clickable or keyboard actionable, but is not a\n * native HTML button.\n *\n * @extends Component\n */\n\nvar ClickableComponent = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ClickableComponent, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   *\n   * @param  {function} [options.clickHandler]\n   *         The function to call when the button is clicked / activated\n   */\n\n\n  function ClickableComponent(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n\n    _this.emitTapEvents();\n\n    _this.enable();\n\n    return _this;\n  }\n  /**\n   * Create the `ClickableComponent`s DOM element.\n   *\n   * @param {string} [tag=div]\n   *        The element's node type.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  var _proto = ClickableComponent.prototype;\n\n  _proto.createEl = function createEl(tag, props, attributes) {\n    if (tag === void 0) {\n      tag = 'div';\n    }\n\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass(),\n      tabIndex: 0\n    }, props);\n\n    if (tag === 'button') {\n      log.error(\"Creating a ClickableComponent with an HTML element of \" + tag + \" is not supported; use a Button instead.\");\n    } // Add ARIA attributes for clickable element which is not a native HTML button\n\n\n    attributes = assign({\n      role: 'button'\n    }, attributes);\n    this.tabIndex_ = props.tabIndex;\n\n    var el = _Component.prototype.createEl.call(this, tag, props, attributes);\n\n    this.createControlTextEl(el);\n    return el;\n  };\n\n  _proto.dispose = function dispose() {\n    // remove controlTextEl_ on dispose\n    this.controlTextEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Create a control text element on this `ClickableComponent`\n   *\n   * @param {Element} [el]\n   *        Parent element for the control text.\n   *\n   * @return {Element}\n   *         The control text element that gets created.\n   */\n  ;\n\n  _proto.createControlTextEl = function createControlTextEl(el) {\n    this.controlTextEl_ = createEl('span', {\n      className: 'vjs-control-text'\n    }, {\n      // let the screen reader user know that the text of the element may change\n      'aria-live': 'polite'\n    });\n\n    if (el) {\n      el.appendChild(this.controlTextEl_);\n    }\n\n    this.controlText(this.controlText_, el);\n    return this.controlTextEl_;\n  }\n  /**\n   * Get or set the localize text to use for the controls on the `ClickableComponent`.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n  ;\n\n  _proto.controlText = function controlText(text, el) {\n    if (el === void 0) {\n      el = this.el();\n    }\n\n    if (text === undefined) {\n      return this.controlText_ || 'Need Text';\n    }\n\n    var localizedText = this.localize(text);\n    this.controlText_ = text;\n    textContent(this.controlTextEl_, localizedText);\n\n    if (!this.nonIconControl) {\n      // Set title attribute if only an icon is shown\n      el.setAttribute('title', localizedText);\n    }\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  ;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-control vjs-button \" + _Component.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Enable this `ClickableComponent`\n   */\n  ;\n\n  _proto.enable = function enable() {\n    if (!this.enabled_) {\n      this.enabled_ = true;\n      this.removeClass('vjs-disabled');\n      this.el_.setAttribute('aria-disabled', 'false');\n\n      if (typeof this.tabIndex_ !== 'undefined') {\n        this.el_.setAttribute('tabIndex', this.tabIndex_);\n      }\n\n      this.on(['tap', 'click'], this.handleClick);\n      this.on('keydown', this.handleKeyDown);\n    }\n  }\n  /**\n   * Disable this `ClickableComponent`\n   */\n  ;\n\n  _proto.disable = function disable() {\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n    this.el_.setAttribute('aria-disabled', 'true');\n\n    if (typeof this.tabIndex_ !== 'undefined') {\n      this.el_.removeAttribute('tabIndex');\n    }\n\n    this.off('mouseover', this.handleMouseOver);\n    this.off('mouseout', this.handleMouseOut);\n    this.off(['tap', 'click'], this.handleClick);\n    this.off('keydown', this.handleKeyDown);\n  }\n  /**\n   * Event handler that is called when a `ClickableComponent` receives a\n   * `click` or `tap` event.\n   *\n   * @param {EventTarget~Event} event\n   *        The `tap` or `click` event that caused this function to be called.\n   *\n   * @listens tap\n   * @listens click\n   * @abstract\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    if (this.options_.clickHandler) {\n      this.options_.clickHandler.call(this, arguments);\n    }\n  }\n  /**\n   * Event handler that is called when a `ClickableComponent` receives a\n   * `keydown` event.\n   *\n   * By default, if the key is Space or Enter, it will trigger a `click` event.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // Support Space or Enter key operation to fire a click event. Also,\n    // prevent the event from propagating through the DOM and triggering\n    // Player hotkeys.\n    if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.trigger('click');\n    } else {\n      // Pass keypress handling up for unsupported keys\n      _Component.prototype.handleKeyDown.call(this, event);\n    }\n  };\n\n  return ClickableComponent;\n}(Component);\n\nComponent.registerComponent('ClickableComponent', ClickableComponent);\n/**\n * A `ClickableComponent` that handles showing the poster image for the player.\n *\n * @extends ClickableComponent\n */\n\nvar PosterImage = /*#__PURE__*/function (_ClickableComponent) {\n  _inheritsLoose(PosterImage, _ClickableComponent);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function PosterImage(player, options) {\n    var _this;\n\n    _this = _ClickableComponent.call(this, player, options) || this;\n\n    _this.update();\n\n    player.on('posterchange', bind(_assertThisInitialized(_this), _this.update));\n    return _this;\n  }\n  /**\n   * Clean up and dispose of the `PosterImage`.\n   */\n\n\n  var _proto = PosterImage.prototype;\n\n  _proto.dispose = function dispose() {\n    this.player().off('posterchange', this.update);\n\n    _ClickableComponent.prototype.dispose.call(this);\n  }\n  /**\n   * Create the `PosterImage`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  ;\n\n  _proto.createEl = function createEl$1() {\n    var el = createEl('div', {\n      className: 'vjs-poster',\n      // Don't want poster to be tabbable.\n      tabIndex: -1\n    });\n    return el;\n  }\n  /**\n   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n   *\n   * @listens Player#posterchange\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `Player#posterchange` event that triggered this function.\n   */\n  ;\n\n  _proto.update = function update(event) {\n    var url = this.player().poster();\n    this.setSrc(url); // If there's no poster source we should display:none on this component\n    // so it's not still clickable or right-clickable\n\n    if (url) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n  /**\n   * Set the source of the `PosterImage` depending on the display method.\n   *\n   * @param {string} url\n   *        The URL to the source for the `PosterImage`.\n   */\n  ;\n\n  _proto.setSrc = function setSrc(url) {\n    var backgroundImage = ''; // Any falsy value should stay as an empty string, otherwise\n    // this will throw an extra error\n\n    if (url) {\n      backgroundImage = \"url(\\\"\" + url + \"\\\")\";\n    }\n\n    this.el_.style.backgroundImage = backgroundImage;\n  }\n  /**\n   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n   * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n   *\n   * @listens tap\n   * @listens click\n   * @listens keydown\n   *\n   * @param {EventTarget~Event} event\n   +        The `click`, `tap` or `keydown` event that caused this function to be called.\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    // We don't want a click to trigger playback when controls are disabled\n    if (!this.player_.controls()) {\n      return;\n    }\n\n    var sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;\n\n    if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where\n    // calling .focus() on the video element causes the video to go black,\n    // so we avoid it in that specific case\n    !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {\n      this.player_.tech(true).focus();\n    }\n\n    if (this.player_.paused()) {\n      silencePromise(this.player_.play());\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  return PosterImage;\n}(ClickableComponent);\n\nComponent.registerComponent('PosterImage', PosterImage);\nvar darkGray = '#222';\nvar lightGray = '#ccc';\nvar fontMap = {\n  monospace: 'monospace',\n  sansSerif: 'sans-serif',\n  serif: 'serif',\n  monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\n  monospaceSerif: '\"Courier New\", monospace',\n  proportionalSansSerif: 'sans-serif',\n  proportionalSerif: 'serif',\n  casual: '\"Comic Sans MS\", Impact, fantasy',\n  script: '\"Monotype Corsiva\", cursive',\n  smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\n};\n/**\n * Construct an rgba color from a given hex color code.\n *\n * @param {number} color\n *        Hex number for color, like #f0e or #f604e2.\n *\n * @param {number} opacity\n *        Value for opacity, 0.0 - 1.0.\n *\n * @return {string}\n *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n */\n\nfunction constructColor(color, opacity) {\n  var hex;\n\n  if (color.length === 4) {\n    // color looks like \"#f0e\"\n    hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];\n  } else if (color.length === 7) {\n    // color looks like \"#f604e2\"\n    hex = color.slice(1);\n  } else {\n    throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');\n  }\n\n  return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';\n}\n/**\n * Try to update the style of a DOM element. Some style changes will throw an error,\n * particularly in IE8. Those should be noops.\n *\n * @param {Element} el\n *        The DOM element to be styled.\n *\n * @param {string} style\n *        The CSS property on the element that should be styled.\n *\n * @param {string} rule\n *        The style rule that should be applied to the property.\n *\n * @private\n */\n\n\nfunction tryUpdateStyle(el, style, rule) {\n  try {\n    el.style[style] = rule;\n  } catch (e) {\n    // Satisfies linter.\n    return;\n  }\n}\n/**\n * The component for displaying text track cues.\n *\n * @extends Component\n */\n\n\nvar TextTrackDisplay = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(TextTrackDisplay, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when `TextTrackDisplay` is ready.\n   */\n\n\n  function TextTrackDisplay(player, options, ready) {\n    var _this;\n\n    _this = _Component.call(this, player, options, ready) || this;\n    var updateDisplayHandler = bind(_assertThisInitialized(_this), _this.updateDisplay);\n    player.on('loadstart', bind(_assertThisInitialized(_this), _this.toggleDisplay));\n    player.on('texttrackchange', updateDisplayHandler);\n    player.on('loadedmetadata', bind(_assertThisInitialized(_this), _this.preselectTrack)); // This used to be called during player init, but was causing an error\n    // if a track should show by default and the display hadn't loaded yet.\n    // Should probably be moved to an external track loader when we support\n    // tracks that don't need a display.\n\n    player.ready(bind(_assertThisInitialized(_this), function () {\n      if (player.tech_ && player.tech_.featuresNativeTextTracks) {\n        this.hide();\n        return;\n      }\n\n      player.on('fullscreenchange', updateDisplayHandler);\n      player.on('playerresize', updateDisplayHandler);\n      window$1.addEventListener('orientationchange', updateDisplayHandler);\n      player.on('dispose', function () {\n        return window$1.removeEventListener('orientationchange', updateDisplayHandler);\n      });\n      var tracks = this.options_.playerOptions.tracks || [];\n\n      for (var i = 0; i < tracks.length; i++) {\n        this.player_.addRemoteTextTrack(tracks[i], true);\n      }\n\n      this.preselectTrack();\n    }));\n    return _this;\n  }\n  /**\n  * Preselect a track following this precedence:\n  * - matches the previously selected {@link TextTrack}'s language and kind\n  * - matches the previously selected {@link TextTrack}'s language only\n  * - is the first default captions track\n  * - is the first default descriptions track\n  *\n  * @listens Player#loadstart\n  */\n\n\n  var _proto = TextTrackDisplay.prototype;\n\n  _proto.preselectTrack = function preselectTrack() {\n    var modes = {\n      captions: 1,\n      subtitles: 1\n    };\n    var trackList = this.player_.textTracks();\n    var userPref = this.player_.cache_.selectedLanguage;\n    var firstDesc;\n    var firstCaptions;\n    var preferredTrack;\n\n    for (var i = 0; i < trackList.length; i++) {\n      var track = trackList[i];\n\n      if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {\n        // Always choose the track that matches both language and kind\n        if (track.kind === userPref.kind) {\n          preferredTrack = track; // or choose the first track that matches language\n        } else if (!preferredTrack) {\n          preferredTrack = track;\n        } // clear everything if offTextTrackMenuItem was clicked\n\n      } else if (userPref && !userPref.enabled) {\n        preferredTrack = null;\n        firstDesc = null;\n        firstCaptions = null;\n      } else if (track[\"default\"]) {\n        if (track.kind === 'descriptions' && !firstDesc) {\n          firstDesc = track;\n        } else if (track.kind in modes && !firstCaptions) {\n          firstCaptions = track;\n        }\n      }\n    } // The preferredTrack matches the user preference and takes\n    // precedence over all the other tracks.\n    // So, display the preferredTrack before the first default track\n    // and the subtitles/captions track before the descriptions track\n\n\n    if (preferredTrack) {\n      preferredTrack.mode = 'showing';\n    } else if (firstCaptions) {\n      firstCaptions.mode = 'showing';\n    } else if (firstDesc) {\n      firstDesc.mode = 'showing';\n    }\n  }\n  /**\n   * Turn display of {@link TextTrack}'s from the current state into the other state.\n   * There are only two states:\n   * - 'shown'\n   * - 'hidden'\n   *\n   * @listens Player#loadstart\n   */\n  ;\n\n  _proto.toggleDisplay = function toggleDisplay() {\n    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  /**\n   * Create the {@link Component}'s DOM element.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-text-track-display'\n    }, {\n      'aria-live': 'off',\n      'aria-atomic': 'true'\n    });\n  }\n  /**\n   * Clear all displayed {@link TextTrack}s.\n   */\n  ;\n\n  _proto.clearDisplay = function clearDisplay() {\n    if (typeof window$1.WebVTT === 'function') {\n      window$1.WebVTT.processCues(window$1, [], this.el_);\n    }\n  }\n  /**\n   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n   * a {@link Player#fullscreenchange} is fired.\n   *\n   * @listens Player#texttrackchange\n   * @listens Player#fullscreenchange\n   */\n  ;\n\n  _proto.updateDisplay = function updateDisplay() {\n    var tracks = this.player_.textTracks();\n    var allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;\n    this.clearDisplay();\n\n    if (allowMultipleShowingTracks) {\n      var showingTracks = [];\n\n      for (var _i = 0; _i < tracks.length; ++_i) {\n        var track = tracks[_i];\n\n        if (track.mode !== 'showing') {\n          continue;\n        }\n\n        showingTracks.push(track);\n      }\n\n      this.updateForTrack(showingTracks);\n      return;\n    } //  Track display prioritization model: if multiple tracks are 'showing',\n    //  display the first 'subtitles' or 'captions' track which is 'showing',\n    //  otherwise display the first 'descriptions' track which is 'showing'\n\n\n    var descriptionsTrack = null;\n    var captionsSubtitlesTrack = null;\n    var i = tracks.length;\n\n    while (i--) {\n      var _track = tracks[i];\n\n      if (_track.mode === 'showing') {\n        if (_track.kind === 'descriptions') {\n          descriptionsTrack = _track;\n        } else {\n          captionsSubtitlesTrack = _track;\n        }\n      }\n    }\n\n    if (captionsSubtitlesTrack) {\n      if (this.getAttribute('aria-live') !== 'off') {\n        this.setAttribute('aria-live', 'off');\n      }\n\n      this.updateForTrack(captionsSubtitlesTrack);\n    } else if (descriptionsTrack) {\n      if (this.getAttribute('aria-live') !== 'assertive') {\n        this.setAttribute('aria-live', 'assertive');\n      }\n\n      this.updateForTrack(descriptionsTrack);\n    }\n  }\n  /**\n   * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.\n   *\n   * @param {TextTrack} track\n   *        Text track object containing active cues to style.\n   */\n  ;\n\n  _proto.updateDisplayState = function updateDisplayState(track) {\n    var overrides = this.player_.textTrackSettings.getValues();\n    var cues = track.activeCues;\n    var i = cues.length;\n\n    while (i--) {\n      var cue = cues[i];\n\n      if (!cue) {\n        continue;\n      }\n\n      var cueDiv = cue.displayState;\n\n      if (overrides.color) {\n        cueDiv.firstChild.style.color = overrides.color;\n      }\n\n      if (overrides.textOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\n      }\n\n      if (overrides.backgroundColor) {\n        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\n      }\n\n      if (overrides.backgroundOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\n      }\n\n      if (overrides.windowColor) {\n        if (overrides.windowOpacity) {\n          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\n        } else {\n          cueDiv.style.backgroundColor = overrides.windowColor;\n        }\n      }\n\n      if (overrides.edgeStyle) {\n        if (overrides.edgeStyle === 'dropshadow') {\n          cueDiv.firstChild.style.textShadow = \"2px 2px 3px \" + darkGray + \", 2px 2px 4px \" + darkGray + \", 2px 2px 5px \" + darkGray;\n        } else if (overrides.edgeStyle === 'raised') {\n          cueDiv.firstChild.style.textShadow = \"1px 1px \" + darkGray + \", 2px 2px \" + darkGray + \", 3px 3px \" + darkGray;\n        } else if (overrides.edgeStyle === 'depressed') {\n          cueDiv.firstChild.style.textShadow = \"1px 1px \" + lightGray + \", 0 1px \" + lightGray + \", -1px -1px \" + darkGray + \", 0 -1px \" + darkGray;\n        } else if (overrides.edgeStyle === 'uniform') {\n          cueDiv.firstChild.style.textShadow = \"0 0 4px \" + darkGray + \", 0 0 4px \" + darkGray + \", 0 0 4px \" + darkGray + \", 0 0 4px \" + darkGray;\n        }\n      }\n\n      if (overrides.fontPercent && overrides.fontPercent !== 1) {\n        var fontSize = window$1.parseFloat(cueDiv.style.fontSize);\n        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\n        cueDiv.style.height = 'auto';\n        cueDiv.style.top = 'auto';\n      }\n\n      if (overrides.fontFamily && overrides.fontFamily !== 'default') {\n        if (overrides.fontFamily === 'small-caps') {\n          cueDiv.firstChild.style.fontVariant = 'small-caps';\n        } else {\n          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\n        }\n      }\n    }\n  }\n  /**\n   * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.\n   *\n   * @param {TextTrack|TextTrack[]} tracks\n   *        Text track object or text track array to be added to the list.\n   */\n  ;\n\n  _proto.updateForTrack = function updateForTrack(tracks) {\n    if (!Array.isArray(tracks)) {\n      tracks = [tracks];\n    }\n\n    if (typeof window$1.WebVTT !== 'function' || tracks.every(function (track) {\n      return !track.activeCues;\n    })) {\n      return;\n    }\n\n    var cues = []; // push all active track cues\n\n    for (var i = 0; i < tracks.length; ++i) {\n      var track = tracks[i];\n\n      for (var j = 0; j < track.activeCues.length; ++j) {\n        cues.push(track.activeCues[j]);\n      }\n    } // removes all cues before it processes new ones\n\n\n    window$1.WebVTT.processCues(window$1, cues, this.el_); // add unique class to each language text track & add settings styling if necessary\n\n    for (var _i2 = 0; _i2 < tracks.length; ++_i2) {\n      var _track2 = tracks[_i2];\n\n      for (var _j = 0; _j < _track2.activeCues.length; ++_j) {\n        var cueEl = _track2.activeCues[_j].displayState;\n        addClass(cueEl, 'vjs-text-track-cue');\n        addClass(cueEl, 'vjs-text-track-cue-' + (_track2.language ? _track2.language : _i2));\n      }\n\n      if (this.player_.textTrackSettings) {\n        this.updateDisplayState(_track2);\n      }\n    }\n  };\n\n  return TextTrackDisplay;\n}(Component);\n\nComponent.registerComponent('TextTrackDisplay', TextTrackDisplay);\n/**\n * A loading spinner for use during waiting/loading events.\n *\n * @extends Component\n */\n\nvar LoadingSpinner = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(LoadingSpinner, _Component);\n\n  function LoadingSpinner() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = LoadingSpinner.prototype;\n  /**\n   * Create the `LoadingSpinner`s DOM element.\n   *\n   * @return {Element}\n   *         The dom element that gets created.\n   */\n\n  _proto.createEl = function createEl$1() {\n    var isAudio = this.player_.isAudio();\n    var playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');\n    var controlText = createEl('span', {\n      className: 'vjs-control-text',\n      innerHTML: this.localize('{1} is loading.', [playerType])\n    });\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-loading-spinner',\n      dir: 'ltr'\n    });\n\n    el.appendChild(controlText);\n    return el;\n  };\n\n  return LoadingSpinner;\n}(Component);\n\nComponent.registerComponent('LoadingSpinner', LoadingSpinner);\n/**\n * Base class for all buttons.\n *\n * @extends ClickableComponent\n */\n\nvar Button = /*#__PURE__*/function (_ClickableComponent) {\n  _inheritsLoose(Button, _ClickableComponent);\n\n  function Button() {\n    return _ClickableComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = Button.prototype;\n  /**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} [tag=\"button\"]\n   *        The element's node type. This argument is IGNORED: no matter what\n   *        is passed, it will always create a `button` element.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n  _proto.createEl = function createEl(tag, props, attributes) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    tag = 'button';\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass()\n    }, props); // Add attributes for button element\n\n    attributes = assign({\n      // Necessary since the default button type is \"submit\"\n      type: 'button'\n    }, attributes);\n    var el = Component.prototype.createEl.call(this, tag, props, attributes);\n    this.createControlTextEl(el);\n    return el;\n  }\n  /**\n   * Add a child `Component` inside of this `Button`.\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   *\n   * @deprecated since version 5\n   */\n  ;\n\n  _proto.addChild = function addChild(child, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var className = this.constructor.name;\n    log.warn(\"Adding an actionable (user controllable) child to a Button (\" + className + \") is not supported; use a ClickableComponent instead.\"); // Avoid the error message generated by ClickableComponent's addChild method\n\n    return Component.prototype.addChild.call(this, child, options);\n  }\n  /**\n   * Enable the `Button` element so that it can be activated or clicked. Use this with\n   * {@link Button#disable}.\n   */\n  ;\n\n  _proto.enable = function enable() {\n    _ClickableComponent.prototype.enable.call(this);\n\n    this.el_.removeAttribute('disabled');\n  }\n  /**\n   * Disable the `Button` element so that it cannot be activated or clicked. Use this with\n   * {@link Button#enable}.\n   */\n  ;\n\n  _proto.disable = function disable() {\n    _ClickableComponent.prototype.disable.call(this);\n\n    this.el_.setAttribute('disabled', 'disabled');\n  }\n  /**\n   * This gets called when a `Button` has focus and `keydown` is triggered via a key\n   * press.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to get called.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // Ignore Space or Enter key operation, which is handled by the browser for\n    // a button - though not for its super class, ClickableComponent. Also,\n    // prevent the event from propagating through the DOM and triggering Player\n    // hotkeys. We do not preventDefault here because we _want_ the browser to\n    // handle it.\n    if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n      event.stopPropagation();\n      return;\n    } // Pass keypress handling up for unsupported keys\n\n\n    _ClickableComponent.prototype.handleKeyDown.call(this, event);\n  };\n\n  return Button;\n}(ClickableComponent);\n\nComponent.registerComponent('Button', Button);\n/**\n * The initial play button that shows before the video has played. The hiding of the\n * `BigPlayButton` get done via CSS and `Player` states.\n *\n * @extends Button\n */\n\nvar BigPlayButton = /*#__PURE__*/function (_Button) {\n  _inheritsLoose(BigPlayButton, _Button);\n\n  function BigPlayButton(player, options) {\n    var _this;\n\n    _this = _Button.call(this, player, options) || this;\n    _this.mouseused_ = false;\n\n    _this.on('mousedown', _this.handleMouseDown);\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n   */\n\n\n  var _proto = BigPlayButton.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return 'vjs-big-play-button';\n  }\n  /**\n   * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    var playPromise = this.player_.play(); // exit early if clicked via the mouse\n\n    if (this.mouseused_ && event.clientX && event.clientY) {\n      var sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;\n      silencePromise(playPromise);\n\n      if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where\n      // calling .focus() on the video element causes the video to go black,\n      // so we avoid it in that specific case\n      !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {\n        this.player_.tech(true).focus();\n      }\n\n      return;\n    }\n\n    var cb = this.player_.getChild('controlBar');\n    var playToggle = cb && cb.getChild('playToggle');\n\n    if (!playToggle) {\n      this.player_.tech(true).focus();\n      return;\n    }\n\n    var playFocus = function playFocus() {\n      return playToggle.focus();\n    };\n\n    if (isPromise(playPromise)) {\n      playPromise.then(playFocus, function () {});\n    } else {\n      this.setTimeout(playFocus, 1);\n    }\n  };\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    this.mouseused_ = false;\n\n    _Button.prototype.handleKeyDown.call(this, event);\n  };\n\n  _proto.handleMouseDown = function handleMouseDown(event) {\n    this.mouseused_ = true;\n  };\n\n  return BigPlayButton;\n}(Button);\n/**\n * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nBigPlayButton.prototype.controlText_ = 'Play Video';\nComponent.registerComponent('BigPlayButton', BigPlayButton);\n/**\n * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n * it gets clicked.\n *\n * @extends Button\n */\n\nvar CloseButton = /*#__PURE__*/function (_Button) {\n  _inheritsLoose(CloseButton, _Button);\n  /**\n  * Creates an instance of the this class.\n  *\n  * @param  {Player} player\n  *         The `Player` that this class should be attached to.\n  *\n  * @param  {Object} [options]\n  *         The key/value store of player options.\n  */\n\n\n  function CloseButton(player, options) {\n    var _this;\n\n    _this = _Button.call(this, player, options) || this;\n\n    _this.controlText(options && options.controlText || _this.localize('Close'));\n\n    return _this;\n  }\n  /**\n  * Builds the default DOM `className`.\n  *\n  * @return {string}\n  *         The DOM `className` for this object.\n  */\n\n\n  var _proto = CloseButton.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-close-button \" + _Button.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * This gets called when a `CloseButton` gets clicked. See\n   * {@link ClickableComponent#handleClick} for more information on when\n   * this will be triggered\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @fires CloseButton#close\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    /**\n     * Triggered when the a `CloseButton` is clicked.\n     *\n     * @event CloseButton#close\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up to parents if there is no listener\n     */\n    this.trigger({\n      type: 'close',\n      bubbles: false\n    });\n  }\n  /**\n   * Event handler that is called when a `CloseButton` receives a\n   * `keydown` event.\n   *\n   * By default, if the key is Esc, it will trigger a `click` event.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // Esc button will trigger `click` event\n    if (keycode.isEventKey(event, 'Esc')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.trigger('click');\n    } else {\n      // Pass keypress handling up for unsupported keys\n      _Button.prototype.handleKeyDown.call(this, event);\n    }\n  };\n\n  return CloseButton;\n}(Button);\n\nComponent.registerComponent('CloseButton', CloseButton);\n/**\n * Button to toggle between play and pause.\n *\n * @extends Button\n */\n\nvar PlayToggle = /*#__PURE__*/function (_Button) {\n  _inheritsLoose(PlayToggle, _Button);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n\n\n  function PlayToggle(player, options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Button.call(this, player, options) || this; // show or hide replay icon\n\n    options.replay = options.replay === undefined || options.replay;\n\n    _this.on(player, 'play', _this.handlePlay);\n\n    _this.on(player, 'pause', _this.handlePause);\n\n    if (options.replay) {\n      _this.on(player, 'ended', _this.handleEnded);\n    }\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = PlayToggle.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-play-control \" + _Button.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * This gets called when an `PlayToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  }\n  /**\n   * This gets called once after the video has ended and the user seeks so that\n   * we can change the replay button back to a play button.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#seeked\n   */\n  ;\n\n  _proto.handleSeeked = function handleSeeked(event) {\n    this.removeClass('vjs-ended');\n\n    if (this.player_.paused()) {\n      this.handlePause(event);\n    } else {\n      this.handlePlay(event);\n    }\n  }\n  /**\n   * Add the vjs-playing class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#play\n   */\n  ;\n\n  _proto.handlePlay = function handlePlay(event) {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing'); // change the button text to \"Pause\"\n\n    this.controlText('Pause');\n  }\n  /**\n   * Add the vjs-paused class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#pause\n   */\n  ;\n\n  _proto.handlePause = function handlePause(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused'); // change the button text to \"Play\"\n\n    this.controlText('Play');\n  }\n  /**\n   * Add the vjs-ended class to the element so it can change appearance\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ended\n   */\n  ;\n\n  _proto.handleEnded = function handleEnded(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-ended'); // change the button text to \"Replay\"\n\n    this.controlText('Replay'); // on the next seek remove the replay button\n\n    this.one(this.player_, 'seeked', this.handleSeeked);\n  };\n\n  return PlayToggle;\n}(Button);\n/**\n * The text that should display over the `PlayToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlayToggle.prototype.controlText_ = 'Play';\nComponent.registerComponent('PlayToggle', PlayToggle);\n/**\n * @file format-time.js\n * @module format-time\n */\n\n/**\n * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in\n * seconds) will force a number of leading zeros to cover the length of the\n * guide.\n *\n * @private\n * @param  {number} seconds\n *         Number of seconds to be turned into a string\n *\n * @param  {number} guide\n *         Number (in seconds) to model the string after\n *\n * @return {string}\n *         Time formatted as H:MM:SS or M:SS\n */\n\nvar defaultImplementation = function defaultImplementation(seconds, guide) {\n  seconds = seconds < 0 ? 0 : seconds;\n  var s = Math.floor(seconds % 60);\n  var m = Math.floor(seconds / 60 % 60);\n  var h = Math.floor(seconds / 3600);\n  var gm = Math.floor(guide / 60 % 60);\n  var gh = Math.floor(guide / 3600); // handle invalid times\n\n  if (isNaN(seconds) || seconds === Infinity) {\n    // '-' is false for all relational operators (e.g. <, >=) so this setting\n    // will add the minimum number of fields specified by the guide\n    h = m = s = '-';\n  } // Check if we need to show hours\n\n\n  h = h > 0 || gh > 0 ? h + ':' : ''; // If hours are showing, we may need to add a leading zero.\n  // Always show at least one digit of minutes.\n\n  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':'; // Check if leading zero is need for seconds\n\n  s = s < 10 ? '0' + s : s;\n  return h + m + s;\n}; // Internal pointer to the current implementation.\n\n\nvar implementation = defaultImplementation;\n/**\n * Replaces the default formatTime implementation with a custom implementation.\n *\n * @param {Function} customImplementation\n *        A function which will be used in place of the default formatTime\n *        implementation. Will receive the current time in seconds and the\n *        guide (in seconds) as arguments.\n */\n\nfunction setFormatTime(customImplementation) {\n  implementation = customImplementation;\n}\n/**\n * Resets formatTime to the default implementation.\n */\n\n\nfunction resetFormatTime() {\n  implementation = defaultImplementation;\n}\n/**\n * Delegates to either the default time formatting function or a custom\n * function supplied via `setFormatTime`.\n *\n * Formats seconds as a time string (H:MM:SS or M:SS). Supplying a\n * guide (in seconds) will force a number of leading zeros to cover the\n * length of the guide.\n *\n * @static\n * @example  formatTime(125, 600) === \"02:05\"\n * @param    {number} seconds\n *           Number of seconds to be turned into a string\n *\n * @param    {number} guide\n *           Number (in seconds) to model the string after\n *\n * @return   {string}\n *           Time formatted as H:MM:SS or M:SS\n */\n\n\nfunction formatTime(seconds, guide) {\n  if (guide === void 0) {\n    guide = seconds;\n  }\n\n  return implementation(seconds, guide);\n}\n/**\n * Displays time information about the video\n *\n * @extends Component\n */\n\n\nvar TimeDisplay = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(TimeDisplay, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function TimeDisplay(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n\n    _this.on(player, ['timeupdate', 'ended'], _this.updateContent);\n\n    _this.updateTextNode_();\n\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = TimeDisplay.prototype;\n\n  _proto.createEl = function createEl$1() {\n    var className = this.buildCSSClass();\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: className + \" vjs-time-control vjs-control\",\n      innerHTML: \"<span class=\\\"vjs-control-text\\\" role=\\\"presentation\\\">\" + this.localize(this.labelText_) + \"\\xA0</span>\"\n    });\n\n    this.contentEl_ = createEl('span', {\n      className: className + \"-display\"\n    }, {\n      // tell screen readers not to automatically read the time as it changes\n      'aria-live': 'off',\n      // span elements have no implicit role, but some screen readers (notably VoiceOver)\n      // treat them as a break between items in the DOM when using arrow keys\n      // (or left-to-right swipes on iOS) to read contents of a page. Using\n      // role='presentation' causes VoiceOver to NOT treat this span as a break.\n      'role': 'presentation'\n    });\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  _proto.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.textNode_ = null;\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Updates the time display text node with a new time\n   *\n   * @param {number} [time=0] the time to update to\n   *\n   * @private\n   */\n  ;\n\n  _proto.updateTextNode_ = function updateTextNode_(time) {\n    var _this2 = this;\n\n    if (time === void 0) {\n      time = 0;\n    }\n\n    time = formatTime(time);\n\n    if (this.formattedTime_ === time) {\n      return;\n    }\n\n    this.formattedTime_ = time;\n    this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', function () {\n      if (!_this2.contentEl_) {\n        return;\n      }\n\n      var oldNode = _this2.textNode_;\n      _this2.textNode_ = document.createTextNode(_this2.formattedTime_);\n\n      if (!_this2.textNode_) {\n        return;\n      }\n\n      if (oldNode) {\n        _this2.contentEl_.replaceChild(_this2.textNode_, oldNode);\n      } else {\n        _this2.contentEl_.appendChild(_this2.textNode_);\n      }\n    });\n  }\n  /**\n   * To be filled out in the child class, should update the displayed time\n   * in accordance with the fact that the current time has changed.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate`  event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   */\n  ;\n\n  _proto.updateContent = function updateContent(event) {};\n\n  return TimeDisplay;\n}(Component);\n/**\n * The text that is added to the `TimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nTimeDisplay.prototype.labelText_ = 'Time';\n/**\n * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\n\nTimeDisplay.prototype.controlText_ = 'Time';\nComponent.registerComponent('TimeDisplay', TimeDisplay);\n/**\n * Displays the current time\n *\n * @extends Component\n */\n\nvar CurrentTimeDisplay = /*#__PURE__*/function (_TimeDisplay) {\n  _inheritsLoose(CurrentTimeDisplay, _TimeDisplay);\n\n  function CurrentTimeDisplay() {\n    return _TimeDisplay.apply(this, arguments) || this;\n  }\n\n  var _proto = CurrentTimeDisplay.prototype;\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return 'vjs-current-time';\n  }\n  /**\n   * Update current time display\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` event that caused this function to run.\n   *\n   * @listens Player#timeupdate\n   */\n  ;\n\n  _proto.updateContent = function updateContent(event) {\n    // Allows for smooth scrubbing, when player can't keep up.\n    var time;\n\n    if (this.player_.ended()) {\n      time = this.player_.duration();\n    } else {\n      time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n    }\n\n    this.updateTextNode_(time);\n  };\n\n  return CurrentTimeDisplay;\n}(TimeDisplay);\n/**\n * The text that is added to the `CurrentTimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nCurrentTimeDisplay.prototype.labelText_ = 'Current Time';\n/**\n * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\n\nCurrentTimeDisplay.prototype.controlText_ = 'Current Time';\nComponent.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\n/**\n * Displays the duration\n *\n * @extends Component\n */\n\nvar DurationDisplay = /*#__PURE__*/function (_TimeDisplay) {\n  _inheritsLoose(DurationDisplay, _TimeDisplay);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function DurationDisplay(player, options) {\n    var _this;\n\n    _this = _TimeDisplay.call(this, player, options) || this; // we do not want to/need to throttle duration changes,\n    // as they should always display the changed duration as\n    // it has changed\n\n    _this.on(player, 'durationchange', _this.updateContent); // Listen to loadstart because the player duration is reset when a new media element is loaded,\n    // but the durationchange on the user agent will not fire.\n    // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n\n\n    _this.on(player, 'loadstart', _this.updateContent); // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n    // listeners could have broken dependent applications/libraries. These\n    // can likely be removed for 7.0.\n\n\n    _this.on(player, 'loadedmetadata', _this.updateContent);\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = DurationDisplay.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return 'vjs-duration';\n  }\n  /**\n   * Update duration time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n   *        this function to be called.\n   *\n   * @listens Player#durationchange\n   * @listens Player#timeupdate\n   * @listens Player#loadedmetadata\n   */\n  ;\n\n  _proto.updateContent = function updateContent(event) {\n    var duration = this.player_.duration();\n    this.updateTextNode_(duration);\n  };\n\n  return DurationDisplay;\n}(TimeDisplay);\n/**\n * The text that is added to the `DurationDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nDurationDisplay.prototype.labelText_ = 'Duration';\n/**\n * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\n\nDurationDisplay.prototype.controlText_ = 'Duration';\nComponent.registerComponent('DurationDisplay', DurationDisplay);\n/**\n * The separator between the current time and duration.\n * Can be hidden if it's not needed in the design.\n *\n * @extends Component\n */\n\nvar TimeDivider = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(TimeDivider, _Component);\n\n  function TimeDivider() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = TimeDivider.prototype;\n  /**\n   * Create the component's DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-control vjs-time-divider',\n      innerHTML: '<div><span>/</span></div>'\n    }, {\n      // this element and its contents can be hidden from assistive techs since\n      // it is made extraneous by the announcement of the control text\n      // for the current time and duration displays\n      'aria-hidden': true\n    });\n  };\n\n  return TimeDivider;\n}(Component);\n\nComponent.registerComponent('TimeDivider', TimeDivider);\n/**\n * Displays the time left in the video\n *\n * @extends Component\n */\n\nvar RemainingTimeDisplay = /*#__PURE__*/function (_TimeDisplay) {\n  _inheritsLoose(RemainingTimeDisplay, _TimeDisplay);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function RemainingTimeDisplay(player, options) {\n    var _this;\n\n    _this = _TimeDisplay.call(this, player, options) || this;\n\n    _this.on(player, 'durationchange', _this.updateContent);\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = RemainingTimeDisplay.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return 'vjs-remaining-time';\n  }\n  /**\n   * Create the `Component`'s DOM element with the \"minus\" characted prepend to the time\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ;\n\n  _proto.createEl = function createEl$1() {\n    var el = _TimeDisplay.prototype.createEl.call(this);\n\n    el.insertBefore(createEl('span', {}, {\n      'aria-hidden': true\n    }, '-'), this.contentEl_);\n    return el;\n  }\n  /**\n   * Update remaining time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `durationchange` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   * @listens Player#durationchange\n   */\n  ;\n\n  _proto.updateContent = function updateContent(event) {\n    if (typeof this.player_.duration() !== 'number') {\n      return;\n    }\n\n    var time; // @deprecated We should only use remainingTimeDisplay\n    // as of video.js 7\n\n    if (this.player_.ended()) {\n      time = 0;\n    } else if (this.player_.remainingTimeDisplay) {\n      time = this.player_.remainingTimeDisplay();\n    } else {\n      time = this.player_.remainingTime();\n    }\n\n    this.updateTextNode_(time);\n  };\n\n  return RemainingTimeDisplay;\n}(TimeDisplay);\n/**\n * The text that is added to the `RemainingTimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nRemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';\n/**\n * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\n\nRemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\nComponent.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\n/**\n * Displays the live indicator when duration is Infinity.\n *\n * @extends Component\n */\n\nvar LiveDisplay = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(LiveDisplay, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function LiveDisplay(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n\n    _this.updateShowing();\n\n    _this.on(_this.player(), 'durationchange', _this.updateShowing);\n\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = LiveDisplay.prototype;\n\n  _proto.createEl = function createEl$1() {\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-live-control vjs-control'\n    });\n\n    this.contentEl_ = createEl('div', {\n      className: 'vjs-live-display',\n      innerHTML: \"<span class=\\\"vjs-control-text\\\">\" + this.localize('Stream Type') + \"\\xA0</span>\" + this.localize('LIVE')\n    }, {\n      'aria-live': 'off'\n    });\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  _proto.dispose = function dispose() {\n    this.contentEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n   * it accordingly\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#durationchange} event that caused this function to run.\n   *\n   * @listens Player#durationchange\n   */\n  ;\n\n  _proto.updateShowing = function updateShowing(event) {\n    if (this.player().duration() === Infinity) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  return LiveDisplay;\n}(Component);\n\nComponent.registerComponent('LiveDisplay', LiveDisplay);\n/**\n * Displays the live indicator when duration is Infinity.\n *\n * @extends Component\n */\n\nvar SeekToLive = /*#__PURE__*/function (_Button) {\n  _inheritsLoose(SeekToLive, _Button);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function SeekToLive(player, options) {\n    var _this;\n\n    _this = _Button.call(this, player, options) || this;\n\n    _this.updateLiveEdgeStatus();\n\n    if (_this.player_.liveTracker) {\n      _this.on(_this.player_.liveTracker, 'liveedgechange', _this.updateLiveEdgeStatus);\n    }\n\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = SeekToLive.prototype;\n\n  _proto.createEl = function createEl$1() {\n    var el = _Button.prototype.createEl.call(this, 'button', {\n      className: 'vjs-seek-to-live-control vjs-control'\n    });\n\n    this.textEl_ = createEl('span', {\n      className: 'vjs-seek-to-live-text',\n      innerHTML: this.localize('LIVE')\n    }, {\n      'aria-hidden': 'true'\n    });\n    el.appendChild(this.textEl_);\n    return el;\n  }\n  /**\n   * Update the state of this button if we are at the live edge\n   * or not\n   */\n  ;\n\n  _proto.updateLiveEdgeStatus = function updateLiveEdgeStatus() {\n    // default to live edge\n    if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {\n      this.setAttribute('aria-disabled', true);\n      this.addClass('vjs-at-live-edge');\n      this.controlText('Seek to live, currently playing live');\n    } else {\n      this.setAttribute('aria-disabled', false);\n      this.removeClass('vjs-at-live-edge');\n      this.controlText('Seek to live, currently behind live');\n    }\n  }\n  /**\n   * On click bring us as near to the live point as possible.\n   * This requires that we wait for the next `live-seekable-change`\n   * event which will happen every segment length seconds.\n   */\n  ;\n\n  _proto.handleClick = function handleClick() {\n    this.player_.liveTracker.seekToLiveEdge();\n  }\n  /**\n   * Dispose of the element and stop tracking\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    if (this.player_.liveTracker) {\n      this.off(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatus);\n    }\n\n    this.textEl_ = null;\n\n    _Button.prototype.dispose.call(this);\n  };\n\n  return SeekToLive;\n}(Button);\n\nSeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';\nComponent.registerComponent('SeekToLive', SeekToLive);\n/**\n * Keep a number between a min and a max value\n *\n * @param {number} number\n *        The number to clamp\n *\n * @param {number} min\n *        The minimum value\n * @param {number} max\n *        The maximum value\n *\n * @return {number}\n *         the clamped number\n */\n\nvar clamp = function clamp(number, min, max) {\n  number = Number(number);\n  return Math.min(max, Math.max(min, isNaN(number) ? min : number));\n};\n/**\n * The base functionality for a slider. Can be vertical or horizontal.\n * For instance the volume bar or the seek bar on a video is a slider.\n *\n * @extends Component\n */\n\n\nvar Slider = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Slider, _Component);\n  /**\n  * Create an instance of this class\n  *\n  * @param {Player} player\n  *        The `Player` that this class should be attached to.\n  *\n  * @param {Object} [options]\n  *        The key/value store of player options.\n  */\n\n\n  function Slider(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this; // Set property names to bar to match with the child Slider class is looking for\n\n    _this.bar = _this.getChild(_this.options_.barName); // Set a horizontal or vertical class on the slider depending on the slider type\n\n    _this.vertical(!!_this.options_.vertical);\n\n    _this.enable();\n\n    return _this;\n  }\n  /**\n   * Are controls are currently enabled for this slider or not.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n\n\n  var _proto = Slider.prototype;\n\n  _proto.enabled = function enabled() {\n    return this.enabled_;\n  }\n  /**\n   * Enable controls for this slider if they are disabled\n   */\n  ;\n\n  _proto.enable = function enable() {\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on('mousedown', this.handleMouseDown);\n    this.on('touchstart', this.handleMouseDown);\n    this.on('keydown', this.handleKeyDown);\n    this.on('click', this.handleClick); // TODO: deprecated, controlsvisible does not seem to be fired\n\n    this.on(this.player_, 'controlsvisible', this.update);\n\n    if (this.playerEvent) {\n      this.on(this.player_, this.playerEvent, this.update);\n    }\n\n    this.removeClass('disabled');\n    this.setAttribute('tabindex', 0);\n    this.enabled_ = true;\n  }\n  /**\n   * Disable controls for this slider if they are enabled\n   */\n  ;\n\n  _proto.disable = function disable() {\n    if (!this.enabled()) {\n      return;\n    }\n\n    var doc = this.bar.el_.ownerDocument;\n    this.off('mousedown', this.handleMouseDown);\n    this.off('touchstart', this.handleMouseDown);\n    this.off('keydown', this.handleKeyDown);\n    this.off('click', this.handleClick);\n    this.off(this.player_, 'controlsvisible', this.update);\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n    this.removeAttribute('tabindex');\n    this.addClass('disabled');\n\n    if (this.playerEvent) {\n      this.off(this.player_, this.playerEvent, this.update);\n    }\n\n    this.enabled_ = false;\n  }\n  /**\n   * Create the `Slider`s DOM element.\n   *\n   * @param {string} type\n   *        Type of element to create.\n   *\n   * @param {Object} [props={}]\n   *        List of properties in Object form.\n   *\n   * @param {Object} [attributes={}]\n   *        list of attributes in Object form.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  ;\n\n  _proto.createEl = function createEl(type, props, attributes) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (attributes === void 0) {\n      attributes = {};\n    } // Add the slider element class to all sub classes\n\n\n    props.className = props.className + ' vjs-slider';\n    props = assign({\n      tabIndex: 0\n    }, props);\n    attributes = assign({\n      'role': 'slider',\n      'aria-valuenow': 0,\n      'aria-valuemin': 0,\n      'aria-valuemax': 100,\n      'tabIndex': 0\n    }, attributes);\n    return _Component.prototype.createEl.call(this, type, props, attributes);\n  }\n  /**\n   * Handle `mousedown` or `touchstart` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   * @fires Slider#slideractive\n   */\n  ;\n\n  _proto.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.bar.el_.ownerDocument;\n\n    if (event.type === 'mousedown') {\n      event.preventDefault();\n    } // Do not call preventDefault() on touchstart in Chrome\n    // to avoid console warnings. Use a 'touch-action: none' style\n    // instead to prevent unintented scrolling.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n\n\n    if (event.type === 'touchstart' && !IS_CHROME) {\n      event.preventDefault();\n    }\n\n    blockTextSelection();\n    this.addClass('vjs-sliding');\n    /**\n     * Triggered when the slider is in an active state\n     *\n     * @event Slider#slideractive\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('slideractive');\n    this.on(doc, 'mousemove', this.handleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchmove', this.handleMouseMove);\n    this.on(doc, 'touchend', this.handleMouseUp);\n    this.handleMouseMove(event);\n  }\n  /**\n   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n   * The `mousemove` and `touchmove` events will only only trigger this function during\n   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n   * {@link Slider#handleMouseUp}.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n   *        this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n  ;\n\n  _proto.handleMouseMove = function handleMouseMove(event) {}\n  /**\n   * Handle `mouseup` or `touchend` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   * @fires Slider#sliderinactive\n   */\n  ;\n\n  _proto.handleMouseUp = function handleMouseUp() {\n    var doc = this.bar.el_.ownerDocument;\n    unblockTextSelection();\n    this.removeClass('vjs-sliding');\n    /**\n     * Triggered when the slider is no longer in an active state.\n     *\n     * @event Slider#sliderinactive\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('sliderinactive');\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n    this.update();\n  }\n  /**\n   * Update the progress bar of the `Slider`.\n   *\n   * @return {number}\n   *          The percentage of progress the progress bar represents as a\n   *          number from 0 to 1.\n   */\n  ;\n\n  _proto.update = function update() {\n    var _this2 = this; // In VolumeBar init we have a setTimeout for update that pops and update\n    // to the end of the execution stack. The player is destroyed before then\n    // update will cause an error\n    // If there's no bar...\n\n\n    if (!this.el_ || !this.bar) {\n      return;\n    } // clamp progress between 0 and 1\n    // and only round to four decimal places, as we round to two below\n\n\n    var progress = this.getProgress();\n\n    if (progress === this.progress_) {\n      return progress;\n    }\n\n    this.progress_ = progress;\n    this.requestNamedAnimationFrame('Slider#update', function () {\n      // Set the new bar width or height\n      var sizeKey = _this2.vertical() ? 'height' : 'width'; // Convert to a percentage for css value\n\n      _this2.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';\n    });\n    return progress;\n  }\n  /**\n   * Get the percentage of the bar that should be filled\n   * but clamped and rounded.\n   *\n   * @return {number}\n   *         percentage filled that the slider is\n   */\n  ;\n\n  _proto.getProgress = function getProgress() {\n    return Number(clamp(this.getPercent(), 0, 1).toFixed(4));\n  }\n  /**\n   * Calculate distance for slider\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @return {number}\n   *         The current position of the Slider.\n   *         - position.x for vertical `Slider`s\n   *         - position.y for horizontal `Slider`s\n   */\n  ;\n\n  _proto.calculateDistance = function calculateDistance(event) {\n    var position = getPointerPosition(this.el_, event);\n\n    if (this.vertical()) {\n      return position.y;\n    }\n\n    return position.x;\n  }\n  /**\n   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\n   * arrow keys. This function will only be called when the slider has focus. See\n   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n   *\n   * @param {EventTarget~Event} event\n   *        the `keydown` event that caused this function to run.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // Left and Down Arrows\n    if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.stepBack(); // Up and Right Arrows\n    } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.stepForward();\n    } else {\n      // Pass keydown handling up for unsupported keys\n      _Component.prototype.handleKeyDown.call(this, event);\n    }\n  }\n  /**\n   * Listener for click events on slider, used to prevent clicks\n   *   from bubbling up to parent elements like button menus.\n   *\n   * @param {Object} event\n   *        Event that caused this object to run\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    event.stopPropagation();\n    event.preventDefault();\n  }\n  /**\n   * Get/set if slider is horizontal for vertical\n   *\n   * @param {boolean} [bool]\n   *        - true if slider is vertical,\n   *        - false is horizontal\n   *\n   * @return {boolean}\n   *         - true if slider is vertical, and getting\n   *         - false if the slider is horizontal, and getting\n   */\n  ;\n\n  _proto.vertical = function vertical(bool) {\n    if (bool === undefined) {\n      return this.vertical_ || false;\n    }\n\n    this.vertical_ = !!bool;\n\n    if (this.vertical_) {\n      this.addClass('vjs-slider-vertical');\n    } else {\n      this.addClass('vjs-slider-horizontal');\n    }\n  };\n\n  return Slider;\n}(Component);\n\nComponent.registerComponent('Slider', Slider);\n\nvar percentify = function percentify(time, end) {\n  return clamp(time / end * 100, 0, 100).toFixed(2) + '%';\n};\n/**\n * Shows loading progress\n *\n * @extends Component\n */\n\n\nvar LoadProgressBar = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(LoadProgressBar, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function LoadProgressBar(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n    _this.partEls_ = [];\n\n    _this.on(player, 'progress', _this.update);\n\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = LoadProgressBar.prototype;\n\n  _proto.createEl = function createEl$1() {\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-load-progress'\n    });\n\n    var wrapper = createEl('span', {\n      className: 'vjs-control-text'\n    });\n    var loadedText = createEl('span', {\n      textContent: this.localize('Loaded')\n    });\n    var separator = document.createTextNode(': ');\n    this.percentageEl_ = createEl('span', {\n      className: 'vjs-control-text-loaded-percentage',\n      textContent: '0%'\n    });\n    el.appendChild(wrapper);\n    wrapper.appendChild(loadedText);\n    wrapper.appendChild(separator);\n    wrapper.appendChild(this.percentageEl_);\n    return el;\n  };\n\n  _proto.dispose = function dispose() {\n    this.partEls_ = null;\n    this.percentageEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Update progress bar\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `progress` event that caused this function to run.\n   *\n   * @listens Player#progress\n   */\n  ;\n\n  _proto.update = function update(event) {\n    var _this2 = this;\n\n    this.requestNamedAnimationFrame('LoadProgressBar#update', function () {\n      var liveTracker = _this2.player_.liveTracker;\n\n      var buffered = _this2.player_.buffered();\n\n      var duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration();\n\n      var bufferedEnd = _this2.player_.bufferedEnd();\n\n      var children = _this2.partEls_;\n      var percent = percentify(bufferedEnd, duration);\n\n      if (_this2.percent_ !== percent) {\n        // update the width of the progress bar\n        _this2.el_.style.width = percent; // update the control-text\n\n        textContent(_this2.percentageEl_, percent);\n        _this2.percent_ = percent;\n      } // add child elements to represent the individual buffered time ranges\n\n\n      for (var i = 0; i < buffered.length; i++) {\n        var start = buffered.start(i);\n        var end = buffered.end(i);\n        var part = children[i];\n\n        if (!part) {\n          part = _this2.el_.appendChild(createEl());\n          children[i] = part;\n        } //  only update if changed\n\n\n        if (part.dataset.start === start && part.dataset.end === end) {\n          continue;\n        }\n\n        part.dataset.start = start;\n        part.dataset.end = end; // set the percent based on the width of the progress bar (bufferedEnd)\n\n        part.style.left = percentify(start, bufferedEnd);\n        part.style.width = percentify(end - start, bufferedEnd);\n      } // remove unused buffered range elements\n\n\n      for (var _i = children.length; _i > buffered.length; _i--) {\n        _this2.el_.removeChild(children[_i - 1]);\n      }\n\n      children.length = buffered.length;\n    });\n  };\n\n  return LoadProgressBar;\n}(Component);\n\nComponent.registerComponent('LoadProgressBar', LoadProgressBar);\n/**\n * Time tooltips display a time above the progress bar.\n *\n * @extends Component\n */\n\nvar TimeTooltip = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(TimeTooltip, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function TimeTooltip(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\n    return _this;\n  }\n  /**\n   * Create the time tooltip DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = TimeTooltip.prototype;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-tooltip'\n    }, {\n      'aria-hidden': 'true'\n    });\n  }\n  /**\n   * Updates the position of the time tooltip relative to the `SeekBar`.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n  ;\n\n  _proto.update = function update(seekBarRect, seekBarPoint, content) {\n    var tooltipRect = findPosition(this.el_);\n    var playerRect = getBoundingClientRect(this.player_.el());\n    var seekBarPointPx = seekBarRect.width * seekBarPoint; // do nothing if either rect isn't available\n    // for example, if the player isn't in the DOM for testing\n\n    if (!playerRect || !tooltipRect) {\n      return;\n    } // This is the space left of the `seekBarPoint` available within the bounds\n    // of the player. We calculate any gap between the left edge of the player\n    // and the left edge of the `SeekBar` and add the number of pixels in the\n    // `SeekBar` before hitting the `seekBarPoint`\n\n\n    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx; // This is the space right of the `seekBarPoint` available within the bounds\n    // of the player. We calculate the number of pixels from the `seekBarPoint`\n    // to the right edge of the `SeekBar` and add to that any gap between the\n    // right edge of the `SeekBar` and the player.\n\n    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right); // This is the number of pixels by which the tooltip will need to be pulled\n    // further to the right to center it over the `seekBarPoint`.\n\n    var pullTooltipBy = tooltipRect.width / 2; // Adjust the `pullTooltipBy` distance to the left or right depending on\n    // the results of the space calculations above.\n\n    if (spaceLeftOfPoint < pullTooltipBy) {\n      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n    } else if (spaceRightOfPoint < pullTooltipBy) {\n      pullTooltipBy = spaceRightOfPoint;\n    } // Due to the imprecision of decimal/ratio based calculations and varying\n    // rounding behaviors, there are cases where the spacing adjustment is off\n    // by a pixel or two. This adds insurance to these calculations.\n\n\n    if (pullTooltipBy < 0) {\n      pullTooltipBy = 0;\n    } else if (pullTooltipBy > tooltipRect.width) {\n      pullTooltipBy = tooltipRect.width;\n    }\n\n    this.el_.style.right = \"-\" + pullTooltipBy + \"px\";\n    this.write(content);\n  }\n  /**\n   * Write the time to the tooltip DOM element.\n   *\n   * @param {string} content\n   *        The formatted time for the tooltip.\n   */\n  ;\n\n  _proto.write = function write(content) {\n    textContent(this.el_, content);\n  }\n  /**\n   * Updates the position of the time tooltip relative to the `SeekBar`.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   *\n   * @param {number} time\n   *        The time to update the tooltip to, not used during live playback\n   *\n   * @param {Function} cb\n   *        A function that will be called during the request animation frame\n   *        for tooltips that need to do additional animations from the default\n   */\n  ;\n\n  _proto.updateTime = function updateTime(seekBarRect, seekBarPoint, time, cb) {\n    var _this2 = this;\n\n    this.requestNamedAnimationFrame('TimeTooltip#updateTime', function () {\n      var content;\n\n      var duration = _this2.player_.duration();\n\n      if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {\n        var liveWindow = _this2.player_.liveTracker.liveWindow();\n\n        var secondsBehind = liveWindow - seekBarPoint * liveWindow;\n        content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);\n      } else {\n        content = formatTime(time, duration);\n      }\n\n      _this2.update(seekBarRect, seekBarPoint, content);\n\n      if (cb) {\n        cb();\n      }\n    });\n  };\n\n  return TimeTooltip;\n}(Component);\n\nComponent.registerComponent('TimeTooltip', TimeTooltip);\n/**\n * Used by {@link SeekBar} to display media playback progress as part of the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar PlayProgressBar = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(PlayProgressBar, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function PlayProgressBar(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\n    return _this;\n  }\n  /**\n   * Create the the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = PlayProgressBar.prototype;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-play-progress vjs-slider-bar'\n    }, {\n      'aria-hidden': 'true'\n    });\n  }\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n  ;\n\n  _proto.update = function update(seekBarRect, seekBarPoint) {\n    var timeTooltip = this.getChild('timeTooltip');\n\n    if (!timeTooltip) {\n      return;\n    }\n\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n    timeTooltip.updateTime(seekBarRect, seekBarPoint, time);\n  };\n\n  return PlayProgressBar;\n}(Component);\n/**\n * Default options for {@link PlayProgressBar}.\n *\n * @type {Object}\n * @private\n */\n\n\nPlayProgressBar.prototype.options_ = {\n  children: []\n}; // Time tooltips should not be added to a player on mobile devices\n\nif (!IS_IOS && !IS_ANDROID) {\n  PlayProgressBar.prototype.options_.children.push('timeTooltip');\n}\n\nComponent.registerComponent('PlayProgressBar', PlayProgressBar);\n/**\n * The {@link MouseTimeDisplay} component tracks mouse movement over the\n * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n * indicating the time which is represented by a given point in the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar MouseTimeDisplay = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(MouseTimeDisplay, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function MouseTimeDisplay(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\n    return _this;\n  }\n  /**\n   * Create the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = MouseTimeDisplay.prototype;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-mouse-display'\n    });\n  }\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n  ;\n\n  _proto.update = function update(seekBarRect, seekBarPoint) {\n    var _this2 = this;\n\n    var time = seekBarPoint * this.player_.duration();\n    this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, function () {\n      _this2.el_.style.left = seekBarRect.width * seekBarPoint + \"px\";\n    });\n  };\n\n  return MouseTimeDisplay;\n}(Component);\n/**\n * Default options for `MouseTimeDisplay`\n *\n * @type {Object}\n * @private\n */\n\n\nMouseTimeDisplay.prototype.options_ = {\n  children: ['timeTooltip']\n};\nComponent.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\nvar STEP_SECONDS = 5; // The multiplier of STEP_SECONDS that PgUp/PgDown move the timeline.\n\nvar PAGE_KEY_MULTIPLIER = 12;\n/**\n * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n * as its `bar`.\n *\n * @extends Slider\n */\n\nvar SeekBar = /*#__PURE__*/function (_Slider) {\n  _inheritsLoose(SeekBar, _Slider);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function SeekBar(player, options) {\n    var _this;\n\n    _this = _Slider.call(this, player, options) || this;\n\n    _this.setEventHandlers_();\n\n    return _this;\n  }\n  /**\n   * Sets the event handlers\n   *\n   * @private\n   */\n\n\n  var _proto = SeekBar.prototype;\n\n  _proto.setEventHandlers_ = function setEventHandlers_() {\n    this.update_ = bind(this, this.update);\n    this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);\n    this.on(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n\n    if (this.player_.liveTracker) {\n      this.on(this.player_.liveTracker, 'liveedgechange', this.update);\n    } // when playing, let's ensure we smoothly update the play progress bar\n    // via an interval\n\n\n    this.updateInterval = null;\n    this.on(this.player_, ['playing'], this.enableInterval_);\n    this.on(this.player_, ['ended', 'pause', 'waiting'], this.disableInterval_); // we don't need to update the play progress if the document is hidden,\n    // also, this causes the CPU to spike and eventually crash the page on IE11.\n\n    if ('hidden' in document && 'visibilityState' in document) {\n      this.on(document, 'visibilitychange', this.toggleVisibility_);\n    }\n  };\n\n  _proto.toggleVisibility_ = function toggleVisibility_(e) {\n    if (document.hidden) {\n      this.disableInterval_(e);\n    } else {\n      this.enableInterval_(); // we just switched back to the page and someone may be looking, so, update ASAP\n\n      this.update();\n    }\n  };\n\n  _proto.enableInterval_ = function enableInterval_() {\n    if (this.updateInterval) {\n      return;\n    }\n\n    this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);\n  };\n\n  _proto.disableInterval_ = function disableInterval_(e) {\n    if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {\n      return;\n    }\n\n    if (!this.updateInterval) {\n      return;\n    }\n\n    this.clearInterval(this.updateInterval);\n    this.updateInterval = null;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-holder'\n    }, {\n      'aria-label': this.localize('Progress Bar')\n    });\n  }\n  /**\n   * This function updates the play progress bar and accessibility\n   * attributes to whatever is passed in.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   *\n   * @return {number}\n   *          The current percent at a number from 0-1\n   */\n  ;\n\n  _proto.update = function update(event) {\n    var _this2 = this;\n\n    var percent = _Slider.prototype.update.call(this);\n\n    this.requestNamedAnimationFrame('SeekBar#update', function () {\n      var currentTime = _this2.player_.ended() ? _this2.player_.duration() : _this2.getCurrentTime_();\n      var liveTracker = _this2.player_.liveTracker;\n\n      var duration = _this2.player_.duration();\n\n      if (liveTracker && liveTracker.isLive()) {\n        duration = _this2.player_.liveTracker.liveCurrentTime();\n      }\n\n      if (_this2.percent_ !== percent) {\n        // machine readable value of progress bar (percentage complete)\n        _this2.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\n\n        _this2.percent_ = percent;\n      }\n\n      if (_this2.currentTime_ !== currentTime || _this2.duration_ !== duration) {\n        // human readable value of progress bar (time complete)\n        _this2.el_.setAttribute('aria-valuetext', _this2.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\n\n        _this2.currentTime_ = currentTime;\n        _this2.duration_ = duration;\n      } // update the progress bar time tooltip with the current time\n\n\n      if (_this2.bar) {\n        _this2.bar.update(getBoundingClientRect(_this2.el()), _this2.getProgress());\n      }\n    });\n    return percent;\n  }\n  /**\n   * Get the value of current time but allows for smooth scrubbing,\n   * when player can't keep up.\n   *\n   * @return {number}\n   *         The current time value to display\n   *\n   * @private\n   */\n  ;\n\n  _proto.getCurrentTime_ = function getCurrentTime_() {\n    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n  }\n  /**\n   * Get the percentage of media played so far.\n   *\n   * @return {number}\n   *         The percentage of media played so far (0 to 1).\n   */\n  ;\n\n  _proto.getPercent = function getPercent() {\n    var currentTime = this.getCurrentTime_();\n    var percent;\n    var liveTracker = this.player_.liveTracker;\n\n    if (liveTracker && liveTracker.isLive()) {\n      percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow(); // prevent the percent from changing at the live edge\n\n      if (liveTracker.atLiveEdge()) {\n        percent = 1;\n      }\n    } else {\n      percent = currentTime / this.player_.duration();\n    }\n\n    return percent;\n  }\n  /**\n   * Handle mouse down on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n  ;\n\n  _proto.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    } // Stop event propagation to prevent double fire in progress-control.js\n\n\n    event.stopPropagation();\n    this.player_.scrubbing(true);\n    this.videoWasPlaying = !this.player_.paused();\n    this.player_.pause();\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  }\n  /**\n   * Handle mouse move on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this to run.\n   *\n   * @listens mousemove\n   */\n  ;\n\n  _proto.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    var newTime;\n    var distance = this.calculateDistance(event);\n    var liveTracker = this.player_.liveTracker;\n\n    if (!liveTracker || !liveTracker.isLive()) {\n      newTime = distance * this.player_.duration(); // Don't let video end while scrubbing.\n\n      if (newTime === this.player_.duration()) {\n        newTime = newTime - 0.1;\n      }\n    } else {\n      if (distance >= 0.99) {\n        liveTracker.seekToLiveEdge();\n        return;\n      }\n\n      var seekableStart = liveTracker.seekableStart();\n      var seekableEnd = liveTracker.liveCurrentTime();\n      newTime = seekableStart + distance * liveTracker.liveWindow(); // Don't let video end while scrubbing.\n\n      if (newTime >= seekableEnd) {\n        newTime = seekableEnd;\n      } // Compensate for precision differences so that currentTime is not less\n      // than seekable start\n\n\n      if (newTime <= seekableStart) {\n        newTime = seekableStart + 0.1;\n      } // On android seekableEnd can be Infinity sometimes,\n      // this will cause newTime to be Infinity, which is\n      // not a valid currentTime.\n\n\n      if (newTime === Infinity) {\n        return;\n      }\n    } // Set new time (tell player to seek to new time)\n\n\n    this.player_.currentTime(newTime);\n  };\n\n  _proto.enable = function enable() {\n    _Slider.prototype.enable.call(this);\n\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.show();\n  };\n\n  _proto.disable = function disable() {\n    _Slider.prototype.disable.call(this);\n\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.hide();\n  }\n  /**\n   * Handle mouse up on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseup` event that caused this to run.\n   *\n   * @listens mouseup\n   */\n  ;\n\n  _proto.handleMouseUp = function handleMouseUp(event) {\n    _Slider.prototype.handleMouseUp.call(this, event); // Stop event propagation to prevent double fire in progress-control.js\n\n\n    if (event) {\n      event.stopPropagation();\n    }\n\n    this.player_.scrubbing(false);\n    /**\n     * Trigger timeupdate because we're done seeking and the time has changed.\n     * This is particularly useful for if the player is paused to time the time displays.\n     *\n     * @event Tech#timeupdate\n     * @type {EventTarget~Event}\n     */\n\n    this.player_.trigger({\n      type: 'timeupdate',\n      target: this,\n      manuallyTriggered: true\n    });\n\n    if (this.videoWasPlaying) {\n      silencePromise(this.player_.play());\n    } else {\n      // We're done seeking and the time has changed.\n      // If the player is paused, make sure we display the correct time on the seek bar.\n      this.update_();\n    }\n  }\n  /**\n   * Move more quickly fast forward for keyboard-only users\n   */\n  ;\n\n  _proto.stepForward = function stepForward() {\n    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);\n  }\n  /**\n   * Move more quickly rewind for keyboard-only users\n   */\n  ;\n\n  _proto.stepBack = function stepBack() {\n    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);\n  }\n  /**\n   * Toggles the playback state of the player\n   * This gets called when enter or space is used on the seekbar\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called\n   *\n   */\n  ;\n\n  _proto.handleAction = function handleAction(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  }\n  /**\n   * Called when this SeekBar has focus and a key gets pressed down.\n   * Supports the following keys:\n   *\n   *   Space or Enter key fire a click event\n   *   Home key moves to start of the timeline\n   *   End key moves to end of the timeline\n   *   Digit \"0\" through \"9\" keys move to 0%, 10% ... 80%, 90% of the timeline\n   *   PageDown key moves back a larger step than ArrowDown\n   *   PageUp key moves forward a large step\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.handleAction(event);\n    } else if (keycode.isEventKey(event, 'Home')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.player_.currentTime(0);\n    } else if (keycode.isEventKey(event, 'End')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.player_.currentTime(this.player_.duration());\n    } else if (/^[0-9]$/.test(keycode(event))) {\n      event.preventDefault();\n      event.stopPropagation();\n      var gotoFraction = (keycode.codes[keycode(event)] - keycode.codes['0']) * 10.0 / 100.0;\n      this.player_.currentTime(this.player_.duration() * gotoFraction);\n    } else if (keycode.isEventKey(event, 'PgDn')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n    } else if (keycode.isEventKey(event, 'PgUp')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n    } else {\n      // Pass keydown handling up for unsupported keys\n      _Slider.prototype.handleKeyDown.call(this, event);\n    }\n  };\n\n  _proto.dispose = function dispose() {\n    this.disableInterval_();\n    this.off(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n\n    if (this.player_.liveTracker) {\n      this.on(this.player_.liveTracker, 'liveedgechange', this.update);\n    }\n\n    this.off(this.player_, ['playing'], this.enableInterval_);\n    this.off(this.player_, ['ended', 'pause', 'waiting'], this.disableInterval_); // we don't need to update the play progress if the document is hidden,\n    // also, this causes the CPU to spike and eventually crash the page on IE11.\n\n    if ('hidden' in document && 'visibilityState' in document) {\n      this.off(document, 'visibilitychange', this.toggleVisibility_);\n    }\n\n    _Slider.prototype.dispose.call(this);\n  };\n\n  return SeekBar;\n}(Slider);\n/**\n * Default options for the `SeekBar`\n *\n * @type {Object}\n * @private\n */\n\n\nSeekBar.prototype.options_ = {\n  children: ['loadProgressBar', 'playProgressBar'],\n  barName: 'playProgressBar'\n}; // MouseTimeDisplay tooltips should not be added to a player on mobile devices\n\nif (!IS_IOS && !IS_ANDROID) {\n  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\n}\n\nComponent.registerComponent('SeekBar', SeekBar);\n/**\n * The Progress Control component contains the seek bar, load progress,\n * and play progress.\n *\n * @extends Component\n */\n\nvar ProgressControl = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ProgressControl, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function ProgressControl(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n    _this.handleMouseMove = throttle(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n    _this.throttledHandleMouseSeek = throttle(bind(_assertThisInitialized(_this), _this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);\n\n    _this.enable();\n\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = ProgressControl.prototype;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-control vjs-control'\n    });\n  }\n  /**\n   * When the mouse moves over the `ProgressControl`, the pointer position\n   * gets passed down to the `MouseTimeDisplay` component.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   */\n  ;\n\n  _proto.handleMouseMove = function handleMouseMove(event) {\n    var seekBar = this.getChild('seekBar');\n\n    if (!seekBar) {\n      return;\n    }\n\n    var playProgressBar = seekBar.getChild('playProgressBar');\n    var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\n\n    if (!playProgressBar && !mouseTimeDisplay) {\n      return;\n    }\n\n    var seekBarEl = seekBar.el();\n    var seekBarRect = findPosition(seekBarEl);\n    var seekBarPoint = getPointerPosition(seekBarEl, event).x; // The default skin has a gap on either side of the `SeekBar`. This means\n    // that it's possible to trigger this behavior outside the boundaries of\n    // the `SeekBar`. This ensures we stay within it at all times.\n\n    seekBarPoint = clamp(seekBarPoint, 0, 1);\n\n    if (mouseTimeDisplay) {\n      mouseTimeDisplay.update(seekBarRect, seekBarPoint);\n    }\n\n    if (playProgressBar) {\n      playProgressBar.update(seekBarRect, seekBar.getProgress());\n    }\n  }\n  /**\n   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n   *\n   * @method ProgressControl#throttledHandleMouseSeek\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   * @listen touchmove\n   */\n\n  /**\n   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n  ;\n\n  _proto.handleMouseSeek = function handleMouseSeek(event) {\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseMove(event);\n    }\n  }\n  /**\n   * Are controls are currently enabled for this progress control.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n  ;\n\n  _proto.enabled = function enabled() {\n    return this.enabled_;\n  }\n  /**\n   * Disable all controls on the progress control and its children\n   */\n  ;\n\n  _proto.disable = function disable() {\n    this.children().forEach(function (child) {\n      return child.disable && child.disable();\n    });\n\n    if (!this.enabled()) {\n      return;\n    }\n\n    this.off(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.off(this.el_, 'mousemove', this.handleMouseMove);\n    this.handleMouseUp();\n    this.addClass('disabled');\n    this.enabled_ = false;\n  }\n  /**\n   * Enable all controls on the progress control and its children\n   */\n  ;\n\n  _proto.enable = function enable() {\n    this.children().forEach(function (child) {\n      return child.enable && child.enable();\n    });\n\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.on(this.el_, 'mousemove', this.handleMouseMove);\n    this.removeClass('disabled');\n    this.enabled_ = true;\n  }\n  /**\n   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n  ;\n\n  _proto.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseDown(event);\n    }\n\n    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  }\n  /**\n   * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n  ;\n\n  _proto.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseUp(event);\n    }\n\n    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  };\n\n  return ProgressControl;\n}(Component);\n/**\n * Default options for `ProgressControl`\n *\n * @type {Object}\n * @private\n */\n\n\nProgressControl.prototype.options_ = {\n  children: ['seekBar']\n};\nComponent.registerComponent('ProgressControl', ProgressControl);\n/**\n * Toggle Picture-in-Picture mode\n *\n * @extends Button\n */\n\nvar PictureInPictureToggle = /*#__PURE__*/function (_Button) {\n  _inheritsLoose(PictureInPictureToggle, _Button);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @listens Player#enterpictureinpicture\n   * @listens Player#leavepictureinpicture\n   */\n\n\n  function PictureInPictureToggle(player, options) {\n    var _this;\n\n    _this = _Button.call(this, player, options) || this;\n\n    _this.on(player, ['enterpictureinpicture', 'leavepictureinpicture'], _this.handlePictureInPictureChange);\n\n    _this.on(player, ['disablepictureinpicturechanged', 'loadedmetadata'], _this.handlePictureInPictureEnabledChange); // TODO: Deactivate button on player emptied event.\n\n\n    _this.disable();\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = PictureInPictureToggle.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-picture-in-picture-control \" + _Button.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Enables or disables button based on document.pictureInPictureEnabled property value\n   * or on value returned by player.disablePictureInPicture() method.\n   */\n  ;\n\n  _proto.handlePictureInPictureEnabledChange = function handlePictureInPictureEnabledChange() {\n    if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {\n      this.enable();\n    } else {\n      this.disable();\n    }\n  }\n  /**\n   * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be\n   *        called.\n   *\n   * @listens Player#enterpictureinpicture\n   * @listens Player#leavepictureinpicture\n   */\n  ;\n\n  _proto.handlePictureInPictureChange = function handlePictureInPictureChange(event) {\n    if (this.player_.isInPictureInPicture()) {\n      this.controlText('Exit Picture-in-Picture');\n    } else {\n      this.controlText('Picture-in-Picture');\n    }\n\n    this.handlePictureInPictureEnabledChange();\n  }\n  /**\n   * This gets called when an `PictureInPictureToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    if (!this.player_.isInPictureInPicture()) {\n      this.player_.requestPictureInPicture();\n    } else {\n      this.player_.exitPictureInPicture();\n    }\n  };\n\n  return PictureInPictureToggle;\n}(Button);\n/**\n * The text that should display over the `PictureInPictureToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';\nComponent.registerComponent('PictureInPictureToggle', PictureInPictureToggle);\n/**\n * Toggle fullscreen video\n *\n * @extends Button\n */\n\nvar FullscreenToggle = /*#__PURE__*/function (_Button) {\n  _inheritsLoose(FullscreenToggle, _Button);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function FullscreenToggle(player, options) {\n    var _this;\n\n    _this = _Button.call(this, player, options) || this;\n\n    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);\n\n    if (document[player.fsApi_.fullscreenEnabled] === false) {\n      _this.disable();\n    }\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = FullscreenToggle.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-fullscreen-control \" + _Button.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Handles fullscreenchange on the player and change control text accordingly.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#fullscreenchange} event that caused this function to be\n   *        called.\n   *\n   * @listens Player#fullscreenchange\n   */\n  ;\n\n  _proto.handleFullscreenChange = function handleFullscreenChange(event) {\n    if (this.player_.isFullscreen()) {\n      this.controlText('Non-Fullscreen');\n    } else {\n      this.controlText('Fullscreen');\n    }\n  }\n  /**\n   * This gets called when an `FullscreenToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    if (!this.player_.isFullscreen()) {\n      this.player_.requestFullscreen();\n    } else {\n      this.player_.exitFullscreen();\n    }\n  };\n\n  return FullscreenToggle;\n}(Button);\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nFullscreenToggle.prototype.controlText_ = 'Fullscreen';\nComponent.registerComponent('FullscreenToggle', FullscreenToggle);\n/**\n * Check if volume control is supported and if it isn't hide the\n * `Component` that was passed  using the `vjs-hidden` class.\n *\n * @param {Component} self\n *        The component that should be hidden if volume is unsupported\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */\n\nvar checkVolumeSupport = function checkVolumeSupport(self, player) {\n  // hide volume controls when they're not supported by the current tech\n  if (player.tech_ && !player.tech_.featuresVolumeControl) {\n    self.addClass('vjs-hidden');\n  }\n\n  self.on(player, 'loadstart', function () {\n    if (!player.tech_.featuresVolumeControl) {\n      self.addClass('vjs-hidden');\n    } else {\n      self.removeClass('vjs-hidden');\n    }\n  });\n};\n/**\n * Shows volume level\n *\n * @extends Component\n */\n\n\nvar VolumeLevel = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(VolumeLevel, _Component);\n\n  function VolumeLevel() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = VolumeLevel.prototype;\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-level',\n      innerHTML: '<span class=\"vjs-control-text\"></span>'\n    });\n  };\n\n  return VolumeLevel;\n}(Component);\n\nComponent.registerComponent('VolumeLevel', VolumeLevel);\n/**\n * The bar that contains the volume level and can be clicked on to adjust the level\n *\n * @extends Slider\n */\n\nvar VolumeBar = /*#__PURE__*/function (_Slider) {\n  _inheritsLoose(VolumeBar, _Slider);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function VolumeBar(player, options) {\n    var _this;\n\n    _this = _Slider.call(this, player, options) || this;\n\n    _this.on('slideractive', _this.updateLastVolume_);\n\n    _this.on(player, 'volumechange', _this.updateARIAAttributes);\n\n    player.ready(function () {\n      return _this.updateARIAAttributes();\n    });\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = VolumeBar.prototype;\n\n  _proto.createEl = function createEl() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-bar vjs-slider-bar'\n    }, {\n      'aria-label': this.localize('Volume Level'),\n      'aria-live': 'polite'\n    });\n  }\n  /**\n   * Handle mouse down on volume bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n  ;\n\n  _proto.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  }\n  /**\n   * Handle movement events on the {@link VolumeMenuButton}.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @listens mousemove\n   */\n  ;\n\n  _proto.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    this.checkMuted();\n    this.player_.volume(this.calculateDistance(event));\n  }\n  /**\n   * If the player is muted unmute it.\n   */\n  ;\n\n  _proto.checkMuted = function checkMuted() {\n    if (this.player_.muted()) {\n      this.player_.muted(false);\n    }\n  }\n  /**\n   * Get percent of volume level\n   *\n   * @return {number}\n   *         Volume level percent as a decimal number.\n   */\n  ;\n\n  _proto.getPercent = function getPercent() {\n    if (this.player_.muted()) {\n      return 0;\n    }\n\n    return this.player_.volume();\n  }\n  /**\n   * Increase volume level for keyboard users\n   */\n  ;\n\n  _proto.stepForward = function stepForward() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() + 0.1);\n  }\n  /**\n   * Decrease volume level for keyboard users\n   */\n  ;\n\n  _proto.stepBack = function stepBack() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() - 0.1);\n  }\n  /**\n   * Update ARIA accessibility attributes\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `volumechange` event that caused this function to run.\n   *\n   * @listens Player#volumechange\n   */\n  ;\n\n  _proto.updateARIAAttributes = function updateARIAAttributes(event) {\n    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\n    this.el_.setAttribute('aria-valuenow', ariaValue);\n    this.el_.setAttribute('aria-valuetext', ariaValue + '%');\n  }\n  /**\n   * Returns the current value of the player volume as a percentage\n   *\n   * @private\n   */\n  ;\n\n  _proto.volumeAsPercentage_ = function volumeAsPercentage_() {\n    return Math.round(this.player_.volume() * 100);\n  }\n  /**\n   * When user starts dragging the VolumeBar, store the volume and listen for\n   * the end of the drag. When the drag ends, if the volume was set to zero,\n   * set lastVolume to the stored volume.\n   *\n   * @listens slideractive\n   * @private\n   */\n  ;\n\n  _proto.updateLastVolume_ = function updateLastVolume_() {\n    var _this2 = this;\n\n    var volumeBeforeDrag = this.player_.volume();\n    this.one('sliderinactive', function () {\n      if (_this2.player_.volume() === 0) {\n        _this2.player_.lastVolume_(volumeBeforeDrag);\n      }\n    });\n  };\n\n  return VolumeBar;\n}(Slider);\n/**\n * Default options for the `VolumeBar`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeBar.prototype.options_ = {\n  children: ['volumeLevel'],\n  barName: 'volumeLevel'\n};\n/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */\n\nVolumeBar.prototype.playerEvent = 'volumechange';\nComponent.registerComponent('VolumeBar', VolumeBar);\n/**\n * The component for controlling the volume level\n *\n * @extends Component\n */\n\nvar VolumeControl = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(VolumeControl, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n\n\n  function VolumeControl(player, options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    options.vertical = options.vertical || false; // Pass the vertical option down to the VolumeBar if\n    // the VolumeBar is turned on.\n\n    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\n      options.volumeBar = options.volumeBar || {};\n      options.volumeBar.vertical = options.vertical;\n    }\n\n    _this = _Component.call(this, player, options) || this; // hide this control if volume support is missing\n\n    checkVolumeSupport(_assertThisInitialized(_this), player);\n    _this.throttledHandleMouseMove = throttle(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n\n    _this.on('mousedown', _this.handleMouseDown);\n\n    _this.on('touchstart', _this.handleMouseDown); // while the slider is active (the mouse has been pressed down and\n    // is dragging) or in focus we do not want to hide the VolumeBar\n\n\n    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {\n      _this.volumeBar.addClass('vjs-slider-active');\n\n      _this.addClass('vjs-slider-active');\n\n      _this.trigger('slideractive');\n    });\n\n    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {\n      _this.volumeBar.removeClass('vjs-slider-active');\n\n      _this.removeClass('vjs-slider-active');\n\n      _this.trigger('sliderinactive');\n    });\n\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = VolumeControl.prototype;\n\n  _proto.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-horizontal';\n\n    if (this.options_.vertical) {\n      orientationClass = 'vjs-volume-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: \"vjs-volume-control vjs-control \" + orientationClass\n    });\n  }\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n  ;\n\n  _proto.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n    this.on(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.on(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  }\n  /**\n   * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n  ;\n\n  _proto.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n    this.off(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.off(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  }\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n  ;\n\n  _proto.handleMouseMove = function handleMouseMove(event) {\n    this.volumeBar.handleMouseMove(event);\n  };\n\n  return VolumeControl;\n}(Component);\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeControl.prototype.options_ = {\n  children: ['volumeBar']\n};\nComponent.registerComponent('VolumeControl', VolumeControl);\n/**\n * Check if muting volume is supported and if it isn't hide the mute toggle\n * button.\n *\n * @param {Component} self\n *        A reference to the mute toggle button\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */\n\nvar checkMuteSupport = function checkMuteSupport(self, player) {\n  // hide mute toggle button if it's not supported by the current tech\n  if (player.tech_ && !player.tech_.featuresMuteControl) {\n    self.addClass('vjs-hidden');\n  }\n\n  self.on(player, 'loadstart', function () {\n    if (!player.tech_.featuresMuteControl) {\n      self.addClass('vjs-hidden');\n    } else {\n      self.removeClass('vjs-hidden');\n    }\n  });\n};\n/**\n * A button component for muting the audio.\n *\n * @extends Button\n */\n\n\nvar MuteToggle = /*#__PURE__*/function (_Button) {\n  _inheritsLoose(MuteToggle, _Button);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function MuteToggle(player, options) {\n    var _this;\n\n    _this = _Button.call(this, player, options) || this; // hide this control if volume support is missing\n\n    checkMuteSupport(_assertThisInitialized(_this), player);\n\n    _this.on(player, ['loadstart', 'volumechange'], _this.update);\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = MuteToggle.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-mute-control \" + _Button.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * This gets called when an `MuteToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    var vol = this.player_.volume();\n    var lastVolume = this.player_.lastVolume_();\n\n    if (vol === 0) {\n      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\n      this.player_.volume(volumeToSet);\n      this.player_.muted(false);\n    } else {\n      this.player_.muted(this.player_.muted() ? false : true);\n    }\n  }\n  /**\n   * Update the `MuteToggle` button based on the state of `volume` and `muted`\n   * on the player.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#loadstart} event if this function was called\n   *        through an event.\n   *\n   * @listens Player#loadstart\n   * @listens Player#volumechange\n   */\n  ;\n\n  _proto.update = function update(event) {\n    this.updateIcon_();\n    this.updateControlText_();\n  }\n  /**\n   * Update the appearance of the `MuteToggle` icon.\n   *\n   * Possible states (given `level` variable below):\n   * - 0: crossed out\n   * - 1: zero bars of volume\n   * - 2: one bar of volume\n   * - 3: two bars of volume\n   *\n   * @private\n   */\n  ;\n\n  _proto.updateIcon_ = function updateIcon_() {\n    var vol = this.player_.volume();\n    var level = 3; // in iOS when a player is loaded with muted attribute\n    // and volume is changed with a native mute button\n    // we want to make sure muted state is updated\n\n    if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {\n      this.player_.muted(this.player_.tech_.el_.muted);\n    }\n\n    if (vol === 0 || this.player_.muted()) {\n      level = 0;\n    } else if (vol < 0.33) {\n      level = 1;\n    } else if (vol < 0.67) {\n      level = 2;\n    } // TODO improve muted icon classes\n\n\n    for (var i = 0; i < 4; i++) {\n      removeClass(this.el_, \"vjs-vol-\" + i);\n    }\n\n    addClass(this.el_, \"vjs-vol-\" + level);\n  }\n  /**\n   * If `muted` has changed on the player, update the control text\n   * (`title` attribute on `vjs-mute-control` element and content of\n   * `vjs-control-text` element).\n   *\n   * @private\n   */\n  ;\n\n  _proto.updateControlText_ = function updateControlText_() {\n    var soundOff = this.player_.muted() || this.player_.volume() === 0;\n    var text = soundOff ? 'Unmute' : 'Mute';\n\n    if (this.controlText() !== text) {\n      this.controlText(text);\n    }\n  };\n\n  return MuteToggle;\n}(Button);\n/**\n * The text that should display over the `MuteToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nMuteToggle.prototype.controlText_ = 'Mute';\nComponent.registerComponent('MuteToggle', MuteToggle);\n/**\n * A Component to contain the MuteToggle and VolumeControl so that\n * they can work together.\n *\n * @extends Component\n */\n\nvar VolumePanel = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(VolumePanel, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n\n\n  function VolumePanel(player, options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (typeof options.inline !== 'undefined') {\n      options.inline = options.inline;\n    } else {\n      options.inline = true;\n    } // pass the inline option down to the VolumeControl as vertical if\n    // the VolumeControl is on.\n\n\n    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\n      options.volumeControl = options.volumeControl || {};\n      options.volumeControl.vertical = !options.inline;\n    }\n\n    _this = _Component.call(this, player, options) || this;\n\n    _this.on(player, ['loadstart'], _this.volumePanelState_);\n\n    _this.on(_this.muteToggle, 'keyup', _this.handleKeyPress);\n\n    _this.on(_this.volumeControl, 'keyup', _this.handleVolumeControlKeyUp);\n\n    _this.on('keydown', _this.handleKeyPress);\n\n    _this.on('mouseover', _this.handleMouseOver);\n\n    _this.on('mouseout', _this.handleMouseOut); // while the slider is active (the mouse has been pressed down and\n    // is dragging) we do not want to hide the VolumeBar\n\n\n    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);\n\n    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);\n\n    return _this;\n  }\n  /**\n   * Add vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#slideractive\n   * @private\n   */\n\n\n  var _proto = VolumePanel.prototype;\n\n  _proto.sliderActive_ = function sliderActive_() {\n    this.addClass('vjs-slider-active');\n  }\n  /**\n   * Removes vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#sliderinactive\n   * @private\n   */\n  ;\n\n  _proto.sliderInactive_ = function sliderInactive_() {\n    this.removeClass('vjs-slider-active');\n  }\n  /**\n   * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel\n   * depending on MuteToggle and VolumeControl state\n   *\n   * @listens Player#loadstart\n   * @private\n   */\n  ;\n\n  _proto.volumePanelState_ = function volumePanelState_() {\n    // hide volume panel if neither volume control or mute toggle\n    // are displayed\n    if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {\n      this.addClass('vjs-hidden');\n    } // if only mute toggle is visible we don't want\n    // volume panel expanding when hovered or active\n\n\n    if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {\n      this.addClass('vjs-mute-toggle-only');\n    }\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-panel-horizontal';\n\n    if (!this.options_.inline) {\n      orientationClass = 'vjs-volume-panel-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: \"vjs-volume-panel vjs-control \" + orientationClass\n    });\n  }\n  /**\n   * Dispose of the `volume-panel` and all child components.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.handleMouseOut();\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes\n   * the volume panel and sets focus on `MuteToggle`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keyup` event that caused this function to be called.\n   *\n   * @listens keyup\n   */\n  ;\n\n  _proto.handleVolumeControlKeyUp = function handleVolumeControlKeyUp(event) {\n    if (keycode.isEventKey(event, 'Esc')) {\n      this.muteToggle.focus();\n    }\n  }\n  /**\n   * This gets called when a `VolumePanel` gains hover via a `mouseover` event.\n   * Turns on listening for `mouseover` event. When they happen it\n   * calls `this.handleMouseOver`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseover` event that caused this function to be called.\n   *\n   * @listens mouseover\n   */\n  ;\n\n  _proto.handleMouseOver = function handleMouseOver(event) {\n    this.addClass('vjs-hover');\n    on(document, 'keyup', bind(this, this.handleKeyPress));\n  }\n  /**\n   * This gets called when a `VolumePanel` gains hover via a `mouseout` event.\n   * Turns on listening for `mouseout` event. When they happen it\n   * calls `this.handleMouseOut`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseout` event that caused this function to be called.\n   *\n   * @listens mouseout\n   */\n  ;\n\n  _proto.handleMouseOut = function handleMouseOut(event) {\n    this.removeClass('vjs-hover');\n    off(document, 'keyup', bind(this, this.handleKeyPress));\n  }\n  /**\n   * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,\n   * looking for ESC, which hides the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        The keypress that triggered this event.\n   *\n   * @listens keydown | keyup\n   */\n  ;\n\n  _proto.handleKeyPress = function handleKeyPress(event) {\n    if (keycode.isEventKey(event, 'Esc')) {\n      this.handleMouseOut();\n    }\n  };\n\n  return VolumePanel;\n}(Component);\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumePanel.prototype.options_ = {\n  children: ['muteToggle', 'volumeControl']\n};\nComponent.registerComponent('VolumePanel', VolumePanel);\n/**\n * The Menu component is used to build popup menus, including subtitle and\n * captions selection menus.\n *\n * @extends Component\n */\n\nvar Menu = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Menu, _Component);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        the player that this component should attach to\n   *\n   * @param {Object} [options]\n   *        Object of option names and values\n   *\n   */\n\n\n  function Menu(player, options) {\n    var _this;\n\n    _this = _Component.call(this, player, options) || this;\n\n    if (options) {\n      _this.menuButton_ = options.menuButton;\n    }\n\n    _this.focusedChild_ = -1;\n\n    _this.on('keydown', _this.handleKeyDown); // All the menu item instances share the same blur handler provided by the menu container.\n\n\n    _this.boundHandleBlur_ = bind(_assertThisInitialized(_this), _this.handleBlur);\n    _this.boundHandleTapClick_ = bind(_assertThisInitialized(_this), _this.handleTapClick);\n    return _this;\n  }\n  /**\n   * Add event listeners to the {@link MenuItem}.\n   *\n   * @param {Object} component\n   *        The instance of the `MenuItem` to add listeners to.\n   *\n   */\n\n\n  var _proto = Menu.prototype;\n\n  _proto.addEventListenerForItem = function addEventListenerForItem(component) {\n    if (!(component instanceof Component)) {\n      return;\n    }\n\n    this.on(component, 'blur', this.boundHandleBlur_);\n    this.on(component, ['tap', 'click'], this.boundHandleTapClick_);\n  }\n  /**\n   * Remove event listeners from the {@link MenuItem}.\n   *\n   * @param {Object} component\n   *        The instance of the `MenuItem` to remove listeners.\n   *\n   */\n  ;\n\n  _proto.removeEventListenerForItem = function removeEventListenerForItem(component) {\n    if (!(component instanceof Component)) {\n      return;\n    }\n\n    this.off(component, 'blur', this.boundHandleBlur_);\n    this.off(component, ['tap', 'click'], this.boundHandleTapClick_);\n  }\n  /**\n   * This method will be called indirectly when the component has been added\n   * before the component adds to the new menu instance by `addItem`.\n   * In this case, the original menu instance will remove the component\n   * by calling `removeChild`.\n   *\n   * @param {Object} component\n   *        The instance of the `MenuItem`\n   */\n  ;\n\n  _proto.removeChild = function removeChild(component) {\n    if (typeof component === 'string') {\n      component = this.getChild(component);\n    }\n\n    this.removeEventListenerForItem(component);\n\n    _Component.prototype.removeChild.call(this, component);\n  }\n  /**\n   * Add a {@link MenuItem} to the menu.\n   *\n   * @param {Object|string} component\n   *        The name or instance of the `MenuItem` to add.\n   *\n   */\n  ;\n\n  _proto.addItem = function addItem(component) {\n    var childComponent = this.addChild(component);\n\n    if (childComponent) {\n      this.addEventListenerForItem(childComponent);\n    }\n  }\n  /**\n   * Create the `Menu`s DOM element.\n   *\n   * @return {Element}\n   *         the element that was created\n   */\n  ;\n\n  _proto.createEl = function createEl$1() {\n    var contentElType = this.options_.contentElType || 'ul';\n    this.contentEl_ = createEl(contentElType, {\n      className: 'vjs-menu-content'\n    });\n    this.contentEl_.setAttribute('role', 'menu');\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      append: this.contentEl_,\n      className: 'vjs-menu'\n    });\n\n    el.appendChild(this.contentEl_); // Prevent clicks from bubbling up. Needed for Menu Buttons,\n    // where a click on the parent is significant\n\n    on(el, 'click', function (event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    return el;\n  };\n\n  _proto.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.boundHandleBlur_ = null;\n    this.boundHandleTapClick_ = null;\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Called when a `MenuItem` loses focus.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */\n  ;\n\n  _proto.handleBlur = function handleBlur(event) {\n    var relatedTarget = event.relatedTarget || document.activeElement; // Close menu popup when a user clicks outside the menu\n\n    if (!this.children().some(function (element) {\n      return element.el() === relatedTarget;\n    })) {\n      var btn = this.menuButton_;\n\n      if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {\n        btn.unpressButton();\n      }\n    }\n  }\n  /**\n   * Called when a `MenuItem` gets clicked or tapped.\n   *\n   * @param {EventTarget~Event} event\n   *        The `click` or `tap` event that caused this function to be called.\n   *\n   * @listens click,tap\n   */\n  ;\n\n  _proto.handleTapClick = function handleTapClick(event) {\n    // Unpress the associated MenuButton, and move focus back to it\n    if (this.menuButton_) {\n      this.menuButton_.unpressButton();\n      var childComponents = this.children();\n\n      if (!Array.isArray(childComponents)) {\n        return;\n      }\n\n      var foundComponent = childComponents.filter(function (component) {\n        return component.el() === event.target;\n      })[0];\n\n      if (!foundComponent) {\n        return;\n      } // don't focus menu button if item is a caption settings item\n      // because focus will move elsewhere\n\n\n      if (foundComponent.name() !== 'CaptionSettingsMenuItem') {\n        this.menuButton_.focus();\n      }\n    }\n  }\n  /**\n   * Handle a `keydown` event on this menu. This listener is added in the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        A `keydown` event that happened on the menu.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // Left and Down Arrows\n    if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.stepForward(); // Up and Right Arrows\n    } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.stepBack();\n    }\n  }\n  /**\n   * Move to next (lower) menu item for keyboard users.\n   */\n  ;\n\n  _proto.stepForward = function stepForward() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ + 1;\n    }\n\n    this.focus(stepChild);\n  }\n  /**\n   * Move to previous (higher) menu item for keyboard users.\n   */\n  ;\n\n  _proto.stepBack = function stepBack() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ - 1;\n    }\n\n    this.focus(stepChild);\n  }\n  /**\n   * Set focus on a {@link MenuItem} in the `Menu`.\n   *\n   * @param {Object|string} [item=0]\n   *        Index of child item set focus on.\n   */\n  ;\n\n  _proto.focus = function focus(item) {\n    if (item === void 0) {\n      item = 0;\n    }\n\n    var children = this.children().slice();\n    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);\n\n    if (haveTitle) {\n      children.shift();\n    }\n\n    if (children.length > 0) {\n      if (item < 0) {\n        item = 0;\n      } else if (item >= children.length) {\n        item = children.length - 1;\n      }\n\n      this.focusedChild_ = item;\n      children[item].el_.focus();\n    }\n  };\n\n  return Menu;\n}(Component);\n\nComponent.registerComponent('Menu', Menu);\n/**\n * A `MenuButton` class for any popup {@link Menu}.\n *\n * @extends Component\n */\n\nvar MenuButton = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(MenuButton, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n\n\n  function MenuButton(player, options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Component.call(this, player, options) || this;\n    _this.menuButton_ = new Button(player, options);\n\n    _this.menuButton_.controlText(_this.controlText_);\n\n    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true'); // Add buildCSSClass values to the button, not the wrapper\n\n\n    var buttonClass = Button.prototype.buildCSSClass();\n    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;\n\n    _this.menuButton_.removeClass('vjs-control');\n\n    _this.addChild(_this.menuButton_);\n\n    _this.update();\n\n    _this.enabled_ = true;\n\n    _this.on(_this.menuButton_, 'tap', _this.handleClick);\n\n    _this.on(_this.menuButton_, 'click', _this.handleClick);\n\n    _this.on(_this.menuButton_, 'keydown', _this.handleKeyDown);\n\n    _this.on(_this.menuButton_, 'mouseenter', function () {\n      _this.addClass('vjs-hover');\n\n      _this.menu.show();\n\n      on(document, 'keyup', bind(_assertThisInitialized(_this), _this.handleMenuKeyUp));\n    });\n\n    _this.on('mouseleave', _this.handleMouseLeave);\n\n    _this.on('keydown', _this.handleSubmenuKeyDown);\n\n    return _this;\n  }\n  /**\n   * Update the menu based on the current state of its items.\n   */\n\n\n  var _proto = MenuButton.prototype;\n\n  _proto.update = function update() {\n    var menu = this.createMenu();\n\n    if (this.menu) {\n      this.menu.dispose();\n      this.removeChild(this.menu);\n    }\n\n    this.menu = menu;\n    this.addChild(menu);\n    /**\n     * Track the state of the menu button\n     *\n     * @type {Boolean}\n     * @private\n     */\n\n    this.buttonPressed_ = false;\n    this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n\n    if (this.items && this.items.length <= this.hideThreshold_) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  /**\n   * Create the menu and add all items to it.\n   *\n   * @return {Menu}\n   *         The constructed menu\n   */\n  ;\n\n  _proto.createMenu = function createMenu() {\n    var menu = new Menu(this.player_, {\n      menuButton: this\n    });\n    /**\n     * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n     * it here because every time we run `createMenu` we need to reset the value.\n     *\n     * @protected\n     * @type {Number}\n     */\n\n    this.hideThreshold_ = 0; // Add a title list item to the top\n\n    if (this.options_.title) {\n      var titleEl = createEl('li', {\n        className: 'vjs-menu-title',\n        innerHTML: toTitleCase(this.options_.title),\n        tabIndex: -1\n      });\n      this.hideThreshold_ += 1;\n      var titleComponent = new Component(this.player_, {\n        el: titleEl\n      });\n      menu.addItem(titleComponent);\n    }\n\n    this.items = this.createItems();\n\n    if (this.items) {\n      // Add menu items to the menu\n      for (var i = 0; i < this.items.length; i++) {\n        menu.addItem(this.items[i]);\n      }\n    }\n\n    return menu;\n  }\n  /**\n   * Create the list of menu items. Specific to each subclass.\n   *\n   * @abstract\n   */\n  ;\n\n  _proto.createItems = function createItems() {}\n  /**\n   * Create the `MenuButtons`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildWrapperCSSClass()\n    }, {});\n  }\n  /**\n   * Allow sub components to stack CSS class names for the wrapper element\n   *\n   * @return {string}\n   *         The constructed wrapper DOM `className`\n   */\n  ;\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    var menuButtonClass = 'vjs-menu-button'; // If the inline option is passed, we want to use different styles altogether.\n\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    } // TODO: Fix the CSS so that this isn't necessary\n\n\n    var buttonClass = Button.prototype.buildCSSClass();\n    return \"vjs-menu-button \" + menuButtonClass + \" \" + buttonClass + \" \" + _Component.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  ;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    var menuButtonClass = 'vjs-menu-button'; // If the inline option is passed, we want to use different styles altogether.\n\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    }\n\n    return \"vjs-menu-button \" + menuButtonClass + \" \" + _Component.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Get or set the localized control text that will be used for accessibility.\n   *\n   * > NOTE: This will come from the internal `menuButton_` element.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.menuButton_.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n  ;\n\n  _proto.controlText = function controlText(text, el) {\n    if (el === void 0) {\n      el = this.menuButton_.el();\n    }\n\n    return this.menuButton_.controlText(text, el);\n  }\n  /**\n   * Dispose of the `menu-button` and all child components.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.handleMouseLeave();\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Handle a click on a `MenuButton`.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    if (this.buttonPressed_) {\n      this.unpressButton();\n    } else {\n      this.pressButton();\n    }\n  }\n  /**\n   * Handle `mouseleave` for `MenuButton`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseleave` event that caused this function to be called.\n   *\n   * @listens mouseleave\n   */\n  ;\n\n  _proto.handleMouseLeave = function handleMouseLeave(event) {\n    this.removeClass('vjs-hover');\n    off(document, 'keyup', bind(this, this.handleMenuKeyUp));\n  }\n  /**\n   * Set the focus to the actual button, not to this element\n   */\n  ;\n\n  _proto.focus = function focus() {\n    this.menuButton_.focus();\n  }\n  /**\n   * Remove the focus from the actual button, not this element\n   */\n  ;\n\n  _proto.blur = function blur() {\n    this.menuButton_.blur();\n  }\n  /**\n   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n   * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // Escape or Tab unpress the 'button'\n    if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      } // Don't preventDefault for Tab key - we still want to lose focus\n\n\n      if (!keycode.isEventKey(event, 'Tab')) {\n        event.preventDefault(); // Set focus back to the menu button's button\n\n        this.menuButton_.focus();\n      } // Up Arrow or Down Arrow also 'press' the button to open the menu\n\n    } else if (keycode.isEventKey(event, 'Up') || keycode.isEventKey(event, 'Down')) {\n      if (!this.buttonPressed_) {\n        event.preventDefault();\n        this.pressButton();\n      }\n    }\n  }\n  /**\n   * Handle a `keyup` event on a `MenuButton`. The listener for this is added in\n   * the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        Key press event\n   *\n   * @listens keyup\n   */\n  ;\n\n  _proto.handleMenuKeyUp = function handleMenuKeyUp(event) {\n    // Escape hides popup menu\n    if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n      this.removeClass('vjs-hover');\n    }\n  }\n  /**\n   * This method name now delegates to `handleSubmenuKeyDown`. This means\n   * anyone calling `handleSubmenuKeyPress` will not see their method calls\n   * stop working.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to be called.\n   */\n  ;\n\n  _proto.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {\n    this.handleSubmenuKeyDown(event);\n  }\n  /**\n   * Handle a `keydown` event on a sub-menu. The listener for this is added in\n   * the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        Key press event\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleSubmenuKeyDown = function handleSubmenuKeyDown(event) {\n    // Escape or Tab unpress the 'button'\n    if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      } // Don't preventDefault for Tab key - we still want to lose focus\n\n\n      if (!keycode.isEventKey(event, 'Tab')) {\n        event.preventDefault(); // Set focus back to the menu button's button\n\n        this.menuButton_.focus();\n      }\n    }\n  }\n  /**\n   * Put the current `MenuButton` into a pressed state.\n   */\n  ;\n\n  _proto.pressButton = function pressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = true;\n      this.menu.show();\n      this.menu.lockShowing();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'true'); // set the focus into the submenu, except on iOS where it is resulting in\n      // undesired scrolling behavior when the player is in an iframe\n\n      if (IS_IOS && isInFrame()) {\n        // Return early so that the menu isn't focused\n        return;\n      }\n\n      this.menu.focus();\n    }\n  }\n  /**\n   * Take the current `MenuButton` out of a pressed state.\n   */\n  ;\n\n  _proto.unpressButton = function unpressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = false;\n      this.menu.unlockShowing();\n      this.menu.hide();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n    }\n  }\n  /**\n   * Disable the `MenuButton`. Don't allow it to be clicked.\n   */\n  ;\n\n  _proto.disable = function disable() {\n    this.unpressButton();\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n    this.menuButton_.disable();\n  }\n  /**\n   * Enable the `MenuButton`. Allow it to be clicked.\n   */\n  ;\n\n  _proto.enable = function enable() {\n    this.enabled_ = true;\n    this.removeClass('vjs-disabled');\n    this.menuButton_.enable();\n  };\n\n  return MenuButton;\n}(Component);\n\nComponent.registerComponent('MenuButton', MenuButton);\n/**\n * The base class for buttons that toggle specific  track types (e.g. subtitles).\n *\n * @extends MenuButton\n */\n\nvar TrackButton = /*#__PURE__*/function (_MenuButton) {\n  _inheritsLoose(TrackButton, _MenuButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function TrackButton(player, options) {\n    var _this;\n\n    var tracks = options.tracks;\n    _this = _MenuButton.call(this, player, options) || this;\n\n    if (_this.items.length <= 1) {\n      _this.hide();\n    }\n\n    if (!tracks) {\n      return _assertThisInitialized(_this);\n    }\n\n    var updateHandler = bind(_assertThisInitialized(_this), _this.update);\n    tracks.addEventListener('removetrack', updateHandler);\n    tracks.addEventListener('addtrack', updateHandler);\n\n    _this.player_.on('ready', updateHandler);\n\n    _this.player_.on('dispose', function () {\n      tracks.removeEventListener('removetrack', updateHandler);\n      tracks.removeEventListener('addtrack', updateHandler);\n    });\n\n    return _this;\n  }\n\n  return TrackButton;\n}(MenuButton);\n\nComponent.registerComponent('TrackButton', TrackButton);\n/**\n * @file menu-keys.js\n */\n\n/**\n  * All keys used for operation of a menu (`MenuButton`, `Menu`, and `MenuItem`)\n  * Note that 'Enter' and 'Space' are not included here (otherwise they would\n  * prevent the `MenuButton` and `MenuItem` from being keyboard-clickable)\n  * @typedef MenuKeys\n  * @array\n  */\n\nvar MenuKeys = ['Tab', 'Esc', 'Up', 'Down', 'Right', 'Left'];\n/**\n * The component for a menu item. `<li>`\n *\n * @extends ClickableComponent\n */\n\nvar MenuItem = /*#__PURE__*/function (_ClickableComponent) {\n  _inheritsLoose(MenuItem, _ClickableComponent);\n  /**\n   * Creates an instance of the this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   *\n   */\n\n\n  function MenuItem(player, options) {\n    var _this;\n\n    _this = _ClickableComponent.call(this, player, options) || this;\n    _this.selectable = options.selectable;\n    _this.isSelected_ = options.selected || false;\n    _this.multiSelectable = options.multiSelectable;\n\n    _this.selected(_this.isSelected_);\n\n    if (_this.selectable) {\n      if (_this.multiSelectable) {\n        _this.el_.setAttribute('role', 'menuitemcheckbox');\n      } else {\n        _this.el_.setAttribute('role', 'menuitemradio');\n      }\n    } else {\n      _this.el_.setAttribute('role', 'menuitem');\n    }\n\n    return _this;\n  }\n  /**\n   * Create the `MenuItem's DOM element\n   *\n   * @param {string} [type=li]\n   *        Element's node type, not actually used, always set to `li`.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element\n   *\n   * @param {Object} [attrs={}]\n   *        An object of attributes that should be set on the element\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  var _proto = MenuItem.prototype;\n\n  _proto.createEl = function createEl(type, props, attrs) {\n    // The control is textual, not just an icon\n    this.nonIconControl = true;\n    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({\n      className: 'vjs-menu-item',\n      innerHTML: \"<span class=\\\"vjs-menu-item-text\\\">\" + this.localize(this.options_.label) + \"</span>\",\n      tabIndex: -1\n    }, props), attrs);\n  }\n  /**\n   * Ignore keys which are used by the menu, but pass any other ones up. See\n   * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    if (!MenuKeys.some(function (key) {\n      return keycode.isEventKey(event, key);\n    })) {\n      // Pass keydown handling up for unused keys\n      _ClickableComponent.prototype.handleKeyDown.call(this, event);\n    }\n  }\n  /**\n   * Any click on a `MenuItem` puts it into the selected state.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    this.selected(true);\n  }\n  /**\n   * Set the state for this menu item as selected or not.\n   *\n   * @param {boolean} selected\n   *        if the menu item is selected or not\n   */\n  ;\n\n  _proto.selected = function selected(_selected) {\n    if (this.selectable) {\n      if (_selected) {\n        this.addClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'true'); // aria-checked isn't fully supported by browsers/screen readers,\n        // so indicate selected state to screen reader in the control text.\n\n        this.controlText(', selected');\n        this.isSelected_ = true;\n      } else {\n        this.removeClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'false'); // Indicate un-selected state to screen reader\n\n        this.controlText('');\n        this.isSelected_ = false;\n      }\n    }\n  };\n\n  return MenuItem;\n}(ClickableComponent);\n\nComponent.registerComponent('MenuItem', MenuItem);\n/**\n * The specific menu item type for selecting a language within a text track kind\n *\n * @extends MenuItem\n */\n\nvar TextTrackMenuItem = /*#__PURE__*/function (_MenuItem) {\n  _inheritsLoose(TextTrackMenuItem, _MenuItem);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function TextTrackMenuItem(player, options) {\n    var _this;\n\n    var track = options.track;\n    var tracks = player.textTracks(); // Modify options for parent MenuItem class's init.\n\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.mode === 'showing';\n    _this = _MenuItem.call(this, player, options) || this;\n    _this.track = track; // Determine the relevant kind(s) of tracks for this component and filter\n    // out empty kinds.\n\n    _this.kinds = (options.kinds || [options.kind || _this.track.kind]).filter(Boolean);\n\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);\n    };\n\n    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.handleSelectedLanguageChange.apply(_assertThisInitialized(_this), args);\n    };\n\n    player.on(['loadstart', 'texttrackchange'], changeHandler);\n    tracks.addEventListener('change', changeHandler);\n    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n\n    _this.on('dispose', function () {\n      player.off(['loadstart', 'texttrackchange'], changeHandler);\n      tracks.removeEventListener('change', changeHandler);\n      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n    }); // iOS7 doesn't dispatch change events to TextTrackLists when an\n    // associated track's mode changes. Without something like\n    // Object.observe() (also not present on iOS7), it's not\n    // possible to detect changes to the mode attribute and polyfill\n    // the change event. As a poor substitute, we manually dispatch\n    // change events whenever the controls modify the mode.\n\n\n    if (tracks.onchange === undefined) {\n      var event;\n\n      _this.on(['tap', 'click'], function () {\n        if (typeof window$1.Event !== 'object') {\n          // Android 2.3 throws an Illegal Constructor error for window.Event\n          try {\n            event = new window$1.Event('change');\n          } catch (err) {// continue regardless of error\n          }\n        }\n\n        if (!event) {\n          event = document.createEvent('Event');\n          event.initEvent('change', true, true);\n        }\n\n        tracks.dispatchEvent(event);\n      });\n    } // set the default state based on current tracks\n\n\n    _this.handleTracksChange();\n\n    return _this;\n  }\n  /**\n   * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  var _proto = TextTrackMenuItem.prototype;\n\n  _proto.handleClick = function handleClick(event) {\n    var referenceTrack = this.track;\n    var tracks = this.player_.textTracks();\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    if (!tracks) {\n      return;\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i]; // If the track from the text tracks list is not of the right kind,\n      // skip it. We do not want to affect tracks of incompatible kind(s).\n\n      if (this.kinds.indexOf(track.kind) === -1) {\n        continue;\n      } // If this text track is the component's track and it is not showing,\n      // set it to showing.\n\n\n      if (track === referenceTrack) {\n        if (track.mode !== 'showing') {\n          track.mode = 'showing';\n        } // If this text track is not the component's track and it is not\n        // disabled, set it to disabled.\n\n      } else if (track.mode !== 'disabled') {\n        track.mode = 'disabled';\n      }\n    }\n  }\n  /**\n   * Handle text track list change\n   *\n   * @param {EventTarget~Event} event\n   *        The `change` event that caused this function to be called.\n   *\n   * @listens TextTrackList#change\n   */\n  ;\n\n  _proto.handleTracksChange = function handleTracksChange(event) {\n    var shouldBeSelected = this.track.mode === 'showing'; // Prevent redundant selected() calls because they may cause\n    // screen readers to read the appended control text unnecessarily\n\n    if (shouldBeSelected !== this.isSelected_) {\n      this.selected(shouldBeSelected);\n    }\n  };\n\n  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    if (this.track.mode === 'showing') {\n      var selectedLanguage = this.player_.cache_.selectedLanguage; // Don't replace the kind of track across the same language\n\n      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\n        return;\n      }\n\n      this.player_.cache_.selectedLanguage = {\n        enabled: true,\n        language: this.track.language,\n        kind: this.track.kind\n      };\n    }\n  };\n\n  _proto.dispose = function dispose() {\n    // remove reference to track object on dispose\n    this.track = null;\n\n    _MenuItem.prototype.dispose.call(this);\n  };\n\n  return TextTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\n/**\n * A special menu item for turning of a specific type of text track\n *\n * @extends TextTrackMenuItem\n */\n\nvar OffTextTrackMenuItem = /*#__PURE__*/function (_TextTrackMenuItem) {\n  _inheritsLoose(OffTextTrackMenuItem, _TextTrackMenuItem);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function OffTextTrackMenuItem(player, options) {\n    // Create pseudo track info\n    // Requires options['kind']\n    options.track = {\n      player: player,\n      // it is no longer necessary to store `kind` or `kinds` on the track itself\n      // since they are now stored in the `kinds` property of all instances of\n      // TextTrackMenuItem, but this will remain for backwards compatibility\n      kind: options.kind,\n      kinds: options.kinds,\n      \"default\": false,\n      mode: 'disabled'\n    };\n\n    if (!options.kinds) {\n      options.kinds = [options.kind];\n    }\n\n    if (options.label) {\n      options.track.label = options.label;\n    } else {\n      options.track.label = options.kinds.join(' and ') + ' off';\n    } // MenuItem is selectable\n\n\n    options.selectable = true; // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n\n    options.multiSelectable = false;\n    return _TextTrackMenuItem.call(this, player, options) || this;\n  }\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   */\n\n\n  var _proto = OffTextTrackMenuItem.prototype;\n\n  _proto.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var shouldBeSelected = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\n        shouldBeSelected = false;\n        break;\n      }\n    } // Prevent redundant selected() calls because they may cause\n    // screen readers to read the appended control text unnecessarily\n\n\n    if (shouldBeSelected !== this.isSelected_) {\n      this.selected(shouldBeSelected);\n    }\n  };\n\n  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    var tracks = this.player().textTracks();\n    var allHidden = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\n        allHidden = false;\n        break;\n      }\n    }\n\n    if (allHidden) {\n      this.player_.cache_.selectedLanguage = {\n        enabled: false\n      };\n    }\n  };\n\n  return OffTextTrackMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\n/**\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\n *\n * @extends MenuButton\n */\n\nvar TextTrackButton = /*#__PURE__*/function (_TrackButton) {\n  _inheritsLoose(TextTrackButton, _TrackButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n\n\n  function TextTrackButton(player, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    options.tracks = player.textTracks();\n    return _TrackButton.call(this, player, options) || this;\n  }\n  /**\n   * Create a menu item for each text track\n   *\n   * @param {TextTrackMenuItem[]} [items=[]]\n   *        Existing array of items to use during creation\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items that were created\n   */\n\n\n  var _proto = TextTrackButton.prototype;\n\n  _proto.createItems = function createItems(items, TrackMenuItem) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (TrackMenuItem === void 0) {\n      TrackMenuItem = TextTrackMenuItem;\n    } // Label is an override for the [track] off label\n    // USed to localise captions/subtitles\n\n\n    var label;\n\n    if (this.label_) {\n      label = this.label_ + \" off\";\n    } // Add an OFF menu item to turn all tracks off\n\n\n    items.push(new OffTextTrackMenuItem(this.player_, {\n      kinds: this.kinds_,\n      kind: this.kind_,\n      label: label\n    }));\n    this.hideThreshold_ += 1;\n    var tracks = this.player_.textTracks();\n\n    if (!Array.isArray(this.kinds_)) {\n      this.kinds_ = [this.kind_];\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i]; // only add tracks that are of an appropriate kind and have a label\n\n      if (this.kinds_.indexOf(track.kind) > -1) {\n        var item = new TrackMenuItem(this.player_, {\n          track: track,\n          kinds: this.kinds_,\n          kind: this.kind_,\n          // MenuItem is selectable\n          selectable: true,\n          // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n          multiSelectable: false\n        });\n        item.addClass(\"vjs-\" + track.kind + \"-menu-item\");\n        items.push(item);\n      }\n    }\n\n    return items;\n  };\n\n  return TextTrackButton;\n}(TrackButton);\n\nComponent.registerComponent('TextTrackButton', TextTrackButton);\n/**\n * The chapter track menu item\n *\n * @extends MenuItem\n */\n\nvar ChaptersTrackMenuItem = /*#__PURE__*/function (_MenuItem) {\n  _inheritsLoose(ChaptersTrackMenuItem, _MenuItem);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function ChaptersTrackMenuItem(player, options) {\n    var _this;\n\n    var track = options.track;\n    var cue = options.cue;\n    var currentTime = player.currentTime(); // Modify options for parent MenuItem class's init.\n\n    options.selectable = true;\n    options.multiSelectable = false;\n    options.label = cue.text;\n    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\n    _this = _MenuItem.call(this, player, options) || this;\n    _this.track = track;\n    _this.cue = cue;\n    track.addEventListener('cuechange', bind(_assertThisInitialized(_this), _this.update));\n    return _this;\n  }\n  /**\n   * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  var _proto = ChaptersTrackMenuItem.prototype;\n\n  _proto.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n\n    this.player_.currentTime(this.cue.startTime);\n    this.update(this.cue.startTime);\n  }\n  /**\n   * Update chapter menu item\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `cuechange` event that caused this function to run.\n   *\n   * @listens TextTrack#cuechange\n   */\n  ;\n\n  _proto.update = function update(event) {\n    var cue = this.cue;\n    var currentTime = this.player_.currentTime(); // vjs.log(currentTime, cue.startTime);\n\n    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);\n  };\n\n  return ChaptersTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\n/**\n * The button component for toggling and selecting chapters\n * Chapters act much differently than other text tracks\n * Cues are navigation vs. other tracks of alternative languages\n *\n * @extends TextTrackButton\n */\n\nvar ChaptersButton = /*#__PURE__*/function (_TextTrackButton) {\n  _inheritsLoose(ChaptersButton, _TextTrackButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this function is ready.\n   */\n\n\n  function ChaptersButton(player, options, ready) {\n    return _TextTrackButton.call(this, player, options, ready) || this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = ChaptersButton.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-chapters-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return \"vjs-chapters-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  }\n  /**\n   * Update the menu based on the current state of its items.\n   *\n   * @param {EventTarget~Event} [event]\n   *        An event that triggered this function to run.\n   *\n   * @listens TextTrackList#addtrack\n   * @listens TextTrackList#removetrack\n   * @listens TextTrackList#change\n   */\n  ;\n\n  _proto.update = function update(event) {\n    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {\n      this.setTrack(this.findChaptersTrack());\n    }\n\n    _TextTrackButton.prototype.update.call(this);\n  }\n  /**\n   * Set the currently selected track for the chapters button.\n   *\n   * @param {TextTrack} track\n   *        The new track to select. Nothing will change if this is the currently selected\n   *        track.\n   */\n  ;\n\n  _proto.setTrack = function setTrack(track) {\n    if (this.track_ === track) {\n      return;\n    }\n\n    if (!this.updateHandler_) {\n      this.updateHandler_ = this.update.bind(this);\n    } // here this.track_ refers to the old track instance\n\n\n    if (this.track_) {\n      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (remoteTextTrackEl) {\n        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\n      }\n\n      this.track_ = null;\n    }\n\n    this.track_ = track; // here this.track_ refers to the new track instance\n\n    if (this.track_) {\n      this.track_.mode = 'hidden';\n\n      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (_remoteTextTrackEl) {\n        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);\n      }\n    }\n  }\n  /**\n   * Find the track object that is currently in use by this ChaptersButton\n   *\n   * @return {TextTrack|undefined}\n   *         The current track or undefined if none was found.\n   */\n  ;\n\n  _proto.findChaptersTrack = function findChaptersTrack() {\n    var tracks = this.player_.textTracks() || [];\n\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      // We will always choose the last track as our chaptersTrack\n      var track = tracks[i];\n\n      if (track.kind === this.kind_) {\n        return track;\n      }\n    }\n  }\n  /**\n   * Get the caption for the ChaptersButton based on the track label. This will also\n   * use the current tracks localized kind as a fallback if a label does not exist.\n   *\n   * @return {string}\n   *         The tracks current label or the localized track kind.\n   */\n  ;\n\n  _proto.getMenuCaption = function getMenuCaption() {\n    if (this.track_ && this.track_.label) {\n      return this.track_.label;\n    }\n\n    return this.localize(toTitleCase(this.kind_));\n  }\n  /**\n   * Create menu from chapter track\n   *\n   * @return {Menu}\n   *         New menu for the chapter buttons\n   */\n  ;\n\n  _proto.createMenu = function createMenu() {\n    this.options_.title = this.getMenuCaption();\n    return _TextTrackButton.prototype.createMenu.call(this);\n  }\n  /**\n   * Create a menu item for each text track\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items\n   */\n  ;\n\n  _proto.createItems = function createItems() {\n    var items = [];\n\n    if (!this.track_) {\n      return items;\n    }\n\n    var cues = this.track_.cues;\n\n    if (!cues) {\n      return items;\n    }\n\n    for (var i = 0, l = cues.length; i < l; i++) {\n      var cue = cues[i];\n      var mi = new ChaptersTrackMenuItem(this.player_, {\n        track: this.track_,\n        cue: cue\n      });\n      items.push(mi);\n    }\n\n    return items;\n  };\n\n  return ChaptersButton;\n}(TextTrackButton);\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nChaptersButton.prototype.kind_ = 'chapters';\n/**\n * The text that should display over the `ChaptersButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\nChaptersButton.prototype.controlText_ = 'Chapters';\nComponent.registerComponent('ChaptersButton', ChaptersButton);\n/**\n * The button component for toggling and selecting descriptions\n *\n * @extends TextTrackButton\n */\n\nvar DescriptionsButton = /*#__PURE__*/function (_TextTrackButton) {\n  _inheritsLoose(DescriptionsButton, _TextTrackButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n\n\n  function DescriptionsButton(player, options, ready) {\n    var _this;\n\n    _this = _TextTrackButton.call(this, player, options, ready) || this;\n    var tracks = player.textTracks();\n    var changeHandler = bind(_assertThisInitialized(_this), _this.handleTracksChange);\n    tracks.addEventListener('change', changeHandler);\n\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n\n    return _this;\n  }\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   *\n   * @listens TextTrackList#change\n   */\n\n\n  var _proto = DescriptionsButton.prototype;\n\n  _proto.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var disabled = false; // Check whether a track of a different kind is showing\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (track.kind !== this.kind_ && track.mode === 'showing') {\n        disabled = true;\n        break;\n      }\n    } // If another track is showing, disable this menu button\n\n\n    if (disabled) {\n      this.disable();\n    } else {\n      this.enable();\n    }\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  ;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-descriptions-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return \"vjs-descriptions-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return DescriptionsButton;\n}(TextTrackButton);\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nDescriptionsButton.prototype.kind_ = 'descriptions';\n/**\n * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\nDescriptionsButton.prototype.controlText_ = 'Descriptions';\nComponent.registerComponent('DescriptionsButton', DescriptionsButton);\n/**\n * The button component for toggling and selecting subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubtitlesButton = /*#__PURE__*/function (_TextTrackButton) {\n  _inheritsLoose(SubtitlesButton, _TextTrackButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n\n\n  function SubtitlesButton(player, options, ready) {\n    return _TextTrackButton.call(this, player, options, ready) || this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = SubtitlesButton.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-subtitles-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return \"vjs-subtitles-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return SubtitlesButton;\n}(TextTrackButton);\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nSubtitlesButton.prototype.kind_ = 'subtitles';\n/**\n * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\nSubtitlesButton.prototype.controlText_ = 'Subtitles';\nComponent.registerComponent('SubtitlesButton', SubtitlesButton);\n/**\n * The menu item for caption track settings menu\n *\n * @extends TextTrackMenuItem\n */\n\nvar CaptionSettingsMenuItem = /*#__PURE__*/function (_TextTrackMenuItem) {\n  _inheritsLoose(CaptionSettingsMenuItem, _TextTrackMenuItem);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function CaptionSettingsMenuItem(player, options) {\n    var _this;\n\n    options.track = {\n      player: player,\n      kind: options.kind,\n      label: options.kind + ' settings',\n      selectable: false,\n      \"default\": false,\n      mode: 'disabled'\n    }; // CaptionSettingsMenuItem has no concept of 'selected'\n\n    options.selectable = false;\n    options.name = 'CaptionSettingsMenuItem';\n    _this = _TextTrackMenuItem.call(this, player, options) || this;\n\n    _this.addClass('vjs-texttrack-settings');\n\n    _this.controlText(', opens ' + options.kind + ' settings dialog');\n\n    return _this;\n  }\n  /**\n   * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  var _proto = CaptionSettingsMenuItem.prototype;\n\n  _proto.handleClick = function handleClick(event) {\n    this.player().getChild('textTrackSettings').open();\n  };\n\n  return CaptionSettingsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\n/**\n * The button component for toggling and selecting captions\n *\n * @extends TextTrackButton\n */\n\nvar CaptionsButton = /*#__PURE__*/function (_TextTrackButton) {\n  _inheritsLoose(CaptionsButton, _TextTrackButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n\n\n  function CaptionsButton(player, options, ready) {\n    return _TextTrackButton.call(this, player, options, ready) || this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = CaptionsButton.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-captions-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return \"vjs-captions-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  }\n  /**\n   * Create caption menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n  ;\n\n  _proto.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n      items.push(new CaptionSettingsMenuItem(this.player_, {\n        kind: this.kind_\n      }));\n      this.hideThreshold_ += 1;\n    }\n\n    return _TextTrackButton.prototype.createItems.call(this, items);\n  };\n\n  return CaptionsButton;\n}(TextTrackButton);\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nCaptionsButton.prototype.kind_ = 'captions';\n/**\n * The text that should display over the `CaptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\nCaptionsButton.prototype.controlText_ = 'Captions';\nComponent.registerComponent('CaptionsButton', CaptionsButton);\n/**\n * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n * in the SubsCapsMenu.\n *\n * @extends TextTrackMenuItem\n */\n\nvar SubsCapsMenuItem = /*#__PURE__*/function (_TextTrackMenuItem) {\n  _inheritsLoose(SubsCapsMenuItem, _TextTrackMenuItem);\n\n  function SubsCapsMenuItem() {\n    return _TextTrackMenuItem.apply(this, arguments) || this;\n  }\n\n  var _proto = SubsCapsMenuItem.prototype;\n\n  _proto.createEl = function createEl(type, props, attrs) {\n    var innerHTML = \"<span class=\\\"vjs-menu-item-text\\\">\" + this.localize(this.options_.label);\n\n    if (this.options_.track.kind === 'captions') {\n      innerHTML += \"\\n        <span aria-hidden=\\\"true\\\" class=\\\"vjs-icon-placeholder\\\"></span>\\n        <span class=\\\"vjs-control-text\\\"> \" + this.localize('Captions') + \"</span>\\n      \";\n    }\n\n    innerHTML += '</span>';\n\n    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({\n      innerHTML: innerHTML\n    }, props), attrs);\n\n    return el;\n  };\n\n  return SubsCapsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\n/**\n * The button component for toggling and selecting captions and/or subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubsCapsButton = /*#__PURE__*/function (_TextTrackButton) {\n  _inheritsLoose(SubsCapsButton, _TextTrackButton);\n\n  function SubsCapsButton(player, options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _TextTrackButton.call(this, player, options) || this; // Although North America uses \"captions\" in most cases for\n    // \"captions and subtitles\" other locales use \"subtitles\"\n\n    _this.label_ = 'subtitles';\n\n    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {\n      _this.label_ = 'captions';\n    }\n\n    _this.menuButton_.controlText(toTitleCase(_this.label_));\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = SubsCapsButton.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-subs-caps-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return \"vjs-subs-caps-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  }\n  /**\n   * Create caption/subtitles menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n  ;\n\n  _proto.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n      items.push(new CaptionSettingsMenuItem(this.player_, {\n        kind: this.label_\n      }));\n      this.hideThreshold_ += 1;\n    }\n\n    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);\n    return items;\n  };\n\n  return SubsCapsButton;\n}(TextTrackButton);\n/**\n * `kind`s of TextTrack to look for to associate it with this menu.\n *\n * @type {array}\n * @private\n */\n\n\nSubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\n/**\n * The text that should display over the `SubsCapsButton`s controls.\n *\n *\n * @type {string}\n * @private\n */\n\nSubsCapsButton.prototype.controlText_ = 'Subtitles';\nComponent.registerComponent('SubsCapsButton', SubsCapsButton);\n/**\n * An {@link AudioTrack} {@link MenuItem}\n *\n * @extends MenuItem\n */\n\nvar AudioTrackMenuItem = /*#__PURE__*/function (_MenuItem) {\n  _inheritsLoose(AudioTrackMenuItem, _MenuItem);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function AudioTrackMenuItem(player, options) {\n    var _this;\n\n    var track = options.track;\n    var tracks = player.audioTracks(); // Modify options for parent MenuItem class's init.\n\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.enabled;\n    _this = _MenuItem.call(this, player, options) || this;\n    _this.track = track;\n\n    _this.addClass(\"vjs-\" + track.kind + \"-menu-item\");\n\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);\n    };\n\n    tracks.addEventListener('change', changeHandler);\n\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n\n    return _this;\n  }\n\n  var _proto = AudioTrackMenuItem.prototype;\n\n  _proto.createEl = function createEl(type, props, attrs) {\n    var innerHTML = \"<span class=\\\"vjs-menu-item-text\\\">\" + this.localize(this.options_.label);\n\n    if (this.options_.track.kind === 'main-desc') {\n      innerHTML += \"\\n        <span aria-hidden=\\\"true\\\" class=\\\"vjs-icon-placeholder\\\"></span>\\n        <span class=\\\"vjs-control-text\\\"> \" + this.localize('Descriptions') + \"</span>\\n      \";\n    }\n\n    innerHTML += '</span>';\n\n    var el = _MenuItem.prototype.createEl.call(this, type, assign({\n      innerHTML: innerHTML\n    }, props), attrs);\n\n    return el;\n  }\n  /**\n   * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    var tracks = this.player_.audioTracks();\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n      track.enabled = track === this.track;\n    }\n  }\n  /**\n   * Handle any {@link AudioTrack} change.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link AudioTrackList#change} event that caused this to run.\n   *\n   * @listens AudioTrackList#change\n   */\n  ;\n\n  _proto.handleTracksChange = function handleTracksChange(event) {\n    this.selected(this.track.enabled);\n  };\n\n  return AudioTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\n/**\n * The base class for buttons that toggle specific {@link AudioTrack} types.\n *\n * @extends TrackButton\n */\n\nvar AudioTrackButton = /*#__PURE__*/function (_TrackButton) {\n  _inheritsLoose(AudioTrackButton, _TrackButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n\n\n  function AudioTrackButton(player, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    options.tracks = player.audioTracks();\n    return _TrackButton.call(this, player, options) || this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  var _proto = AudioTrackButton.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-audio-button \" + _TrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return \"vjs-audio-button \" + _TrackButton.prototype.buildWrapperCSSClass.call(this);\n  }\n  /**\n   * Create a menu item for each audio track\n   *\n   * @param {AudioTrackMenuItem[]} [items=[]]\n   *        An array of existing menu items to use.\n   *\n   * @return {AudioTrackMenuItem[]}\n   *         An array of menu items\n   */\n  ;\n\n  _proto.createItems = function createItems(items) {\n    if (items === void 0) {\n      items = [];\n    } // if there's only one audio track, there no point in showing it\n\n\n    this.hideThreshold_ = 1;\n    var tracks = this.player_.audioTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n      items.push(new AudioTrackMenuItem(this.player_, {\n        track: track,\n        // MenuItem is selectable\n        selectable: true,\n        // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n        multiSelectable: false\n      }));\n    }\n\n    return items;\n  };\n\n  return AudioTrackButton;\n}(TrackButton);\n/**\n * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nAudioTrackButton.prototype.controlText_ = 'Audio Track';\nComponent.registerComponent('AudioTrackButton', AudioTrackButton);\n/**\n * The specific menu item type for selecting a playback rate.\n *\n * @extends MenuItem\n */\n\nvar PlaybackRateMenuItem = /*#__PURE__*/function (_MenuItem) {\n  _inheritsLoose(PlaybackRateMenuItem, _MenuItem);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function PlaybackRateMenuItem(player, options) {\n    var _this;\n\n    var label = options.rate;\n    var rate = parseFloat(label, 10); // Modify options for parent MenuItem class's init.\n\n    options.label = label;\n    options.selected = rate === 1;\n    options.selectable = true;\n    options.multiSelectable = false;\n    _this = _MenuItem.call(this, player, options) || this;\n    _this.label = label;\n    _this.rate = rate;\n\n    _this.on(player, 'ratechange', _this.update);\n\n    return _this;\n  }\n  /**\n   * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  var _proto = PlaybackRateMenuItem.prototype;\n\n  _proto.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n\n    this.player().playbackRate(this.rate);\n  }\n  /**\n   * Update the PlaybackRateMenuItem when the playbackrate changes.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ratechange` event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n  ;\n\n  _proto.update = function update(event) {\n    this.selected(this.player().playbackRate() === this.rate);\n  };\n\n  return PlaybackRateMenuItem;\n}(MenuItem);\n/**\n * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuItem.prototype.contentElType = 'button';\nComponent.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\n/**\n * The component for controlling the playback rate.\n *\n * @extends MenuButton\n */\n\nvar PlaybackRateMenuButton = /*#__PURE__*/function (_MenuButton) {\n  _inheritsLoose(PlaybackRateMenuButton, _MenuButton);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n\n\n  function PlaybackRateMenuButton(player, options) {\n    var _this;\n\n    _this = _MenuButton.call(this, player, options) || this;\n\n    _this.updateVisibility();\n\n    _this.updateLabel();\n\n    _this.on(player, 'loadstart', _this.updateVisibility);\n\n    _this.on(player, 'ratechange', _this.updateLabel);\n\n    return _this;\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  var _proto = PlaybackRateMenuButton.prototype;\n\n  _proto.createEl = function createEl$1() {\n    var el = _MenuButton.prototype.createEl.call(this);\n\n    this.labelEl_ = createEl('div', {\n      className: 'vjs-playback-rate-value',\n      innerHTML: '1x'\n    });\n    el.appendChild(this.labelEl_);\n    return el;\n  };\n\n  _proto.dispose = function dispose() {\n    this.labelEl_ = null;\n\n    _MenuButton.prototype.dispose.call(this);\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  ;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-playback-rate \" + _MenuButton.prototype.buildCSSClass.call(this);\n  };\n\n  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return \"vjs-playback-rate \" + _MenuButton.prototype.buildWrapperCSSClass.call(this);\n  }\n  /**\n   * Create the playback rate menu\n   *\n   * @return {Menu}\n   *         Menu object populated with {@link PlaybackRateMenuItem}s\n   */\n  ;\n\n  _proto.createMenu = function createMenu() {\n    var menu = new Menu(this.player());\n    var rates = this.playbackRates();\n\n    if (rates) {\n      for (var i = rates.length - 1; i >= 0; i--) {\n        menu.addChild(new PlaybackRateMenuItem(this.player(), {\n          rate: rates[i] + 'x'\n        }));\n      }\n    }\n\n    return menu;\n  }\n  /**\n   * Updates ARIA accessibility attributes\n   */\n  ;\n\n  _proto.updateARIAAttributes = function updateARIAAttributes() {\n    // Current playback rate\n    this.el().setAttribute('aria-valuenow', this.player().playbackRate());\n  }\n  /**\n   * This gets called when an `PlaybackRateMenuButton` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n  ;\n\n  _proto.handleClick = function handleClick(event) {\n    // select next rate option\n    var currentRate = this.player().playbackRate();\n    var rates = this.playbackRates(); // this will select first one if the last one currently selected\n\n    var newRate = rates[0];\n\n    for (var i = 0; i < rates.length; i++) {\n      if (rates[i] > currentRate) {\n        newRate = rates[i];\n        break;\n      }\n    }\n\n    this.player().playbackRate(newRate);\n  }\n  /**\n   * Get possible playback rates\n   *\n   * @return {Array}\n   *         All possible playback rates\n   */\n  ;\n\n  _proto.playbackRates = function playbackRates() {\n    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;\n  }\n  /**\n   * Get whether playback rates is supported by the tech\n   * and an array of playback rates exists\n   *\n   * @return {boolean}\n   *         Whether changing playback rate is supported\n   */\n  ;\n\n  _proto.playbackRateSupported = function playbackRateSupported() {\n    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\n  }\n  /**\n   * Hide playback rate controls when they're no playback rate options to select\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#loadstart\n   */\n  ;\n\n  _proto.updateVisibility = function updateVisibility(event) {\n    if (this.playbackRateSupported()) {\n      this.removeClass('vjs-hidden');\n    } else {\n      this.addClass('vjs-hidden');\n    }\n  }\n  /**\n   * Update button label when rate changed\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n  ;\n\n  _proto.updateLabel = function updateLabel(event) {\n    if (this.playbackRateSupported()) {\n      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';\n    }\n  };\n\n  return PlaybackRateMenuButton;\n}(MenuButton);\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\nComponent.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\n/**\n * Just an empty spacer element that can be used as an append point for plugins, etc.\n * Also can be used to create space between elements when necessary.\n *\n * @extends Component\n */\n\nvar Spacer = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Spacer, _Component);\n\n  function Spacer() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Spacer.prototype;\n  /**\n  * Builds the default DOM `className`.\n  *\n  * @return {string}\n  *         The DOM `className` for this object.\n  */\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-spacer \" + _Component.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass()\n    });\n  };\n\n  return Spacer;\n}(Component);\n\nComponent.registerComponent('Spacer', Spacer);\n/**\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n *\n * @extends Spacer\n */\n\nvar CustomControlSpacer = /*#__PURE__*/function (_Spacer) {\n  _inheritsLoose(CustomControlSpacer, _Spacer);\n\n  function CustomControlSpacer() {\n    return _Spacer.apply(this, arguments) || this;\n  }\n\n  var _proto = CustomControlSpacer.prototype;\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-custom-control-spacer \" + _Spacer.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    var el = _Spacer.prototype.createEl.call(this, {\n      className: this.buildCSSClass()\n    }); // No-flex/table-cell mode requires there be some content\n    // in the cell to fill the remaining space of the table.\n\n\n    el.innerHTML = \"\\xA0\";\n    return el;\n  };\n\n  return CustomControlSpacer;\n}(Spacer);\n\nComponent.registerComponent('CustomControlSpacer', CustomControlSpacer);\n/**\n * Container of main controls.\n *\n * @extends Component\n */\n\nvar ControlBar = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ControlBar, _Component);\n\n  function ControlBar() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = ControlBar.prototype;\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-control-bar',\n      dir: 'ltr'\n    });\n  };\n\n  return ControlBar;\n}(Component);\n/**\n * Default options for `ControlBar`\n *\n * @type {Object}\n * @private\n */\n\n\nControlBar.prototype.options_ = {\n  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'seekToLive', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\n};\n\nif ('exitPictureInPicture' in document) {\n  ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, 'pictureInPictureToggle');\n}\n\nComponent.registerComponent('ControlBar', ControlBar);\n/**\n * A display that indicates an error has occurred. This means that the video\n * is unplayable.\n *\n * @extends ModalDialog\n */\n\nvar ErrorDisplay = /*#__PURE__*/function (_ModalDialog) {\n  _inheritsLoose(ErrorDisplay, _ModalDialog);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n\n\n  function ErrorDisplay(player, options) {\n    var _this;\n\n    _this = _ModalDialog.call(this, player, options) || this;\n\n    _this.on(player, 'error', _this.open);\n\n    return _this;\n  }\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  var _proto = ErrorDisplay.prototype;\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return \"vjs-error-display \" + _ModalDialog.prototype.buildCSSClass.call(this);\n  }\n  /**\n   * Gets the localized error message based on the `Player`s error.\n   *\n   * @return {string}\n   *         The `Player`s error message localized or an empty string.\n   */\n  ;\n\n  _proto.content = function content() {\n    var error = this.player().error();\n    return error ? this.localize(error.message) : '';\n  };\n\n  return ErrorDisplay;\n}(ModalDialog);\n/**\n * The default options for an `ErrorDisplay`.\n *\n * @private\n */\n\n\nErrorDisplay.prototype.options_ = _extends({}, ModalDialog.prototype.options_, {\n  pauseOnOpen: false,\n  fillAlways: true,\n  temporary: false,\n  uncloseable: true\n});\nComponent.registerComponent('ErrorDisplay', ErrorDisplay);\nvar LOCAL_STORAGE_KEY = 'vjs-text-track-settings';\nvar COLOR_BLACK = ['#000', 'Black'];\nvar COLOR_BLUE = ['#00F', 'Blue'];\nvar COLOR_CYAN = ['#0FF', 'Cyan'];\nvar COLOR_GREEN = ['#0F0', 'Green'];\nvar COLOR_MAGENTA = ['#F0F', 'Magenta'];\nvar COLOR_RED = ['#F00', 'Red'];\nvar COLOR_WHITE = ['#FFF', 'White'];\nvar COLOR_YELLOW = ['#FF0', 'Yellow'];\nvar OPACITY_OPAQUE = ['1', 'Opaque'];\nvar OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\nvar OPACITY_TRANS = ['0', 'Transparent']; // Configuration for the various <select> elements in the DOM of this component.\n//\n// Possible keys include:\n//\n// `default`:\n//   The default option index. Only needs to be provided if not zero.\n// `parser`:\n//   A function which is used to parse the value from the selected option in\n//   a customized way.\n// `selector`:\n//   The selector used to find the associated <select> element.\n\nvar selectConfigs = {\n  backgroundColor: {\n    selector: '.vjs-bg-color > select',\n    id: 'captions-background-color-%s',\n    label: 'Color',\n    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n  backgroundOpacity: {\n    selector: '.vjs-bg-opacity > select',\n    id: 'captions-background-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\n  },\n  color: {\n    selector: '.vjs-fg-color > select',\n    id: 'captions-foreground-color-%s',\n    label: 'Color',\n    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n  edgeStyle: {\n    selector: '.vjs-edge-style > select',\n    id: '%s',\n    label: 'Text Edge Style',\n    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]\n  },\n  fontFamily: {\n    selector: '.vjs-font-family > select',\n    id: 'captions-font-family-%s',\n    label: 'Font Family',\n    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\n  },\n  fontPercent: {\n    selector: '.vjs-font-percent > select',\n    id: 'captions-font-size-%s',\n    label: 'Font Size',\n    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\n    \"default\": 2,\n    parser: function parser(v) {\n      return v === '1.00' ? null : Number(v);\n    }\n  },\n  textOpacity: {\n    selector: '.vjs-text-opacity > select',\n    id: 'captions-foreground-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI]\n  },\n  // Options for this object are defined below.\n  windowColor: {\n    selector: '.vjs-window-color > select',\n    id: 'captions-window-color-%s',\n    label: 'Color'\n  },\n  // Options for this object are defined below.\n  windowOpacity: {\n    selector: '.vjs-window-opacity > select',\n    id: 'captions-window-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\n  }\n};\nselectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\n/**\n * Get the actual value of an option.\n *\n * @param  {string} value\n *         The value to get\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\n\nfunction parseOptionValue(value, parser) {\n  if (parser) {\n    value = parser(value);\n  }\n\n  if (value && value !== 'none') {\n    return value;\n  }\n}\n/**\n * Gets the value of the selected <option> element within a <select> element.\n *\n * @param  {Element} el\n *         the element to look in\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\n\n\nfunction getSelectedOptionValue(el, parser) {\n  var value = el.options[el.options.selectedIndex].value;\n  return parseOptionValue(value, parser);\n}\n/**\n * Sets the selected <option> element within a <select> element based on a\n * given value.\n *\n * @param {Element} el\n *        The element to look in.\n *\n * @param {string} value\n *        the property to look on.\n *\n * @param {Function} [parser]\n *        Optional function to adjust the value before comparing.\n *\n * @private\n */\n\n\nfunction setSelectedOption(el, value, parser) {\n  if (!value) {\n    return;\n  }\n\n  for (var i = 0; i < el.options.length; i++) {\n    if (parseOptionValue(el.options[i].value, parser) === value) {\n      el.selectedIndex = i;\n      break;\n    }\n  }\n}\n/**\n * Manipulate Text Tracks settings.\n *\n * @extends ModalDialog\n */\n\n\nvar TextTrackSettings = /*#__PURE__*/function (_ModalDialog) {\n  _inheritsLoose(TextTrackSettings, _ModalDialog);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *         The key/value store of player options.\n   */\n\n\n  function TextTrackSettings(player, options) {\n    var _this;\n\n    options.temporary = false;\n    _this = _ModalDialog.call(this, player, options) || this;\n    _this.updateDisplay = bind(_assertThisInitialized(_this), _this.updateDisplay); // fill the modal and pretend we have opened it\n\n    _this.fill();\n\n    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;\n    _this.endDialog = createEl('p', {\n      className: 'vjs-control-text',\n      textContent: _this.localize('End of dialog window.')\n    });\n\n    _this.el().appendChild(_this.endDialog);\n\n    _this.setDefaults(); // Grab `persistTextTrackSettings` from the player options if not passed in child options\n\n\n    if (options.persistTextTrackSettings === undefined) {\n      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;\n    }\n\n    _this.on(_this.$('.vjs-done-button'), 'click', function () {\n      _this.saveSettings();\n\n      _this.close();\n    });\n\n    _this.on(_this.$('.vjs-default-button'), 'click', function () {\n      _this.setDefaults();\n\n      _this.updateDisplay();\n    });\n\n    each(selectConfigs, function (config) {\n      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);\n    });\n\n    if (_this.options_.persistTextTrackSettings) {\n      _this.restoreSettings();\n    }\n\n    return _this;\n  }\n\n  var _proto = TextTrackSettings.prototype;\n\n  _proto.dispose = function dispose() {\n    this.endDialog = null;\n\n    _ModalDialog.prototype.dispose.call(this);\n  }\n  /**\n   * Create a <select> element with configured options.\n   *\n   * @param {string} key\n   *        Configuration key to use during creation.\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n  ;\n\n  _proto.createElSelect_ = function createElSelect_(key, legendId, type) {\n    var _this2 = this;\n\n    if (legendId === void 0) {\n      legendId = '';\n    }\n\n    if (type === void 0) {\n      type = 'label';\n    }\n\n    var config = selectConfigs[key];\n    var id = config.id.replace('%s', this.id_);\n    var selectLabelledbyIds = [legendId, id].join(' ').trim();\n    return [\"<\" + type + \" id=\\\"\" + id + \"\\\" class=\\\"\" + (type === 'label' ? 'vjs-label' : '') + \"\\\">\", this.localize(config.label), \"</\" + type + \">\", \"<select aria-labelledby=\\\"\" + selectLabelledbyIds + \"\\\">\"].concat(config.options.map(function (o) {\n      var optionId = id + '-' + o[1].replace(/\\W+/g, '');\n      return [\"<option id=\\\"\" + optionId + \"\\\" value=\\\"\" + o[0] + \"\\\" \", \"aria-labelledby=\\\"\" + selectLabelledbyIds + \" \" + optionId + \"\\\">\", _this2.localize(o[1]), '</option>'].join('');\n    })).concat('</select>').join('');\n  }\n  /**\n   * Create foreground color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n  ;\n\n  _proto.createElFgColor_ = function createElFgColor_() {\n    var legendId = \"captions-text-legend-\" + this.id_;\n    return ['<fieldset class=\"vjs-fg-color vjs-track-setting\">', \"<legend id=\\\"\" + legendId + \"\\\">\", this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\n  }\n  /**\n   * Create background color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n  ;\n\n  _proto.createElBgColor_ = function createElBgColor_() {\n    var legendId = \"captions-background-\" + this.id_;\n    return ['<fieldset class=\"vjs-bg-color vjs-track-setting\">', \"<legend id=\\\"\" + legendId + \"\\\">\", this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\n  }\n  /**\n   * Create window color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n  ;\n\n  _proto.createElWinColor_ = function createElWinColor_() {\n    var legendId = \"captions-window-\" + this.id_;\n    return ['<fieldset class=\"vjs-window-color vjs-track-setting\">', \"<legend id=\\\"\" + legendId + \"\\\">\", this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\n  }\n  /**\n   * Create color elements for the component\n   *\n   * @return {Element}\n   *         The element that was created\n   *\n   * @private\n   */\n  ;\n\n  _proto.createElColors_ = function createElColors_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-colors',\n      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\n    });\n  }\n  /**\n   * Create font elements for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n  ;\n\n  _proto.createElFont_ = function createElFont_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-font',\n      innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\n    });\n  }\n  /**\n   * Create controls for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n  ;\n\n  _proto.createElControls_ = function createElControls_() {\n    var defaultsDescription = this.localize('restore all settings to the default values');\n    return createEl('div', {\n      className: 'vjs-track-settings-controls',\n      innerHTML: [\"<button type=\\\"button\\\" class=\\\"vjs-default-button\\\" title=\\\"\" + defaultsDescription + \"\\\">\", this.localize('Reset'), \"<span class=\\\"vjs-control-text\\\"> \" + defaultsDescription + \"</span>\", '</button>', \"<button type=\\\"button\\\" class=\\\"vjs-done-button\\\">\" + this.localize('Done') + \"</button>\"].join('')\n    });\n  };\n\n  _proto.content = function content() {\n    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\n  };\n\n  _proto.label = function label() {\n    return this.localize('Caption Settings Dialog');\n  };\n\n  _proto.description = function description() {\n    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\n  };\n\n  _proto.buildCSSClass = function buildCSSClass() {\n    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';\n  }\n  /**\n   * Gets an object of text track settings (or null).\n   *\n   * @return {Object}\n   *         An object with config values parsed from the DOM or localStorage.\n   */\n  ;\n\n  _proto.getValues = function getValues() {\n    var _this3 = this;\n\n    return reduce(selectConfigs, function (accum, config, key) {\n      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);\n\n      if (value !== undefined) {\n        accum[key] = value;\n      }\n\n      return accum;\n    }, {});\n  }\n  /**\n   * Sets text track settings from an object of values.\n   *\n   * @param {Object} values\n   *        An object with config values parsed from the DOM or localStorage.\n   */\n  ;\n\n  _proto.setValues = function setValues(values) {\n    var _this4 = this;\n\n    each(selectConfigs, function (config, key) {\n      setSelectedOption(_this4.$(config.selector), values[key], config.parser);\n    });\n  }\n  /**\n   * Sets all `<select>` elements to their default values.\n   */\n  ;\n\n  _proto.setDefaults = function setDefaults() {\n    var _this5 = this;\n\n    each(selectConfigs, function (config) {\n      var index = config.hasOwnProperty('default') ? config[\"default\"] : 0;\n      _this5.$(config.selector).selectedIndex = index;\n    });\n  }\n  /**\n   * Restore texttrack settings from localStorage\n   */\n  ;\n\n  _proto.restoreSettings = function restoreSettings() {\n    var values;\n\n    try {\n      values = JSON.parse(window$1.localStorage.getItem(LOCAL_STORAGE_KEY));\n    } catch (err) {\n      log.warn(err);\n    }\n\n    if (values) {\n      this.setValues(values);\n    }\n  }\n  /**\n   * Save text track settings to localStorage\n   */\n  ;\n\n  _proto.saveSettings = function saveSettings() {\n    if (!this.options_.persistTextTrackSettings) {\n      return;\n    }\n\n    var values = this.getValues();\n\n    try {\n      if (Object.keys(values).length) {\n        window$1.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));\n      } else {\n        window$1.localStorage.removeItem(LOCAL_STORAGE_KEY);\n      }\n    } catch (err) {\n      log.warn(err);\n    }\n  }\n  /**\n   * Update display of text track settings\n   */\n  ;\n\n  _proto.updateDisplay = function updateDisplay() {\n    var ttDisplay = this.player_.getChild('textTrackDisplay');\n\n    if (ttDisplay) {\n      ttDisplay.updateDisplay();\n    }\n  }\n  /**\n   * conditionally blur the element and refocus the captions button\n   *\n   * @private\n   */\n  ;\n\n  _proto.conditionalBlur_ = function conditionalBlur_() {\n    this.previouslyActiveEl_ = null;\n    var cb = this.player_.controlBar;\n    var subsCapsBtn = cb && cb.subsCapsButton;\n    var ccBtn = cb && cb.captionsButton;\n\n    if (subsCapsBtn) {\n      subsCapsBtn.focus();\n    } else if (ccBtn) {\n      ccBtn.focus();\n    }\n  };\n\n  return TextTrackSettings;\n}(ModalDialog);\n\nComponent.registerComponent('TextTrackSettings', TextTrackSettings);\n/**\n * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.\n *\n * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.\n *\n * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.\n * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.\n * @example <caption>How to disable the resize manager</caption>\n * const player = videojs('#vid', {\n *   resizeManager: false\n * });\n *\n * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}\n *\n * @extends Component\n */\n\nvar ResizeManager = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ResizeManager, _Component);\n  /**\n   * Create the ResizeManager.\n   *\n   * @param {Object} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of ResizeManager options.\n   *\n   * @param {Object} [options.ResizeObserver]\n   *        A polyfill for ResizeObserver can be passed in here.\n   *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.\n   */\n\n\n  function ResizeManager(player, options) {\n    var _this;\n\n    var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window$1.ResizeObserver; // if `null` was passed, we want to disable the ResizeObserver\n\n    if (options.ResizeObserver === null) {\n      RESIZE_OBSERVER_AVAILABLE = false;\n    } // Only create an element when ResizeObserver isn't available\n\n\n    var options_ = mergeOptions({\n      createEl: !RESIZE_OBSERVER_AVAILABLE,\n      reportTouchActivity: false\n    }, options);\n    _this = _Component.call(this, player, options_) || this;\n    _this.ResizeObserver = options.ResizeObserver || window$1.ResizeObserver;\n    _this.loadListener_ = null;\n    _this.resizeObserver_ = null;\n    _this.debouncedHandler_ = debounce(function () {\n      _this.resizeHandler();\n    }, 100, false, _assertThisInitialized(_this));\n\n    if (RESIZE_OBSERVER_AVAILABLE) {\n      _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);\n\n      _this.resizeObserver_.observe(player.el());\n    } else {\n      _this.loadListener_ = function () {\n        if (!_this.el_ || !_this.el_.contentWindow) {\n          return;\n        }\n\n        var debouncedHandler_ = _this.debouncedHandler_;\n\n        var unloadListener_ = _this.unloadListener_ = function () {\n          off(this, 'resize', debouncedHandler_);\n          off(this, 'unload', unloadListener_);\n          unloadListener_ = null;\n        }; // safari and edge can unload the iframe before resizemanager dispose\n        // we have to dispose of event handlers correctly before that happens\n\n\n        on(_this.el_.contentWindow, 'unload', unloadListener_);\n        on(_this.el_.contentWindow, 'resize', debouncedHandler_);\n      };\n\n      _this.one('load', _this.loadListener_);\n    }\n\n    return _this;\n  }\n\n  var _proto = ResizeManager.prototype;\n\n  _proto.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'iframe', {\n      className: 'vjs-resize-manager',\n      tabIndex: -1\n    }, {\n      'aria-hidden': 'true'\n    });\n  }\n  /**\n   * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver\n   *\n   * @fires Player#playerresize\n   */\n  ;\n\n  _proto.resizeHandler = function resizeHandler() {\n    /**\n     * Called when the player size has changed\n     *\n     * @event Player#playerresize\n     * @type {EventTarget~Event}\n     */\n    // make sure player is still around to trigger\n    // prevents this from causing an error after dispose\n    if (!this.player_ || !this.player_.trigger) {\n      return;\n    }\n\n    this.player_.trigger('playerresize');\n  };\n\n  _proto.dispose = function dispose() {\n    if (this.debouncedHandler_) {\n      this.debouncedHandler_.cancel();\n    }\n\n    if (this.resizeObserver_) {\n      if (this.player_.el()) {\n        this.resizeObserver_.unobserve(this.player_.el());\n      }\n\n      this.resizeObserver_.disconnect();\n    }\n\n    if (this.loadListener_) {\n      this.off('load', this.loadListener_);\n    }\n\n    if (this.el_ && this.el_.contentWindow && this.unloadListener_) {\n      this.unloadListener_.call(this.el_.contentWindow);\n    }\n\n    this.ResizeObserver = null;\n    this.resizeObserver = null;\n    this.debouncedHandler_ = null;\n    this.loadListener_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  return ResizeManager;\n}(Component);\n\nComponent.registerComponent('ResizeManager', ResizeManager);\nvar defaults = {\n  trackingThreshold: 30,\n  liveTolerance: 15\n};\n/*\n  track when we are at the live edge, and other helpers for live playback */\n\n/**\n * A class for checking live current time and determining when the player\n * is at or behind the live edge.\n */\n\nvar LiveTracker = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(LiveTracker, _Component);\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {number} [options.trackingThreshold=30]\n   *        Number of seconds of live window (seekableEnd - seekableStart) that\n   *        media needs to have before the liveui will be shown.\n   *\n   * @param {number} [options.liveTolerance=15]\n   *        Number of seconds behind live that we have to be\n   *        before we will be considered non-live. Note that this will only\n   *        be used when playing at the live edge. This allows large seekable end\n   *        changes to not effect wether we are live or not.\n   */\n\n\n  function LiveTracker(player, options) {\n    var _this; // LiveTracker does not need an element\n\n\n    var options_ = mergeOptions(defaults, options, {\n      createEl: false\n    });\n    _this = _Component.call(this, player, options_) || this;\n\n    _this.reset_();\n\n    _this.on(_this.player_, 'durationchange', _this.handleDurationchange); // we don't need to track live playback if the document is hidden,\n    // also, tracking when the document is hidden can\n    // cause the CPU to spike and eventually crash the page on IE11.\n\n\n    if (IE_VERSION && 'hidden' in document && 'visibilityState' in document) {\n      _this.on(document, 'visibilitychange', _this.handleVisibilityChange);\n    }\n\n    return _this;\n  }\n  /**\n   * toggle tracking based on document visiblility\n   */\n\n\n  var _proto = LiveTracker.prototype;\n\n  _proto.handleVisibilityChange = function handleVisibilityChange() {\n    if (this.player_.duration() !== Infinity) {\n      return;\n    }\n\n    if (document.hidden) {\n      this.stopTracking();\n    } else {\n      this.startTracking();\n    }\n  }\n  /**\n   * all the functionality for tracking when seek end changes\n   * and for tracking how far past seek end we should be\n   */\n  ;\n\n  _proto.trackLive_ = function trackLive_() {\n    var seekable = this.player_.seekable(); // skip undefined seekable\n\n    if (!seekable || !seekable.length) {\n      return;\n    }\n\n    var newTime = Number(window$1.performance.now().toFixed(4));\n    var deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;\n    this.lastTime_ = newTime;\n    this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;\n    var liveCurrentTime = this.liveCurrentTime();\n    var currentTime = this.player_.currentTime(); // we are behind live if any are true\n    // 1. the player is paused\n    // 2. the user seeked to a location 2 seconds away from live\n    // 3. the difference between live and current time is greater\n    //    liveTolerance which defaults to 15s\n\n    var isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance; // we cannot be behind if\n    // 1. until we have not seen a timeupdate yet\n    // 2. liveCurrentTime is Infinity, which happens on Android\n\n    if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {\n      isBehind = false;\n    }\n\n    if (isBehind !== this.behindLiveEdge_) {\n      this.behindLiveEdge_ = isBehind;\n      this.trigger('liveedgechange');\n    }\n  }\n  /**\n   * handle a durationchange event on the player\n   * and start/stop tracking accordingly.\n   */\n  ;\n\n  _proto.handleDurationchange = function handleDurationchange() {\n    if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {\n      if (this.player_.options_.liveui) {\n        this.player_.addClass('vjs-liveui');\n      }\n\n      this.startTracking();\n    } else {\n      this.player_.removeClass('vjs-liveui');\n      this.stopTracking();\n    }\n  }\n  /**\n   * start tracking live playback\n   */\n  ;\n\n  _proto.startTracking = function startTracking() {\n    if (this.isTracking()) {\n      return;\n    } // If we haven't seen a timeupdate, we need to check whether playback\n    // began before this component started tracking. This can happen commonly\n    // when using autoplay.\n\n\n    if (!this.timeupdateSeen_) {\n      this.timeupdateSeen_ = this.player_.hasStarted();\n    }\n\n    this.trackingInterval_ = this.setInterval(this.trackLive_, UPDATE_REFRESH_INTERVAL);\n    this.trackLive_();\n    this.on(this.player_, ['play', 'pause'], this.trackLive_);\n\n    if (!this.timeupdateSeen_) {\n      this.one(this.player_, 'play', this.handlePlay);\n      this.one(this.player_, 'timeupdate', this.handleFirstTimeupdate);\n    } else {\n      this.on(this.player_, 'seeked', this.handleSeeked);\n    }\n  }\n  /**\n   * handle the first timeupdate on the player if it wasn't already playing\n   * when live tracker started tracking.\n   */\n  ;\n\n  _proto.handleFirstTimeupdate = function handleFirstTimeupdate() {\n    this.timeupdateSeen_ = true;\n    this.on(this.player_, 'seeked', this.handleSeeked);\n  }\n  /**\n   * Keep track of what time a seek starts, and listen for seeked\n   * to find where a seek ends.\n   */\n  ;\n\n  _proto.handleSeeked = function handleSeeked() {\n    var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());\n    this.seekedBehindLive_ = this.skipNextSeeked_ ? false : timeDiff > 2;\n    this.skipNextSeeked_ = false;\n    this.trackLive_();\n  }\n  /**\n   * handle the first play on the player, and make sure that we seek\n   * right to the live edge.\n   */\n  ;\n\n  _proto.handlePlay = function handlePlay() {\n    this.one(this.player_, 'timeupdate', this.seekToLiveEdge);\n  }\n  /**\n   * Stop tracking, and set all internal variables to\n   * their initial value.\n   */\n  ;\n\n  _proto.reset_ = function reset_() {\n    this.lastTime_ = -1;\n    this.pastSeekEnd_ = 0;\n    this.lastSeekEnd_ = -1;\n    this.behindLiveEdge_ = true;\n    this.timeupdateSeen_ = false;\n    this.seekedBehindLive_ = false;\n    this.skipNextSeeked_ = false;\n    this.clearInterval(this.trackingInterval_);\n    this.trackingInterval_ = null;\n    this.off(this.player_, ['play', 'pause'], this.trackLive_);\n    this.off(this.player_, 'seeked', this.handleSeeked);\n    this.off(this.player_, 'play', this.handlePlay);\n    this.off(this.player_, 'timeupdate', this.handleFirstTimeupdate);\n    this.off(this.player_, 'timeupdate', this.seekToLiveEdge);\n  }\n  /**\n   * stop tracking live playback\n   */\n  ;\n\n  _proto.stopTracking = function stopTracking() {\n    if (!this.isTracking()) {\n      return;\n    }\n\n    this.reset_();\n    this.trigger('liveedgechange');\n  }\n  /**\n   * A helper to get the player seekable end\n   * so that we don't have to null check everywhere\n   *\n   * @return {number}\n   *         The furthest seekable end or Infinity.\n   */\n  ;\n\n  _proto.seekableEnd = function seekableEnd() {\n    var seekable = this.player_.seekable();\n    var seekableEnds = [];\n    var i = seekable ? seekable.length : 0;\n\n    while (i--) {\n      seekableEnds.push(seekable.end(i));\n    } // grab the furthest seekable end after sorting, or if there are none\n    // default to Infinity\n\n\n    return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;\n  }\n  /**\n   * A helper to get the player seekable start\n   * so that we don't have to null check everywhere\n   *\n   * @return {number}\n   *         The earliest seekable start or 0.\n   */\n  ;\n\n  _proto.seekableStart = function seekableStart() {\n    var seekable = this.player_.seekable();\n    var seekableStarts = [];\n    var i = seekable ? seekable.length : 0;\n\n    while (i--) {\n      seekableStarts.push(seekable.start(i));\n    } // grab the first seekable start after sorting, or if there are none\n    // default to 0\n\n\n    return seekableStarts.length ? seekableStarts.sort()[0] : 0;\n  }\n  /**\n   * Get the live time window aka\n   * the amount of time between seekable start and\n   * live current time.\n   *\n   * @return {number}\n   *         The amount of seconds that are seekable in\n   *         the live video.\n   */\n  ;\n\n  _proto.liveWindow = function liveWindow() {\n    var liveCurrentTime = this.liveCurrentTime();\n\n    if (liveCurrentTime === Infinity) {\n      return Infinity;\n    }\n\n    return liveCurrentTime - this.seekableStart();\n  }\n  /**\n   * Determines if the player is live, only checks if this component\n   * is tracking live playback or not\n   *\n   * @return {boolean}\n   *         Wether liveTracker is tracking\n   */\n  ;\n\n  _proto.isLive = function isLive() {\n    return this.isTracking();\n  }\n  /**\n   * Determines if currentTime is at the live edge and won't fall behind\n   * on each seekableendchange\n   *\n   * @return {boolean}\n   *         Wether playback is at the live edge\n   */\n  ;\n\n  _proto.atLiveEdge = function atLiveEdge() {\n    return !this.behindLiveEdge();\n  }\n  /**\n   * get what we expect the live current time to be\n   *\n   * @return {number}\n   *         The expected live current time\n   */\n  ;\n\n  _proto.liveCurrentTime = function liveCurrentTime() {\n    return this.pastSeekEnd() + this.seekableEnd();\n  }\n  /**\n   * The number of seconds that have occured after seekable end\n   * changed. This will be reset to 0 once seekable end changes.\n   *\n   * @return {number}\n   *         Seconds past the current seekable end\n   */\n  ;\n\n  _proto.pastSeekEnd = function pastSeekEnd() {\n    var seekableEnd = this.seekableEnd();\n\n    if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {\n      this.pastSeekEnd_ = 0;\n    }\n\n    this.lastSeekEnd_ = seekableEnd;\n    return this.pastSeekEnd_;\n  }\n  /**\n   * If we are currently behind the live edge, aka currentTime will be\n   * behind on a seekableendchange\n   *\n   * @return {boolean}\n   *         If we are behind the live edge\n   */\n  ;\n\n  _proto.behindLiveEdge = function behindLiveEdge() {\n    return this.behindLiveEdge_;\n  }\n  /**\n   * Wether live tracker is currently tracking or not.\n   */\n  ;\n\n  _proto.isTracking = function isTracking() {\n    return typeof this.trackingInterval_ === 'number';\n  }\n  /**\n   * Seek to the live edge if we are behind the live edge\n   */\n  ;\n\n  _proto.seekToLiveEdge = function seekToLiveEdge() {\n    this.seekedBehindLive_ = false;\n\n    if (this.atLiveEdge()) {\n      return;\n    } // skipNextSeeked_\n\n\n    this.skipNextSeeked_ = true;\n    this.player_.currentTime(this.liveCurrentTime());\n  }\n  /**\n   * Dispose of liveTracker\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.off(document, 'visibilitychange', this.handleVisibilityChange);\n    this.stopTracking();\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  return LiveTracker;\n}(Component);\n\nComponent.registerComponent('LiveTracker', LiveTracker);\n/**\n * This function is used to fire a sourceset when there is something\n * similar to `mediaEl.load()` being called. It will try to find the source via\n * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`\n * with the source that was found or empty string if we cannot know. If it cannot\n * find a source then `sourceset` will not be fired.\n *\n * @param {Html5} tech\n *        The tech object that sourceset was setup on\n *\n * @return {boolean}\n *         returns false if the sourceset was not fired and true otherwise.\n */\n\nvar sourcesetLoad = function sourcesetLoad(tech) {\n  var el = tech.el(); // if `el.src` is set, that source will be loaded.\n\n  if (el.hasAttribute('src')) {\n    tech.triggerSourceset(el.src);\n    return true;\n  }\n  /**\n   * Since there isn't a src property on the media element, source elements will be used for\n   * implementing the source selection algorithm. This happens asynchronously and\n   * for most cases were there is more than one source we cannot tell what source will\n   * be loaded, without re-implementing the source selection algorithm. At this time we are not\n   * going to do that. There are three special cases that we do handle here though:\n   *\n   * 1. If there are no sources, do not fire `sourceset`.\n   * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`\n   * 3. If there is more than one `<source>` but all of them have the same `src` url.\n   *    That will be our src.\n   */\n\n\n  var sources = tech.$$('source');\n  var srcUrls = [];\n  var src = ''; // if there are no sources, do not fire sourceset\n\n  if (!sources.length) {\n    return false;\n  } // only count valid/non-duplicate source elements\n\n\n  for (var i = 0; i < sources.length; i++) {\n    var url = sources[i].src;\n\n    if (url && srcUrls.indexOf(url) === -1) {\n      srcUrls.push(url);\n    }\n  } // there were no valid sources\n\n\n  if (!srcUrls.length) {\n    return false;\n  } // there is only one valid source element url\n  // use that\n\n\n  if (srcUrls.length === 1) {\n    src = srcUrls[0];\n  }\n\n  tech.triggerSourceset(src);\n  return true;\n};\n/**\n * our implementation of an `innerHTML` descriptor for browsers\n * that do not have one.\n */\n\n\nvar innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {\n  get: function get() {\n    return this.cloneNode(true).innerHTML;\n  },\n  set: function set(v) {\n    // make a dummy node to use innerHTML on\n    var dummy = document.createElement(this.nodeName.toLowerCase()); // set innerHTML to the value provided\n\n    dummy.innerHTML = v; // make a document fragment to hold the nodes from dummy\n\n    var docFrag = document.createDocumentFragment(); // copy all of the nodes created by the innerHTML on dummy\n    // to the document fragment\n\n    while (dummy.childNodes.length) {\n      docFrag.appendChild(dummy.childNodes[0]);\n    } // remove content\n\n\n    this.innerText = ''; // now we add all of that html in one by appending the\n    // document fragment. This is how innerHTML does it.\n\n    window$1.Element.prototype.appendChild.call(this, docFrag); // then return the result that innerHTML's setter would\n\n    return this.innerHTML;\n  }\n});\n/**\n * Get a property descriptor given a list of priorities and the\n * property to get.\n */\n\nvar getDescriptor = function getDescriptor(priority, prop) {\n  var descriptor = {};\n\n  for (var i = 0; i < priority.length; i++) {\n    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);\n\n    if (descriptor && descriptor.set && descriptor.get) {\n      break;\n    }\n  }\n\n  descriptor.enumerable = true;\n  descriptor.configurable = true;\n  return descriptor;\n};\n\nvar getInnerHTMLDescriptor = function getInnerHTMLDescriptor(tech) {\n  return getDescriptor([tech.el(), window$1.HTMLMediaElement.prototype, window$1.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');\n};\n/**\n * Patches browser internal functions so that we can tell synchronously\n * if a `<source>` was appended to the media element. For some reason this\n * causes a `sourceset` if the the media element is ready and has no source.\n * This happens when:\n * - The page has just loaded and the media element does not have a source.\n * - The media element was emptied of all sources, then `load()` was called.\n *\n * It does this by patching the following functions/properties when they are supported:\n *\n * - `append()` - can be used to add a `<source>` element to the media element\n * - `appendChild()` - can be used to add a `<source>` element to the media element\n * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element\n * - `innerHTML` -  can be used to add a `<source>` element to the media element\n *\n * @param {Html5} tech\n *        The tech object that sourceset is being setup on.\n */\n\n\nvar firstSourceWatch = function firstSourceWatch(tech) {\n  var el = tech.el(); // make sure firstSourceWatch isn't setup twice.\n\n  if (el.resetSourceWatch_) {\n    return;\n  }\n\n  var old = {};\n  var innerDescriptor = getInnerHTMLDescriptor(tech);\n\n  var appendWrapper = function appendWrapper(appendFn) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var retval = appendFn.apply(el, args);\n      sourcesetLoad(tech);\n      return retval;\n    };\n  };\n\n  ['append', 'appendChild', 'insertAdjacentHTML'].forEach(function (k) {\n    if (!el[k]) {\n      return;\n    } // store the old function\n\n\n    old[k] = el[k]; // call the old function with a sourceset if a source\n    // was loaded\n\n    el[k] = appendWrapper(old[k]);\n  });\n  Object.defineProperty(el, 'innerHTML', mergeOptions(innerDescriptor, {\n    set: appendWrapper(innerDescriptor.set)\n  }));\n\n  el.resetSourceWatch_ = function () {\n    el.resetSourceWatch_ = null;\n    Object.keys(old).forEach(function (k) {\n      el[k] = old[k];\n    });\n    Object.defineProperty(el, 'innerHTML', innerDescriptor);\n  }; // on the first sourceset, we need to revert our changes\n\n\n  tech.one('sourceset', el.resetSourceWatch_);\n};\n/**\n * our implementation of a `src` descriptor for browsers\n * that do not have one.\n */\n\n\nvar srcDescriptorPolyfill = Object.defineProperty({}, 'src', {\n  get: function get() {\n    if (this.hasAttribute('src')) {\n      return getAbsoluteURL(window$1.Element.prototype.getAttribute.call(this, 'src'));\n    }\n\n    return '';\n  },\n  set: function set(v) {\n    window$1.Element.prototype.setAttribute.call(this, 'src', v);\n    return v;\n  }\n});\n\nvar getSrcDescriptor = function getSrcDescriptor(tech) {\n  return getDescriptor([tech.el(), window$1.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');\n};\n/**\n * setup `sourceset` handling on the `Html5` tech. This function\n * patches the following element properties/functions:\n *\n * - `src` - to determine when `src` is set\n * - `setAttribute()` - to determine when `src` is set\n * - `load()` - this re-triggers the source selection algorithm, and can\n *              cause a sourceset.\n *\n * If there is no source when we are adding `sourceset` support or during a `load()`\n * we also patch the functions listed in `firstSourceWatch`.\n *\n * @param {Html5} tech\n *        The tech to patch\n */\n\n\nvar setupSourceset = function setupSourceset(tech) {\n  if (!tech.featuresSourceset) {\n    return;\n  }\n\n  var el = tech.el(); // make sure sourceset isn't setup twice.\n\n  if (el.resetSourceset_) {\n    return;\n  }\n\n  var srcDescriptor = getSrcDescriptor(tech);\n  var oldSetAttribute = el.setAttribute;\n  var oldLoad = el.load;\n  Object.defineProperty(el, 'src', mergeOptions(srcDescriptor, {\n    set: function set(v) {\n      var retval = srcDescriptor.set.call(el, v); // we use the getter here to get the actual value set on src\n\n      tech.triggerSourceset(el.src);\n      return retval;\n    }\n  }));\n\n  el.setAttribute = function (n, v) {\n    var retval = oldSetAttribute.call(el, n, v);\n\n    if (/src/i.test(n)) {\n      tech.triggerSourceset(el.src);\n    }\n\n    return retval;\n  };\n\n  el.load = function () {\n    var retval = oldLoad.call(el); // if load was called, but there was no source to fire\n    // sourceset on. We have to watch for a source append\n    // as that can trigger a `sourceset` when the media element\n    // has no source\n\n    if (!sourcesetLoad(tech)) {\n      tech.triggerSourceset('');\n      firstSourceWatch(tech);\n    }\n\n    return retval;\n  };\n\n  if (el.currentSrc) {\n    tech.triggerSourceset(el.currentSrc);\n  } else if (!sourcesetLoad(tech)) {\n    firstSourceWatch(tech);\n  }\n\n  el.resetSourceset_ = function () {\n    el.resetSourceset_ = null;\n    el.load = oldLoad;\n    el.setAttribute = oldSetAttribute;\n    Object.defineProperty(el, 'src', srcDescriptor);\n\n    if (el.resetSourceWatch_) {\n      el.resetSourceWatch_();\n    }\n  };\n};\n/**\n * Object.defineProperty but \"lazy\", which means that the value is only set after\n * it retrieved the first time, rather than being set right away.\n *\n * @param {Object} obj the object to set the property on\n * @param {string} key the key for the property to set\n * @param {Function} getValue the function used to get the value when it is needed.\n * @param {boolean} setter wether a setter shoould be allowed or not\n */\n\n\nvar defineLazyProperty = function defineLazyProperty(obj, key, getValue, setter) {\n  if (setter === void 0) {\n    setter = true;\n  }\n\n  var set = function set(value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      writable: true\n    });\n  };\n\n  var options = {\n    configurable: true,\n    enumerable: true,\n    get: function get() {\n      var value = getValue();\n      set(value);\n      return value;\n    }\n  };\n\n  if (setter) {\n    options.set = set;\n  }\n\n  return Object.defineProperty(obj, key, options);\n};\n/**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n *\n * @mixes Tech~SourceHandlerAdditions\n * @extends Tech\n */\n\n\nvar Html5 = /*#__PURE__*/function (_Tech) {\n  _inheritsLoose(Html5, _Tech);\n  /**\n  * Create an instance of this Tech.\n  *\n  * @param {Object} [options]\n  *        The key/value store of player options.\n  *\n  * @param {Component~ReadyCallback} ready\n  *        Callback function to call when the `HTML5` Tech is ready.\n  */\n\n\n  function Html5(options, ready) {\n    var _this;\n\n    _this = _Tech.call(this, options, ready) || this;\n    var source = options.source;\n    var crossoriginTracks = false; // Set the source if one is provided\n    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n    // anyway so the error gets fired.\n\n    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\n      _this.setSource(source);\n    } else {\n      _this.handleLateInit_(_this.el_);\n    } // setup sourceset after late sourceset/init\n\n\n    if (options.enableSourceset) {\n      _this.setupSourcesetHandling_();\n    }\n\n    if (_this.el_.hasChildNodes()) {\n      var nodes = _this.el_.childNodes;\n      var nodesLength = nodes.length;\n      var removeNodes = [];\n\n      while (nodesLength--) {\n        var node = nodes[nodesLength];\n        var nodeName = node.nodeName.toLowerCase();\n\n        if (nodeName === 'track') {\n          if (!_this.featuresNativeTextTracks) {\n            // Empty video tag tracks so the built-in player doesn't use them also.\n            // This may not be fast enough to stop HTML5 browsers from reading the tags\n            // so we'll need to turn off any default tracks if we're manually doing\n            // captions and subtitles. videoElement.textTracks\n            removeNodes.push(node);\n          } else {\n            // store HTMLTrackElement and TextTrack to remote list\n            _this.remoteTextTrackEls().addTrackElement_(node);\n\n            _this.remoteTextTracks().addTrack(node.track);\n\n            _this.textTracks().addTrack(node.track);\n\n            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\n              crossoriginTracks = true;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < removeNodes.length; i++) {\n        _this.el_.removeChild(removeNodes[i]);\n      }\n    }\n\n    _this.proxyNativeTracks_();\n\n    if (_this.featuresNativeTextTracks && crossoriginTracks) {\n      log.warn('Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n' + 'This may prevent text tracks from loading.');\n    } // prevent iOS Safari from disabling metadata text tracks during native playback\n\n\n    _this.restoreMetadataTracksInIOSNativePlayer_(); // Determine if native controls should be used\n    // Our goal should be to get the custom controls on mobile solid everywhere\n    // so we can remove this all together. Right now this will block custom\n    // controls on touch enabled laptops like the Chrome Pixel\n\n\n    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {\n      _this.setControls(true);\n    } // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n    // into a `fullscreenchange` event\n\n\n    _this.proxyWebkitFullscreen_();\n\n    _this.triggerReady();\n\n    return _this;\n  }\n  /**\n   * Dispose of `HTML5` media element and remove all tracks.\n   */\n\n\n  var _proto = Html5.prototype;\n\n  _proto.dispose = function dispose() {\n    if (this.el_ && this.el_.resetSourceset_) {\n      this.el_.resetSourceset_();\n    }\n\n    Html5.disposeMediaElement(this.el_);\n    this.options_ = null; // tech will handle clearing of the emulated track list\n\n    _Tech.prototype.dispose.call(this);\n  }\n  /**\n   * Modify the media element so that we can detect when\n   * the source is changed. Fires `sourceset` just after the source has changed\n   */\n  ;\n\n  _proto.setupSourcesetHandling_ = function setupSourcesetHandling_() {\n    setupSourceset(this);\n  }\n  /**\n   * When a captions track is enabled in the iOS Safari native player, all other\n   * tracks are disabled (including metadata tracks), which nulls all of their\n   * associated cue points. This will restore metadata tracks to their pre-fullscreen\n   * state in those cases so that cue points are not needlessly lost.\n   *\n   * @private\n   */\n  ;\n\n  _proto.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {\n    var textTracks = this.textTracks();\n    var metadataTracksPreFullscreenState; // captures a snapshot of every metadata track's current state\n\n    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {\n      metadataTracksPreFullscreenState = [];\n\n      for (var i = 0; i < textTracks.length; i++) {\n        var track = textTracks[i];\n\n        if (track.kind === 'metadata') {\n          metadataTracksPreFullscreenState.push({\n            track: track,\n            storedMode: track.mode\n          });\n        }\n      }\n    }; // snapshot each metadata track's initial state, and update the snapshot\n    // each time there is a track 'change' event\n\n\n    takeMetadataTrackSnapshot();\n    textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n    this.on('dispose', function () {\n      return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n    });\n\n    var restoreTrackMode = function restoreTrackMode() {\n      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {\n        var storedTrack = metadataTracksPreFullscreenState[i];\n\n        if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\n          storedTrack.track.mode = storedTrack.storedMode;\n        }\n      } // we only want this handler to be executed on the first 'change' event\n\n\n      textTracks.removeEventListener('change', restoreTrackMode);\n    }; // when we enter fullscreen playback, stop updating the snapshot and\n    // restore all track modes to their pre-fullscreen state\n\n\n    this.on('webkitbeginfullscreen', function () {\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot); // remove the listener before adding it just in case it wasn't previously removed\n\n      textTracks.removeEventListener('change', restoreTrackMode);\n      textTracks.addEventListener('change', restoreTrackMode);\n    }); // start updating the snapshot again after leaving fullscreen\n\n    this.on('webkitendfullscreen', function () {\n      // remove the listener before adding it just in case it wasn't previously removed\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n      textTracks.addEventListener('change', takeMetadataTrackSnapshot); // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\n\n      textTracks.removeEventListener('change', restoreTrackMode);\n    });\n  }\n  /**\n   * Attempt to force override of tracks for the given type\n   *\n   * @param {string} type - Track type to override, possible values include 'Audio',\n   * 'Video', and 'Text'.\n   * @param {boolean} override - If set to true native audio/video will be overridden,\n   * otherwise native audio/video will potentially be used.\n   * @private\n   */\n  ;\n\n  _proto.overrideNative_ = function overrideNative_(type, override) {\n    var _this2 = this; // If there is no behavioral change don't add/remove listeners\n\n\n    if (override !== this[\"featuresNative\" + type + \"Tracks\"]) {\n      return;\n    }\n\n    var lowerCaseType = type.toLowerCase();\n\n    if (this[lowerCaseType + \"TracksListeners_\"]) {\n      Object.keys(this[lowerCaseType + \"TracksListeners_\"]).forEach(function (eventName) {\n        var elTracks = _this2.el()[lowerCaseType + \"Tracks\"];\n\n        elTracks.removeEventListener(eventName, _this2[lowerCaseType + \"TracksListeners_\"][eventName]);\n      });\n    }\n\n    this[\"featuresNative\" + type + \"Tracks\"] = !override;\n    this[lowerCaseType + \"TracksListeners_\"] = null;\n    this.proxyNativeTracksForType_(lowerCaseType);\n  }\n  /**\n   * Attempt to force override of native audio tracks.\n   *\n   * @param {boolean} override - If set to true native audio will be overridden,\n   * otherwise native audio will potentially be used.\n   */\n  ;\n\n  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {\n    this.overrideNative_('Audio', override);\n  }\n  /**\n   * Attempt to force override of native video tracks.\n   *\n   * @param {boolean} override - If set to true native video will be overridden,\n   * otherwise native video will potentially be used.\n   */\n  ;\n\n  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {\n    this.overrideNative_('Video', override);\n  }\n  /**\n   * Proxy native track list events for the given type to our track\n   * lists if the browser we are playing in supports that type of track list.\n   *\n   * @param {string} name - Track type; values include 'audio', 'video', and 'text'\n   * @private\n   */\n  ;\n\n  _proto.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {\n    var _this3 = this;\n\n    var props = NORMAL[name];\n    var elTracks = this.el()[props.getterName];\n    var techTracks = this[props.getterName]();\n\n    if (!this[\"featuresNative\" + props.capitalName + \"Tracks\"] || !elTracks || !elTracks.addEventListener) {\n      return;\n    }\n\n    var listeners = {\n      change: function change(e) {\n        var event = {\n          type: 'change',\n          target: techTracks,\n          currentTarget: techTracks,\n          srcElement: techTracks\n        };\n        techTracks.trigger(event); // if we are a text track change event, we should also notify the\n        // remote text track list. This can potentially cause a false positive\n        // if we were to get a change event on a non-remote track and\n        // we triggered the event on the remote text track list which doesn't\n        // contain that track. However, best practices mean looping through the\n        // list of tracks and searching for the appropriate mode value, so,\n        // this shouldn't pose an issue\n\n        if (name === 'text') {\n          _this3[REMOTE.remoteText.getterName]().trigger(event);\n        }\n      },\n      addtrack: function addtrack(e) {\n        techTracks.addTrack(e.track);\n      },\n      removetrack: function removetrack(e) {\n        techTracks.removeTrack(e.track);\n      }\n    };\n\n    var removeOldTracks = function removeOldTracks() {\n      var removeTracks = [];\n\n      for (var i = 0; i < techTracks.length; i++) {\n        var found = false;\n\n        for (var j = 0; j < elTracks.length; j++) {\n          if (elTracks[j] === techTracks[i]) {\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          removeTracks.push(techTracks[i]);\n        }\n      }\n\n      while (removeTracks.length) {\n        techTracks.removeTrack(removeTracks.shift());\n      }\n    };\n\n    this[props.getterName + 'Listeners_'] = listeners;\n    Object.keys(listeners).forEach(function (eventName) {\n      var listener = listeners[eventName];\n      elTracks.addEventListener(eventName, listener);\n\n      _this3.on('dispose', function (e) {\n        return elTracks.removeEventListener(eventName, listener);\n      });\n    }); // Remove (native) tracks that are not used anymore\n\n    this.on('loadstart', removeOldTracks);\n    this.on('dispose', function (e) {\n      return _this3.off('loadstart', removeOldTracks);\n    });\n  }\n  /**\n   * Proxy all native track list events to our track lists if the browser we are playing\n   * in supports that type of track list.\n   *\n   * @private\n   */\n  ;\n\n  _proto.proxyNativeTracks_ = function proxyNativeTracks_() {\n    var _this4 = this;\n\n    NORMAL.names.forEach(function (name) {\n      _this4.proxyNativeTracksForType_(name);\n    });\n  }\n  /**\n   * Create the `Html5` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    var el = this.options_.tag; // Check if this browser supports moving the element into the box.\n    // On the iPhone video will break if you move the element,\n    // So we have to create a brand new element.\n    // If we ingested the player div, we do not need to move the media element.\n\n    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\n      // If the original tag is still there, clone and remove it.\n      if (el) {\n        var clone = el.cloneNode(true);\n\n        if (el.parentNode) {\n          el.parentNode.insertBefore(clone, el);\n        }\n\n        Html5.disposeMediaElement(el);\n        el = clone;\n      } else {\n        el = document.createElement('video'); // determine if native controls should be used\n\n        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\n        var attributes = mergeOptions({}, tagAttributes);\n\n        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\n          delete attributes.controls;\n        }\n\n        setAttributes(el, assign(attributes, {\n          id: this.options_.techId,\n          \"class\": 'vjs-tech'\n        }));\n      }\n\n      el.playerId = this.options_.playerId;\n    }\n\n    if (typeof this.options_.preload !== 'undefined') {\n      setAttribute(el, 'preload', this.options_.preload);\n    }\n\n    if (this.options_.disablePictureInPicture !== undefined) {\n      el.disablePictureInPicture = this.options_.disablePictureInPicture;\n    } // Update specific tag settings, in case they were overridden\n    // `autoplay` has to be *last* so that `muted` and `playsinline` are present\n    // when iOS/Safari or other browsers attempt to autoplay.\n\n\n    var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\n\n    for (var i = 0; i < settingsAttrs.length; i++) {\n      var attr = settingsAttrs[i];\n      var value = this.options_[attr];\n\n      if (typeof value !== 'undefined') {\n        if (value) {\n          setAttribute(el, attr, attr);\n        } else {\n          removeAttribute(el, attr);\n        }\n\n        el[attr] = value;\n      }\n    }\n\n    return el;\n  }\n  /**\n   * This will be triggered if the loadstart event has already fired, before videojs was\n   * ready. Two known examples of when this can happen are:\n   * 1. If we're loading the playback object after it has started loading\n   * 2. The media is already playing the (often with autoplay on) then\n   *\n   * This function will fire another loadstart so that videojs can catchup.\n   *\n   * @fires Tech#loadstart\n   *\n   * @return {undefined}\n   *         returns nothing.\n   */\n  ;\n\n  _proto.handleLateInit_ = function handleLateInit_(el) {\n    if (el.networkState === 0 || el.networkState === 3) {\n      // The video element hasn't started loading the source yet\n      // or didn't find a source\n      return;\n    }\n\n    if (el.readyState === 0) {\n      // NetworkState is set synchronously BUT loadstart is fired at the\n      // end of the current stack, usually before setInterval(fn, 0).\n      // So at this point we know loadstart may have already fired or is\n      // about to fire, and either way the player hasn't seen it yet.\n      // We don't want to fire loadstart prematurely here and cause a\n      // double loadstart so we'll wait and see if it happens between now\n      // and the next loop, and fire it if not.\n      // HOWEVER, we also want to make sure it fires before loadedmetadata\n      // which could also happen between now and the next loop, so we'll\n      // watch for that also.\n      var loadstartFired = false;\n\n      var setLoadstartFired = function setLoadstartFired() {\n        loadstartFired = true;\n      };\n\n      this.on('loadstart', setLoadstartFired);\n\n      var triggerLoadstart = function triggerLoadstart() {\n        // We did miss the original loadstart. Make sure the player\n        // sees loadstart before loadedmetadata\n        if (!loadstartFired) {\n          this.trigger('loadstart');\n        }\n      };\n\n      this.on('loadedmetadata', triggerLoadstart);\n      this.ready(function () {\n        this.off('loadstart', setLoadstartFired);\n        this.off('loadedmetadata', triggerLoadstart);\n\n        if (!loadstartFired) {\n          // We did miss the original native loadstart. Fire it now.\n          this.trigger('loadstart');\n        }\n      });\n      return;\n    } // From here on we know that loadstart already fired and we missed it.\n    // The other readyState events aren't as much of a problem if we double\n    // them, so not going to go to as much trouble as loadstart to prevent\n    // that unless we find reason to.\n\n\n    var eventsToTrigger = ['loadstart']; // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\n\n    eventsToTrigger.push('loadedmetadata'); // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\n\n    if (el.readyState >= 2) {\n      eventsToTrigger.push('loadeddata');\n    } // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\n\n\n    if (el.readyState >= 3) {\n      eventsToTrigger.push('canplay');\n    } // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\n\n\n    if (el.readyState >= 4) {\n      eventsToTrigger.push('canplaythrough');\n    } // We still need to give the player time to add event listeners\n\n\n    this.ready(function () {\n      eventsToTrigger.forEach(function (type) {\n        this.trigger(type);\n      }, this);\n    });\n  }\n  /**\n   * Set whether we are scrubbing or not.\n   * This is used to decide whether we should use `fastSeek` or not.\n   * `fastSeek` is used to provide trick play on Safari browsers.\n   *\n   * @param {boolean} isScrubbing\n   *                  - true for we are currently scrubbing\n   *                  - false for we are no longer scrubbing\n   */\n  ;\n\n  _proto.setScrubbing = function setScrubbing(isScrubbing) {\n    this.isScrubbing_ = isScrubbing;\n  }\n  /**\n   * Set current time for the `HTML5` tech.\n   *\n   * @param {number} seconds\n   *        Set the current time of the media to this.\n   */\n  ;\n\n  _proto.setCurrentTime = function setCurrentTime(seconds) {\n    try {\n      if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {\n        this.el_.fastSeek(seconds);\n      } else {\n        this.el_.currentTime = seconds;\n      }\n    } catch (e) {\n      log(e, 'Video is not ready. (Video.js)'); // this.warning(VideoJS.warnings.videoNotReady);\n    }\n  }\n  /**\n   * Get the current duration of the HTML5 media element.\n   *\n   * @return {number}\n   *         The duration of the media or 0 if there is no duration.\n   */\n  ;\n\n  _proto.duration = function duration() {\n    var _this5 = this; // Android Chrome will report duration as Infinity for VOD HLS until after\n    // playback has started, which triggers the live display erroneously.\n    // Return NaN if playback has not started and trigger a durationupdate once\n    // the duration can be reliably known.\n\n\n    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\n      // Wait for the first `timeupdate` with currentTime > 0 - there may be\n      // several with 0\n      var checkProgress = function checkProgress() {\n        if (_this5.el_.currentTime > 0) {\n          // Trigger durationchange for genuinely live video\n          if (_this5.el_.duration === Infinity) {\n            _this5.trigger('durationchange');\n          }\n\n          _this5.off('timeupdate', checkProgress);\n        }\n      };\n\n      this.on('timeupdate', checkProgress);\n      return NaN;\n    }\n\n    return this.el_.duration || NaN;\n  }\n  /**\n   * Get the current width of the HTML5 media element.\n   *\n   * @return {number}\n   *         The width of the HTML5 media element.\n   */\n  ;\n\n  _proto.width = function width() {\n    return this.el_.offsetWidth;\n  }\n  /**\n   * Get the current height of the HTML5 media element.\n   *\n   * @return {number}\n   *         The height of the HTML5 media element.\n   */\n  ;\n\n  _proto.height = function height() {\n    return this.el_.offsetHeight;\n  }\n  /**\n   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n   * `fullscreenchange` event.\n   *\n   * @private\n   * @fires fullscreenchange\n   * @listens webkitendfullscreen\n   * @listens webkitbeginfullscreen\n   * @listens webkitbeginfullscreen\n   */\n  ;\n\n  _proto.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {\n    var _this6 = this;\n\n    if (!('webkitDisplayingFullscreen' in this.el_)) {\n      return;\n    }\n\n    var endFn = function endFn() {\n      this.trigger('fullscreenchange', {\n        isFullscreen: false\n      });\n    };\n\n    var beginFn = function beginFn() {\n      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\n        this.one('webkitendfullscreen', endFn);\n        this.trigger('fullscreenchange', {\n          isFullscreen: true,\n          // set a flag in case another tech triggers fullscreenchange\n          nativeIOSFullscreen: true\n        });\n      }\n    };\n\n    this.on('webkitbeginfullscreen', beginFn);\n    this.on('dispose', function () {\n      _this6.off('webkitbeginfullscreen', beginFn);\n\n      _this6.off('webkitendfullscreen', endFn);\n    });\n  }\n  /**\n   * Check if fullscreen is supported on the current playback device.\n   *\n   * @return {boolean}\n   *         - True if fullscreen is supported.\n   *         - False if fullscreen is not supported.\n   */\n  ;\n\n  _proto.supportsFullScreen = function supportsFullScreen() {\n    if (typeof this.el_.webkitEnterFullScreen === 'function') {\n      var userAgent = window$1.navigator && window$1.navigator.userAgent || ''; // Seems to be broken in Chromium/Chrome && Safari in Leopard\n\n      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Request that the `HTML5` Tech enter fullscreen.\n   */\n  ;\n\n  _proto.enterFullScreen = function enterFullScreen() {\n    var video = this.el_;\n\n    if (video.paused && video.networkState <= video.HAVE_METADATA) {\n      // attempt to prime the video element for programmatic access\n      // this isn't necessary on the desktop but shouldn't hurt\n      silencePromise(this.el_.play()); // playing and pausing synchronously during the transition to fullscreen\n      // can get iOS ~6.1 devices into a play/pause loop\n\n      this.setTimeout(function () {\n        video.pause();\n\n        try {\n          video.webkitEnterFullScreen();\n        } catch (e) {\n          this.trigger('fullscreenerror', e);\n        }\n      }, 0);\n    } else {\n      try {\n        video.webkitEnterFullScreen();\n      } catch (e) {\n        this.trigger('fullscreenerror', e);\n      }\n    }\n  }\n  /**\n   * Request that the `HTML5` Tech exit fullscreen.\n   */\n  ;\n\n  _proto.exitFullScreen = function exitFullScreen() {\n    if (!this.el_.webkitDisplayingFullscreen) {\n      this.trigger('fullscreenerror', new Error('The video is not fullscreen'));\n      return;\n    }\n\n    this.el_.webkitExitFullScreen();\n  }\n  /**\n   * Create a floating video window always on top of other windows so that users may\n   * continue consuming media while they interact with other content sites, or\n   * applications on their device.\n   *\n   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n   *\n   * @return {Promise}\n   *         A promise with a Picture-in-Picture window.\n   */\n  ;\n\n  _proto.requestPictureInPicture = function requestPictureInPicture() {\n    return this.el_.requestPictureInPicture();\n  }\n  /**\n   * A getter/setter for the `Html5` Tech's source object.\n   * > Note: Please use {@link Html5#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `HTML5` techs element.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */\n  ;\n\n  _proto.src = function src(_src) {\n    if (_src === undefined) {\n      return this.el_.src;\n    } // Setting src through `src` instead of `setSrc` will be deprecated\n\n\n    this.setSrc(_src);\n  }\n  /**\n   * Reset the tech by removing all sources and then calling\n   * {@link Html5.resetMediaElement}.\n   */\n  ;\n\n  _proto.reset = function reset() {\n    Html5.resetMediaElement(this.el_);\n  }\n  /**\n   * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n   * the HTML5 media element.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object from the HTML5 tech. With a fallback to the\n   *         elements source.\n   */\n  ;\n\n  _proto.currentSrc = function currentSrc() {\n    if (this.currentSource_) {\n      return this.currentSource_.src;\n    }\n\n    return this.el_.currentSrc;\n  }\n  /**\n   * Set controls attribute for the HTML5 media Element.\n   *\n   * @param {string} val\n   *        Value to set the controls attribute to\n   */\n  ;\n\n  _proto.setControls = function setControls(val) {\n    this.el_.controls = !!val;\n  }\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n  ;\n\n  _proto.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.addTextTrack.call(this, kind, label, language);\n    }\n\n    return this.el_.addTextTrack(kind, label, language);\n  }\n  /**\n   * Creates either native TextTrack or an emulated TextTrack depending\n   * on the value of `featuresNativeTextTracks`\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label]\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @param {boolean} [options.default]\n   *        Default this track to on.\n   *\n   * @param {string} [options.id]\n   *        The internal id to assign this track.\n   *\n   * @param {string} [options.src]\n   *        A source url for the track.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n  ;\n\n  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.createRemoteTextTrack.call(this, options);\n    }\n\n    var htmlTrackElement = document.createElement('track');\n\n    if (options.kind) {\n      htmlTrackElement.kind = options.kind;\n    }\n\n    if (options.label) {\n      htmlTrackElement.label = options.label;\n    }\n\n    if (options.language || options.srclang) {\n      htmlTrackElement.srclang = options.language || options.srclang;\n    }\n\n    if (options[\"default\"]) {\n      htmlTrackElement[\"default\"] = options[\"default\"];\n    }\n\n    if (options.id) {\n      htmlTrackElement.id = options.id;\n    }\n\n    if (options.src) {\n      htmlTrackElement.src = options.src;\n    }\n\n    return htmlTrackElement;\n  }\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * @param {Object} options The object should contain values for\n   * kind, language, label, and src (location of the WebVTT file)\n   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   * automatically removed from the video element whenever the source changes\n   * @return {HTMLTrackElement} An Html Track Element.\n   * This can be an emulated {@link HTMLTrackElement} or a native one.\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   * to \"false\" in upcoming versions of Video.js\n   */\n  ;\n\n  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);\n\n    if (this.featuresNativeTextTracks) {\n      this.el().appendChild(htmlTrackElement);\n    }\n\n    return htmlTrackElement;\n  }\n  /**\n   * Remove remote `TextTrack` from `TextTrackList` object\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` object to remove\n   */\n  ;\n\n  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    _Tech.prototype.removeRemoteTextTrack.call(this, track);\n\n    if (this.featuresNativeTextTracks) {\n      var tracks = this.$$('track');\n      var i = tracks.length;\n\n      while (i--) {\n        if (track === tracks[i] || track === tracks[i].track) {\n          this.el().removeChild(tracks[i]);\n        }\n      }\n    }\n  }\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */\n  ;\n\n  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    if (typeof this.el().getVideoPlaybackQuality === 'function') {\n      return this.el().getVideoPlaybackQuality();\n    }\n\n    var videoPlaybackQuality = {};\n\n    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\n      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\n      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\n    }\n\n    if (window$1.performance && typeof window$1.performance.now === 'function') {\n      videoPlaybackQuality.creationTime = window$1.performance.now();\n    } else if (window$1.performance && window$1.performance.timing && typeof window$1.performance.timing.navigationStart === 'number') {\n      videoPlaybackQuality.creationTime = window$1.Date.now() - window$1.performance.timing.navigationStart;\n    }\n\n    return videoPlaybackQuality;\n  };\n\n  return Html5;\n}(Tech);\n/* HTML5 Support Testing ---------------------------------------------------- */\n\n/**\n * Element for testing browser HTML5 media capabilities\n *\n * @type {Element}\n * @constant\n * @private\n */\n\n\ndefineLazyProperty(Html5, 'TEST_VID', function () {\n  if (!isReal()) {\n    return;\n  }\n\n  var video = document.createElement('video');\n  var track = document.createElement('track');\n  track.kind = 'captions';\n  track.srclang = 'en';\n  track.label = 'English';\n  video.appendChild(track);\n  return video;\n});\n/**\n * Check if HTML5 media is supported by this browser/device.\n *\n * @return {boolean}\n *         - True if HTML5 media is supported.\n *         - False if HTML5 media is not supported.\n */\n\nHtml5.isSupported = function () {\n  // IE with no Media Player is a LIAR! (#984)\n  try {\n    Html5.TEST_VID.volume = 0.5;\n  } catch (e) {\n    return false;\n  }\n\n  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\n};\n/**\n * Check if the tech can support the given type\n *\n * @param {string} type\n *        The mimetype to check\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\n\n\nHtml5.canPlayType = function (type) {\n  return Html5.TEST_VID.canPlayType(type);\n};\n/**\n * Check if the tech can support the given source\n *\n * @param {Object} srcObj\n *        The source object\n * @param {Object} options\n *        The options passed to the tech\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\n\n\nHtml5.canPlaySource = function (srcObj, options) {\n  return Html5.canPlayType(srcObj.type);\n};\n/**\n * Check if the volume can be changed in this browser/device.\n * Volume cannot be changed in a lot of mobile devices.\n * Specifically, it can't be changed from 1 on iOS.\n *\n * @return {boolean}\n *         - True if volume can be controlled\n *         - False otherwise\n */\n\n\nHtml5.canControlVolume = function () {\n  // IE will error if Windows Media Player not installed #3315\n  try {\n    var volume = Html5.TEST_VID.volume;\n    Html5.TEST_VID.volume = volume / 2 + 0.1;\n    return volume !== Html5.TEST_VID.volume;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Check if the volume can be muted in this browser/device.\n * Some devices, e.g. iOS, don't allow changing volume\n * but permits muting/unmuting.\n *\n * @return {bolean}\n *      - True if volume can be muted\n *      - False otherwise\n */\n\n\nHtml5.canMuteVolume = function () {\n  try {\n    var muted = Html5.TEST_VID.muted; // in some versions of iOS muted property doesn't always\n    // work, so we want to set both property and attribute\n\n    Html5.TEST_VID.muted = !muted;\n\n    if (Html5.TEST_VID.muted) {\n      setAttribute(Html5.TEST_VID, 'muted', 'muted');\n    } else {\n      removeAttribute(Html5.TEST_VID, 'muted', 'muted');\n    }\n\n    return muted !== Html5.TEST_VID.muted;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Check if the playback rate can be changed in this browser/device.\n *\n * @return {boolean}\n *         - True if playback rate can be controlled\n *         - False otherwise\n */\n\n\nHtml5.canControlPlaybackRate = function () {\n  // Playback rate API is implemented in Android Chrome, but doesn't do anything\n  // https://github.com/videojs/video.js/issues/3180\n  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\n    return false;\n  } // IE will error if Windows Media Player not installed #3315\n\n\n  try {\n    var playbackRate = Html5.TEST_VID.playbackRate;\n    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\n    return playbackRate !== Html5.TEST_VID.playbackRate;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Check if we can override a video/audio elements attributes, with\n * Object.defineProperty.\n *\n * @return {boolean}\n *         - True if builtin attributes can be overridden\n *         - False otherwise\n */\n\n\nHtml5.canOverrideAttributes = function () {\n  // if we cannot overwrite the src/innerHTML property, there is no support\n  // iOS 7 safari for instance cannot do this.\n  try {\n    var noop = function noop() {};\n\n    Object.defineProperty(document.createElement('video'), 'src', {\n      get: noop,\n      set: noop\n    });\n    Object.defineProperty(document.createElement('audio'), 'src', {\n      get: noop,\n      set: noop\n    });\n    Object.defineProperty(document.createElement('video'), 'innerHTML', {\n      get: noop,\n      set: noop\n    });\n    Object.defineProperty(document.createElement('audio'), 'innerHTML', {\n      get: noop,\n      set: noop\n    });\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Check to see if native `TextTrack`s are supported by this browser/device.\n *\n * @return {boolean}\n *         - True if native `TextTrack`s are supported.\n *         - False otherwise\n */\n\n\nHtml5.supportsNativeTextTracks = function () {\n  return IS_ANY_SAFARI || IS_IOS && IS_CHROME;\n};\n/**\n * Check to see if native `VideoTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `VideoTrack`s are supported.\n *        - False otherwise\n */\n\n\nHtml5.supportsNativeVideoTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\n};\n/**\n * Check to see if native `AudioTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `AudioTrack`s are supported.\n *        - False otherwise\n */\n\n\nHtml5.supportsNativeAudioTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\n};\n/**\n * An array of events available on the Html5 tech.\n *\n * @private\n * @type {Array}\n */\n\n\nHtml5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\n/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default {@link Html5.canControlVolume}\n */\n\n/**\n * Boolean indicating whether the `Tech` supports muting volume.\n *\n * @type {bolean}\n * @default {@link Html5.canMuteVolume}\n */\n\n/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the media\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default {@link Html5.canControlPlaybackRate}\n */\n\n/**\n * Boolean indicating whether the `Tech` supports the `sourceset` event.\n *\n * @type {boolean}\n * @default\n */\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeTextTracks}\n */\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeVideoTracks}\n */\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeAudioTracks}\n */\n\n[['featuresVolumeControl', 'canControlVolume'], ['featuresMuteControl', 'canMuteVolume'], ['featuresPlaybackRate', 'canControlPlaybackRate'], ['featuresSourceset', 'canOverrideAttributes'], ['featuresNativeTextTracks', 'supportsNativeTextTracks'], ['featuresNativeVideoTracks', 'supportsNativeVideoTracks'], ['featuresNativeAudioTracks', 'supportsNativeAudioTracks']].forEach(function (_ref) {\n  var key = _ref[0],\n      fn = _ref[1];\n  defineLazyProperty(Html5.prototype, key, function () {\n    return Html5[fn]();\n  }, true);\n});\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the media element\n * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n * false there. Everywhere else this should be true.\n *\n * @type {boolean}\n * @default\n */\n\nHtml5.prototype.movingMediaElementInDOM = !IS_IOS; // TODO: Previous comment: No longer appears to be used. Can probably be removed.\n//       Is this true?\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n * when going into fullscreen.\n *\n * @type {boolean}\n * @default\n */\n\nHtml5.prototype.featuresFullscreenResize = true;\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n * If this is false, manual `progress` events will be triggered instead.\n *\n * @type {boolean}\n * @default\n */\n\nHtml5.prototype.featuresProgressEvents = true;\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n * If this is false, manual `timeupdate` events will be triggered instead.\n *\n * @default\n */\n\nHtml5.prototype.featuresTimeupdateEvents = true; // HTML5 Feature detection and Device Fixes --------------------------------- //\n\nvar canPlayType;\n\nHtml5.patchCanPlayType = function () {\n  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so\n  // Firefox and Chrome report correctly\n  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX && !IS_CHROME) {\n    canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;\n\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\n      var mpegurlRE = /^application\\/(?:x-|vnd\\.apple\\.)mpegurl/i;\n\n      if (type && mpegurlRE.test(type)) {\n        return 'maybe';\n      }\n\n      return canPlayType.call(this, type);\n    };\n  }\n};\n\nHtml5.unpatchCanPlayType = function () {\n  var r = Html5.TEST_VID.constructor.prototype.canPlayType;\n\n  if (canPlayType) {\n    Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;\n  }\n\n  return r;\n}; // by default, patch the media element\n\n\nHtml5.patchCanPlayType();\n\nHtml5.disposeMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  } // remove any child track or source nodes to prevent their loading\n\n\n  while (el.hasChildNodes()) {\n    el.removeChild(el.firstChild);\n  } // remove any src reference. not setting `src=''` because that causes a warning\n  // in firefox\n\n\n  el.removeAttribute('src'); // force the media element to update its loading state by calling load()\n  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\n\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {// not supported\n      }\n    })();\n  }\n};\n\nHtml5.resetMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  var sources = el.querySelectorAll('source');\n  var i = sources.length;\n\n  while (i--) {\n    el.removeChild(sources[i]);\n  } // remove any src reference.\n  // not setting `src=''` because that throws an error\n\n\n  el.removeAttribute('src');\n\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {// satisfy linter\n      }\n    })();\n  }\n};\n/* Native HTML5 element property wrapping ----------------------------------- */\n// Wrap native boolean attributes with getters that check both property and attribute\n// The list is as followed:\n// muted, defaultMuted, autoplay, controls, loop, playsinline\n\n\n[\n/**\n * Get the value of `muted` from the media element. `muted` indicates\n * that the volume for the media should be set to silent. This does not actually change\n * the `volume` attribute.\n *\n * @method Html5#muted\n * @return {boolean}\n *         - True if the value of `volume` should be ignored and the audio set to silent.\n *         - False if the value of `volume` should be used.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n/**\n * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n * current state.\n *\n * @method Html5#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the media element.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n/**\n * Get the value of `autoplay` from the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the media element.\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n/**\n * Get the value of `controls` from the media element. `controls` indicates\n * whether the native media controls should be shown or hidden.\n *\n * @method Html5#controls\n * @return {boolean}\n *         - The value of `controls` from the media element.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n */\n'controls',\n/**\n * Get the value of `loop` from the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#loop\n * @return {boolean}\n *         - The value of `loop` from the media element.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n/**\n * Get the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#playsinline\n * @return {boolean}\n *         - The value of `playsinline` from the media element.\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop] || this.el_.hasAttribute(prop);\n  };\n}); // Wrap native boolean attributes with setters that set both property and attribute\n// The list is as followed:\n// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n// setControls is special-cased above\n\n[\n/**\n * Set the value of `muted` on the media element. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Html5#setMuted\n * @param {boolean} muted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n/**\n * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n * audio level should be silent, but will only effect the muted level on initial playback..\n *\n * @method Html5.prototype.setDefaultMuted\n * @param {boolean} defaultMuted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n/**\n * Set the value of `autoplay` on the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#setAutoplay\n * @param {boolean} autoplay\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n/**\n * Set the value of `loop` on the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#setLoop\n * @param {boolean} loop\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n/**\n * Set the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#setPlaysinline\n * @param {boolean} playsinline\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n\n    if (v) {\n      this.el_.setAttribute(prop, prop);\n    } else {\n      this.el_.removeAttribute(prop);\n    }\n  };\n}); // Wrap native properties with a getter\n// The list is as followed\n// paused, currentTime, buffered, volume, poster, preload, error, seeking\n// seekable, ended, playbackRate, defaultPlaybackRate, disablePictureInPicture\n// played, networkState, readyState, videoWidth, videoHeight, crossOrigin\n\n[\n/**\n * Get the value of `paused` from the media element. `paused` indicates whether the media element\n * is currently paused or not.\n *\n * @method Html5#paused\n * @return {boolean}\n *         The value of `paused` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n */\n'paused',\n/**\n * Get the value of `currentTime` from the media element. `currentTime` indicates\n * the current second that the media is at in playback.\n *\n * @method Html5#currentTime\n * @return {number}\n *         The value of `currentTime` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n */\n'currentTime',\n/**\n * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n * object that represents the parts of the media that are already downloaded and\n * available for playback.\n *\n * @method Html5#buffered\n * @return {TimeRange}\n *         The value of `buffered` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n */\n'buffered',\n/**\n * Get the value of `volume` from the media element. `volume` indicates\n * the current playback volume of audio for a media. `volume` will be a value from 0\n * (silent) to 1 (loudest and default).\n *\n * @method Html5#volume\n * @return {number}\n *         The value of `volume` from the media element. Value will be between 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n/**\n * Get the value of `poster` from the media element. `poster` indicates\n * that the url of an image file that can/will be shown when no media data is available.\n *\n * @method Html5#poster\n * @return {string}\n *         The value of `poster` from the media element. Value will be a url to an\n *         image.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n */\n'poster',\n/**\n * Get the value of `preload` from the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#preload\n * @return {string}\n *         The value of `preload` from the media element. Will be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n/**\n * Get the value of the `error` from the media element. `error` indicates any\n * MediaError that may have occurred during playback. If error returns null there is no\n * current error.\n *\n * @method Html5#error\n * @return {MediaError|null}\n *         The value of `error` from the media element. Will be `MediaError` if there\n *         is a current error and null otherwise.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n */\n'error',\n/**\n * Get the value of `seeking` from the media element. `seeking` indicates whether the\n * media is currently seeking to a new position or not.\n *\n * @method Html5#seeking\n * @return {boolean}\n *         - The value of `seeking` from the media element.\n *         - True indicates that the media is currently seeking to a new position.\n *         - False indicates that the media is not seeking to a new position at this time.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n */\n'seeking',\n/**\n * Get the value of `seekable` from the media element. `seekable` returns a\n * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n *\n * @method Html5#seekable\n * @return {TimeRange}\n *         The value of `seekable` from the media element. A `TimeRange` object\n *         indicating the current ranges of time that can be seeked to.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n */\n'seekable',\n/**\n * Get the value of `ended` from the media element. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Html5#ended\n * @return {boolean}\n *         - The value of `ended` from the media element.\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */\n'ended',\n/**\n * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n/**\n * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n * the rate at which the media is currently playing back. This value will not indicate the current\n * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n *\n * Examples:\n *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.defaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'defaultPlaybackRate',\n/**\n * Get the value of 'disablePictureInPicture' from the video element.\n *\n * @method Html5#disablePictureInPicture\n * @return {boolean} value\n *         - The value of `disablePictureInPicture` from the video element.\n *         - True indicates that the video can't be played in Picture-In-Picture mode\n *         - False indicates that the video can be played in Picture-In-Picture mode\n *\n * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n */\n'disablePictureInPicture',\n/**\n * Get the value of `played` from the media element. `played` returns a `TimeRange`\n * object representing points in the media timeline that have been played.\n *\n * @method Html5#played\n * @return {TimeRange}\n *         The value of `played` from the media element. A `TimeRange` object indicating\n *         the ranges of time that have been played.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n */\n'played',\n/**\n * Get the value of `networkState` from the media element. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NETWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Html5#networkState\n * @return {number}\n *         The value of `networkState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n */\n'networkState',\n/**\n * Get the value of `readyState` from the media element. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Html5#readyState\n * @return {number}\n *         The value of `readyState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n */\n'readyState',\n/**\n * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n * the current width of the video in css pixels.\n *\n * @method Html5#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoWidth',\n/**\n * Get the value of `videoHeight` from the video element. `videoHeight` indicates\n * the current height of the video in css pixels.\n *\n * @method Html5#videoHeight\n * @return {number}\n *         The value of `videoHeight` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoHeight',\n/**\n * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates\n * to the browser that should sent the cookies along with the requests for the\n * different assets/playlists\n *\n * @method Html5#crossOrigin\n * @return {string}\n *         - anonymous indicates that the media should not sent cookies.\n *         - use-credentials indicates that the media should sent cookies along the requests.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n */\n'crossOrigin'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop];\n  };\n}); // Wrap native properties with a setter in this format:\n// set + toTitleCase(name)\n// The list is as follows:\n// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate,\n// setDisablePictureInPicture, setCrossOrigin\n\n[\n/**\n * Set the value of `volume` on the media element. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Html5#setVolume\n * @param {number} percentAsDecimal\n *        The volume percent as a decimal. Valid range is from 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n/**\n * Set the value of `src` on the media element. `src` indicates the current\n * {@link Tech~SourceObject} for the media.\n *\n * @method Html5#setSrc\n * @param {Tech~SourceObject} src\n *        The source object to set as the current source.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n */\n'src',\n/**\n * Set the value of `poster` on the media element. `poster` is the url to\n * an image file that can/will be shown when no media data is available.\n *\n * @method Html5#setPoster\n * @param {string} poster\n *        The url to an image that should be used as the `poster` for the media\n *        element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n */\n'poster',\n/**\n * Set the value of `preload` on the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#setPreload\n * @param {string} preload\n *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n/**\n * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n * the rate at which the media should play back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#setPlaybackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n/**\n * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n * the rate at which the media should play back upon initial startup. Changing this value\n * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n *\n * Example Values:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.setDefaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n */\n'defaultPlaybackRate',\n/**\n * Prevents the browser from suggesting a Picture-in-Picture context menu\n * or to request Picture-in-Picture automatically in some cases.\n *\n * @method Html5#setDisablePictureInPicture\n * @param {boolean} value\n *         The true value will disable Picture-in-Picture mode.\n *\n * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n */\n'disablePictureInPicture',\n/**\n * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates\n * to the browser that should sent the cookies along with the requests for the\n * different assets/playlists\n *\n * @method Html5#setCrossOrigin\n * @param {string} crossOrigin\n *         - anonymous indicates that the media should not sent cookies.\n *         - use-credentials indicates that the media should sent cookies along the requests.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n */\n'crossOrigin'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n  };\n}); // wrap native functions with a function\n// The list is as follows:\n// pause, load, play\n\n[\n/**\n * A wrapper around the media elements `pause` function. This will call the `HTML5`\n * media elements `pause` function.\n *\n * @method Html5#pause\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n */\n'pause',\n/**\n * A wrapper around the media elements `load` function. This will call the `HTML5`s\n * media element `load` function.\n *\n * @method Html5#load\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n */\n'load',\n/**\n * A wrapper around the media elements `play` function. This will call the `HTML5`s\n * media element `play` function.\n *\n * @method Html5#play\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n */\n'play'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop]();\n  };\n});\nTech.withSourceHandlers(Html5);\n/**\n * Native source handler for Html5, simply passes the source to the media element.\n *\n * @property {Tech~SourceObject} source\n *        The source object\n *\n * @property {Html5} tech\n *        The instance of the HTML5 tech.\n */\n\nHtml5.nativeSourceHandler = {};\n/**\n * Check if the media element can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string)\n */\n\nHtml5.nativeSourceHandler.canPlayType = function (type) {\n  // IE without MediaPlayer throws an error (#519)\n  try {\n    return Html5.TEST_VID.canPlayType(type);\n  } catch (e) {\n    return '';\n  }\n};\n/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string).\n */\n\n\nHtml5.nativeSourceHandler.canHandleSource = function (source, options) {\n  // If a type was provided we should rely on that\n  if (source.type) {\n    return Html5.nativeSourceHandler.canPlayType(source.type); // If no type, fall back to checking 'video/[EXTENSION]'\n  } else if (source.src) {\n    var ext = getFileExtension(source.src);\n    return Html5.nativeSourceHandler.canPlayType(\"video/\" + ext);\n  }\n\n  return '';\n};\n/**\n * Pass the source to the native media element.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Html5} tech\n *        The instance of the Html5 tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */\n\n\nHtml5.nativeSourceHandler.handleSource = function (source, tech, options) {\n  tech.setSrc(source.src);\n};\n/**\n * A noop for the native dispose function, as cleanup is not needed.\n */\n\n\nHtml5.nativeSourceHandler.dispose = function () {}; // Register the native source handler\n\n\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);\nTech.registerTech('Html5', Html5); // on the player when they happen\n\nvar TECH_EVENTS_RETRIGGER = [\n/**\n * Fired while the user agent is downloading media data.\n *\n * @event Player#progress\n * @type {EventTarget~Event}\n */\n\n/**\n * Retrigger the `progress` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechProgress_\n * @fires Player#progress\n * @listens Tech#progress\n */\n'progress',\n/**\n * Fires when the loading of an audio/video is aborted.\n *\n * @event Player#abort\n * @type {EventTarget~Event}\n */\n\n/**\n * Retrigger the `abort` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechAbort_\n * @fires Player#abort\n * @listens Tech#abort\n */\n'abort',\n/**\n * Fires when the browser is intentionally not getting media data.\n *\n * @event Player#suspend\n * @type {EventTarget~Event}\n */\n\n/**\n * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechSuspend_\n * @fires Player#suspend\n * @listens Tech#suspend\n */\n'suspend',\n/**\n * Fires when the current playlist is empty.\n *\n * @event Player#emptied\n * @type {EventTarget~Event}\n */\n\n/**\n * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechEmptied_\n * @fires Player#emptied\n * @listens Tech#emptied\n */\n'emptied',\n/**\n * Fires when the browser is trying to get media data, but data is not available.\n *\n * @event Player#stalled\n * @type {EventTarget~Event}\n */\n\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechStalled_\n * @fires Player#stalled\n * @listens Tech#stalled\n */\n'stalled',\n/**\n * Fires when the browser has loaded meta data for the audio/video.\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoadedmetadata_\n * @fires Player#loadedmetadata\n * @listens Tech#loadedmetadata\n */\n'loadedmetadata',\n/**\n * Fires when the browser has loaded the current frame of the audio/video.\n *\n * @event Player#loadeddata\n * @type {event}\n */\n\n/**\n * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoaddeddata_\n * @fires Player#loadeddata\n * @listens Tech#loadeddata\n */\n'loadeddata',\n/**\n * Fires when the current playback position has changed.\n *\n * @event Player#timeupdate\n * @type {event}\n */\n\n/**\n * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTimeUpdate_\n * @fires Player#timeupdate\n * @listens Tech#timeupdate\n */\n'timeupdate',\n/**\n * Fires when the video's intrinsic dimensions change\n *\n * @event Player#resize\n * @type {event}\n */\n\n/**\n * Retrigger the `resize` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechResize_\n * @fires Player#resize\n * @listens Tech#resize\n */\n'resize',\n/**\n * Fires when the volume has been changed\n *\n * @event Player#volumechange\n * @type {event}\n */\n\n/**\n * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechVolumechange_\n * @fires Player#volumechange\n * @listens Tech#volumechange\n */\n'volumechange',\n/**\n * Fires when the text track has been changed\n *\n * @event Player#texttrackchange\n * @type {event}\n */\n\n/**\n * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTexttrackchange_\n * @fires Player#texttrackchange\n * @listens Tech#texttrackchange\n */\n'texttrackchange']; // events to queue when playback rate is zero\n// this is a hash for the sole purpose of mapping non-camel-cased event names\n// to camel-cased function names\n\nvar TECH_EVENTS_QUEUE = {\n  canplay: 'CanPlay',\n  canplaythrough: 'CanPlayThrough',\n  playing: 'Playing',\n  seeked: 'Seeked'\n};\nvar BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];\nvar BREAKPOINT_CLASSES = {}; // grep: vjs-layout-tiny\n// grep: vjs-layout-x-small\n// grep: vjs-layout-small\n// grep: vjs-layout-medium\n// grep: vjs-layout-large\n// grep: vjs-layout-x-large\n// grep: vjs-layout-huge\n\nBREAKPOINT_ORDER.forEach(function (k) {\n  var v = k.charAt(0) === 'x' ? \"x-\" + k.substring(1) : k;\n  BREAKPOINT_CLASSES[k] = \"vjs-layout-\" + v;\n});\nvar DEFAULT_BREAKPOINTS = {\n  tiny: 210,\n  xsmall: 320,\n  small: 425,\n  medium: 768,\n  large: 1440,\n  xlarge: 2560,\n  huge: Infinity\n};\n/**\n * An instance of the `Player` class is created when any of the Video.js setup methods\n * are used to initialize a video.\n *\n * After an instance has been created it can be accessed globally in two ways:\n * 1. By calling `videojs('example_video_1');`\n * 2. By using it directly via  `videojs.players.example_video_1;`\n *\n * @extends Component\n */\n\nvar Player = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Player, _Component);\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Element} tag\n   *        The original video DOM element used for configuring options.\n   *\n   * @param {Object} [options]\n   *        Object of option names and values.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Ready callback function.\n   */\n\n\n  function Player(tag, options, ready) {\n    var _this; // Make sure tag ID exists\n\n\n    tag.id = tag.id || options.id || \"vjs_video_\" + newGUID(); // Set Options\n    // The options argument overrides options set in the video tag\n    // which overrides globally set options.\n    // This latter part coincides with the load order\n    // (tag must exist before Player)\n\n    options = assign(Player.getTagSettings(tag), options); // Delay the initialization of children because we need to set up\n    // player properties first, and can't use `this` before `super()`\n\n    options.initChildren = false; // Same with creating the element\n\n    options.createEl = false; // don't auto mixin the evented mixin\n\n    options.evented = false; // we don't want the player to report touch activity on itself\n    // see enableTouchActivity in Component\n\n    options.reportTouchActivity = false; // If language is not set, get the closest lang attribute\n\n    if (!options.language) {\n      if (typeof tag.closest === 'function') {\n        var closest = tag.closest('[lang]');\n\n        if (closest && closest.getAttribute) {\n          options.language = closest.getAttribute('lang');\n        }\n      } else {\n        var element = tag;\n\n        while (element && element.nodeType === 1) {\n          if (getAttributes(element).hasOwnProperty('lang')) {\n            options.language = element.getAttribute('lang');\n            break;\n          }\n\n          element = element.parentNode;\n        }\n      }\n    } // Run base component initializing with new options\n\n\n    _this = _Component.call(this, null, options, ready) || this; // Create bound methods for document listeners.\n\n    _this.boundDocumentFullscreenChange_ = bind(_assertThisInitialized(_this), _this.documentFullscreenChange_);\n    _this.boundFullWindowOnEscKey_ = bind(_assertThisInitialized(_this), _this.fullWindowOnEscKey); // default isFullscreen_ to false\n\n    _this.isFullscreen_ = false; // create logger\n\n    _this.log = createLogger$1(_this.id_); // Hold our own reference to fullscreen api so it can be mocked in tests\n\n    _this.fsApi_ = FullscreenApi; // Tracks when a tech changes the poster\n\n    _this.isPosterFromTech_ = false; // Holds callback info that gets queued when playback rate is zero\n    // and a seek is happening\n\n    _this.queuedCallbacks_ = []; // Turn off API access because we're loading a new tech that might load asynchronously\n\n    _this.isReady_ = false; // Init state hasStarted_\n\n    _this.hasStarted_ = false; // Init state userActive_\n\n    _this.userActive_ = false; // Init debugEnabled_\n\n    _this.debugEnabled_ = false; // if the global option object was accidentally blown away by\n    // someone, bail early with an informative error\n\n    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {\n      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\n    } // Store the original tag used to set options\n\n\n    _this.tag = tag; // Store the tag attributes used to restore html5 element\n\n    _this.tagAttributes = tag && getAttributes(tag); // Update current language\n\n    _this.language(_this.options_.language); // Update Supported Languages\n\n\n    if (options.languages) {\n      // Normalise player option languages to lowercase\n      var languagesToLower = {};\n      Object.getOwnPropertyNames(options.languages).forEach(function (name) {\n        languagesToLower[name.toLowerCase()] = options.languages[name];\n      });\n      _this.languages_ = languagesToLower;\n    } else {\n      _this.languages_ = Player.prototype.options_.languages;\n    }\n\n    _this.resetCache_(); // Set poster\n\n\n    _this.poster_ = options.poster || ''; // Set controls\n\n    _this.controls_ = !!options.controls; // Original tag settings stored in options\n    // now remove immediately so native controls don't flash.\n    // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n\n    tag.controls = false;\n    tag.removeAttribute('controls');\n    _this.changingSrc_ = false;\n    _this.playCallbacks_ = [];\n    _this.playTerminatedQueue_ = []; // the attribute overrides the option\n\n    if (tag.hasAttribute('autoplay')) {\n      _this.autoplay(true);\n    } else {\n      // otherwise use the setter to validate and\n      // set the correct value.\n      _this.autoplay(_this.options_.autoplay);\n    } // check plugins\n\n\n    if (options.plugins) {\n      Object.keys(options.plugins).forEach(function (name) {\n        if (typeof _this[name] !== 'function') {\n          throw new Error(\"plugin \\\"\" + name + \"\\\" does not exist\");\n        }\n      });\n    }\n    /*\n     * Store the internal state of scrubbing\n     *\n     * @private\n     * @return {Boolean} True if the user is scrubbing\n     */\n\n\n    _this.scrubbing_ = false;\n    _this.el_ = _this.createEl(); // Make this an evented object and use `el_` as its event bus.\n\n    evented(_assertThisInitialized(_this), {\n      eventBusKey: 'el_'\n    }); // listen to document and player fullscreenchange handlers so we receive those events\n    // before a user can receive them so we can update isFullscreen appropriately.\n    // make sure that we listen to fullscreenchange events before everything else to make sure that\n    // our isFullscreen method is updated properly for internal components as well as external.\n\n    if (_this.fsApi_.requestFullscreen) {\n      on(document, _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);\n\n      _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);\n    }\n\n    if (_this.fluid_) {\n      _this.on('playerreset', _this.updateStyleEl_);\n    } // We also want to pass the original player options to each component and plugin\n    // as well so they don't need to reach back into the player for options later.\n    // We also need to do another copy of this.options_ so we don't end up with\n    // an infinite loop.\n\n\n    var playerOptionsCopy = mergeOptions(_this.options_); // Load plugins\n\n    if (options.plugins) {\n      Object.keys(options.plugins).forEach(function (name) {\n        _this[name](options.plugins[name]);\n      });\n    } // Enable debug mode to fire debugon event for all plugins.\n\n\n    if (options.debug) {\n      _this.debug(true);\n    }\n\n    _this.options_.playerOptions = playerOptionsCopy;\n    _this.middleware_ = [];\n\n    _this.initChildren(); // Set isAudio based on whether or not an audio tag was used\n\n\n    _this.isAudio(tag.nodeName.toLowerCase() === 'audio'); // Update controls className. Can't do this when the controls are initially\n    // set because the element doesn't exist yet.\n\n\n    if (_this.controls()) {\n      _this.addClass('vjs-controls-enabled');\n    } else {\n      _this.addClass('vjs-controls-disabled');\n    } // Set ARIA label and region role depending on player type\n\n\n    _this.el_.setAttribute('role', 'region');\n\n    if (_this.isAudio()) {\n      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));\n    } else {\n      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));\n    }\n\n    if (_this.isAudio()) {\n      _this.addClass('vjs-audio');\n    }\n\n    if (_this.flexNotSupported_()) {\n      _this.addClass('vjs-no-flex');\n    } // TODO: Make this smarter. Toggle user state between touching/mousing\n    // using events, since devices can have both touch and mouse events.\n    // TODO: Make this check be performed again when the window switches between monitors\n    // (See https://github.com/videojs/video.js/issues/5683)\n\n\n    if (TOUCH_ENABLED) {\n      _this.addClass('vjs-touch-enabled');\n    } // iOS Safari has broken hover handling\n\n\n    if (!IS_IOS) {\n      _this.addClass('vjs-workinghover');\n    } // Make player easily findable by ID\n\n\n    Player.players[_this.id_] = _assertThisInitialized(_this); // Add a major version class to aid css in plugins\n\n    var majorVersion = version.split('.')[0];\n\n    _this.addClass(\"vjs-v\" + majorVersion); // When the player is first initialized, trigger activity so components\n    // like the control bar show themselves if needed\n\n\n    _this.userActive(true);\n\n    _this.reportUserActivity();\n\n    _this.one('play', _this.listenForUserActivity_);\n\n    _this.on('stageclick', _this.handleStageClick_);\n\n    _this.on('keydown', _this.handleKeyDown);\n\n    _this.breakpoints(_this.options_.breakpoints);\n\n    _this.responsive(_this.options_.responsive);\n\n    return _this;\n  }\n  /**\n   * Destroys the video player and does any necessary cleanup.\n   *\n   * This is especially helpful if you are dynamically adding and removing videos\n   * to/from the DOM.\n   *\n   * @fires Player#dispose\n   */\n\n\n  var _proto = Player.prototype;\n\n  _proto.dispose = function dispose() {\n    var _this2 = this;\n    /**\n     * Called when the player is being disposed of.\n     *\n     * @event Player#dispose\n     * @type {EventTarget~Event}\n     */\n\n\n    this.trigger('dispose'); // prevent dispose from being called twice\n\n    this.off('dispose'); // Make sure all player-specific document listeners are unbound. This is\n\n    off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n    off(document, 'keydown', this.boundFullWindowOnEscKey_);\n\n    if (this.styleEl_ && this.styleEl_.parentNode) {\n      this.styleEl_.parentNode.removeChild(this.styleEl_);\n      this.styleEl_ = null;\n    } // Kill reference to this player\n\n\n    Player.players[this.id_] = null;\n\n    if (this.tag && this.tag.player) {\n      this.tag.player = null;\n    }\n\n    if (this.el_ && this.el_.player) {\n      this.el_.player = null;\n    }\n\n    if (this.tech_) {\n      this.tech_.dispose();\n      this.isPosterFromTech_ = false;\n      this.poster_ = '';\n    }\n\n    if (this.playerElIngest_) {\n      this.playerElIngest_ = null;\n    }\n\n    if (this.tag) {\n      this.tag = null;\n    }\n\n    clearCacheForPlayer(this); // remove all event handlers for track lists\n    // all tracks and track listeners are removed on\n    // tech dispose\n\n    ALL.names.forEach(function (name) {\n      var props = ALL[name];\n\n      var list = _this2[props.getterName](); // if it is not a native list\n      // we have to manually remove event listeners\n\n\n      if (list && list.off) {\n        list.off();\n      }\n    }); // the actual .el_ is removed here\n\n    _Component.prototype.dispose.call(this);\n  }\n  /**\n   * Create the `Player`'s DOM element.\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n  ;\n\n  _proto.createEl = function createEl() {\n    var tag = this.tag;\n    var el;\n    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\n    var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\n\n    if (playerElIngest) {\n      el = this.el_ = tag.parentNode;\n    } else if (!divEmbed) {\n      el = this.el_ = _Component.prototype.createEl.call(this, 'div');\n    } // Copy over all the attributes from the tag, including ID and class\n    // ID will now reference player box, not the video tag\n\n\n    var attrs = getAttributes(tag);\n\n    if (divEmbed) {\n      el = this.el_ = tag;\n      tag = this.tag = document.createElement('video');\n\n      while (el.children.length) {\n        tag.appendChild(el.firstChild);\n      }\n\n      if (!hasClass(el, 'video-js')) {\n        addClass(el, 'video-js');\n      }\n\n      el.appendChild(tag);\n      playerElIngest = this.playerElIngest_ = el; // move properties over from our custom `video-js` element\n      // to our new `video` element. This will move things like\n      // `src` or `controls` that were set via js before the player\n      // was initialized.\n\n      Object.keys(el).forEach(function (k) {\n        try {\n          tag[k] = el[k];\n        } catch (e) {// we got a a property like outerHTML which we can't actually copy, ignore it\n        }\n      });\n    } // set tabindex to -1 to remove the video element from the focus order\n\n\n    tag.setAttribute('tabindex', '-1');\n    attrs.tabindex = '-1'; // Workaround for #4583 (JAWS+IE doesn't announce BPB or play button), and\n    // for the same issue with Chrome (on Windows) with JAWS.\n    // See https://github.com/FreedomScientific/VFO-standards-support/issues/78\n    // Note that we can't detect if JAWS is being used, but this ARIA attribute\n    //  doesn't change behavior of IE11 or Chrome if JAWS is not being used\n\n    if (IE_VERSION || IS_CHROME && IS_WINDOWS) {\n      tag.setAttribute('role', 'application');\n      attrs.role = 'application';\n    } // Remove width/height attrs from tag so CSS can make it 100% width/height\n\n\n    tag.removeAttribute('width');\n    tag.removeAttribute('height');\n\n    if ('width' in attrs) {\n      delete attrs.width;\n    }\n\n    if ('height' in attrs) {\n      delete attrs.height;\n    }\n\n    Object.getOwnPropertyNames(attrs).forEach(function (attr) {\n      // don't copy over the class attribute to the player element when we're in a div embed\n      // the class is already set up properly in the divEmbed case\n      // and we want to make sure that the `video-js` class doesn't get lost\n      if (!(divEmbed && attr === 'class')) {\n        el.setAttribute(attr, attrs[attr]);\n      }\n\n      if (divEmbed) {\n        tag.setAttribute(attr, attrs[attr]);\n      }\n    }); // Update tag id/class for use as HTML5 playback tech\n    // Might think we should do this after embedding in container so .vjs-tech class\n    // doesn't flash 100% width/height, but class only applies with .video-js parent\n\n    tag.playerId = tag.id;\n    tag.id += '_html5_api';\n    tag.className = 'vjs-tech'; // Make player findable on elements\n\n    tag.player = el.player = this; // Default state of video is paused\n\n    this.addClass('vjs-paused'); // Add a style element in the player that we'll use to set the width/height\n    // of the player in a way that's still overrideable by CSS, just like the\n    // video element\n\n    if (window$1.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\n      this.styleEl_ = createStyleElement('vjs-styles-dimensions');\n      var defaultsStyleEl = $('.vjs-styles-defaults');\n      var head = $('head');\n      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\n    }\n\n    this.fill_ = false;\n    this.fluid_ = false; // Pass in the width/height/aspectRatio options which will update the style el\n\n    this.width(this.options_.width);\n    this.height(this.options_.height);\n    this.fill(this.options_.fill);\n    this.fluid(this.options_.fluid);\n    this.aspectRatio(this.options_.aspectRatio); // support both crossOrigin and crossorigin to reduce confusion and issues around the name\n\n    this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin); // Hide any links within the video/audio tag,\n    // because IE doesn't hide them completely from screen readers.\n\n    var links = tag.getElementsByTagName('a');\n\n    for (var i = 0; i < links.length; i++) {\n      var linkEl = links.item(i);\n      addClass(linkEl, 'vjs-hidden');\n      linkEl.setAttribute('hidden', 'hidden');\n    } // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n    // keep track of the original for later so we can know if the source originally failed\n\n\n    tag.initNetworkState_ = tag.networkState; // Wrap video tag in div (el/box) container\n\n    if (tag.parentNode && !playerElIngest) {\n      tag.parentNode.insertBefore(el, tag);\n    } // insert the tag as the first child of the player element\n    // then manually add it to the children array so that this.addChild\n    // will work properly for other components\n    //\n    // Breaks iPhone, fixed in HTML5 setup.\n\n\n    prependTo(tag, el);\n    this.children_.unshift(tag); // Set lang attr on player to ensure CSS :lang() in consistent with player\n    // if it's been set to something different to the doc\n\n    this.el_.setAttribute('lang', this.language_);\n    this.el_ = el;\n    return el;\n  }\n  /**\n   * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this\n   * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n   * behavior.\n   *\n   * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n   *\n   * @param {string} [value]\n   *        The value to set the `Player`'s crossOrigin to. If an argument is\n   *        given, must be one of `anonymous` or `use-credentials`.\n   *\n   * @return {string|undefined}\n   *         - The current crossOrigin value of the `Player` when getting.\n   *         - undefined when setting\n   */\n  ;\n\n  _proto.crossOrigin = function crossOrigin(value) {\n    if (!value) {\n      return this.techGet_('crossOrigin');\n    }\n\n    if (value !== 'anonymous' && value !== 'use-credentials') {\n      log.warn(\"crossOrigin must be \\\"anonymous\\\" or \\\"use-credentials\\\", given \\\"\" + value + \"\\\"\");\n      return;\n    }\n\n    this.techCall_('setCrossOrigin', value);\n    return;\n  }\n  /**\n   * A getter/setter for the `Player`'s width. Returns the player's configured value.\n   * To get the current width use `currentWidth()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s width to.\n   *\n   * @return {number}\n   *         The current width of the `Player` when getting.\n   */\n  ;\n\n  _proto.width = function width(value) {\n    return this.dimension('width', value);\n  }\n  /**\n   * A getter/setter for the `Player`'s height. Returns the player's configured value.\n   * To get the current height use `currentheight()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s heigth to.\n   *\n   * @return {number}\n   *         The current height of the `Player` when getting.\n   */\n  ;\n\n  _proto.height = function height(value) {\n    return this.dimension('height', value);\n  }\n  /**\n   * A getter/setter for the `Player`'s width & height.\n   *\n   * @param {string} dimension\n   *        This string can be:\n   *        - 'width'\n   *        - 'height'\n   *\n   * @param {number} [value]\n   *        Value for dimension specified in the first argument.\n   *\n   * @return {number}\n   *         The dimension arguments value when getting (width/height).\n   */\n  ;\n\n  _proto.dimension = function dimension(_dimension, value) {\n    var privDimension = _dimension + '_';\n\n    if (value === undefined) {\n      return this[privDimension] || 0;\n    }\n\n    if (value === '' || value === 'auto') {\n      // If an empty string is given, reset the dimension to be automatic\n      this[privDimension] = undefined;\n      this.updateStyleEl_();\n      return;\n    }\n\n    var parsedVal = parseFloat(value);\n\n    if (isNaN(parsedVal)) {\n      log.error(\"Improper value \\\"\" + value + \"\\\" supplied for for \" + _dimension);\n      return;\n    }\n\n    this[privDimension] = parsedVal;\n    this.updateStyleEl_();\n  }\n  /**\n   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n   *\n   * Turning this on will turn off fill mode.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will be a getter.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */\n  ;\n\n  _proto.fluid = function fluid(bool) {\n    if (bool === undefined) {\n      return !!this.fluid_;\n    }\n\n    this.fluid_ = !!bool;\n\n    if (isEvented(this)) {\n      this.off('playerreset', this.updateStyleEl_);\n    }\n\n    if (bool) {\n      this.addClass('vjs-fluid');\n      this.fill(false);\n      addEventedCallback(function () {\n        this.on('playerreset', this.updateStyleEl_);\n      });\n    } else {\n      this.removeClass('vjs-fluid');\n    }\n\n    this.updateStyleEl_();\n  }\n  /**\n   * A getter/setter/toggler for the vjs-fill `className` on the `Player`.\n   *\n   * Turning this on will turn off fluid mode.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will be a getter.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */\n  ;\n\n  _proto.fill = function fill(bool) {\n    if (bool === undefined) {\n      return !!this.fill_;\n    }\n\n    this.fill_ = !!bool;\n\n    if (bool) {\n      this.addClass('vjs-fill');\n      this.fluid(false);\n    } else {\n      this.removeClass('vjs-fill');\n    }\n  }\n  /**\n   * Get/Set the aspect ratio\n   *\n   * @param {string} [ratio]\n   *        Aspect ratio for player\n   *\n   * @return {string|undefined}\n   *         returns the current aspect ratio when getting\n   */\n\n  /**\n   * A getter/setter for the `Player`'s aspect ratio.\n   *\n   * @param {string} [ratio]\n   *        The value to set the `Player`'s aspect ratio to.\n   *\n   * @return {string|undefined}\n   *         - The current aspect ratio of the `Player` when getting.\n   *         - undefined when setting\n   */\n  ;\n\n  _proto.aspectRatio = function aspectRatio(ratio) {\n    if (ratio === undefined) {\n      return this.aspectRatio_;\n    } // Check for width:height format\n\n\n    if (!/^\\d+\\:\\d+$/.test(ratio)) {\n      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\n    }\n\n    this.aspectRatio_ = ratio; // We're assuming if you set an aspect ratio you want fluid mode,\n    // because in fixed mode you could calculate width and height yourself.\n\n    this.fluid(true);\n    this.updateStyleEl_();\n  }\n  /**\n   * Update styles of the `Player` element (height, width and aspect ratio).\n   *\n   * @private\n   * @listens Tech#loadedmetadata\n   */\n  ;\n\n  _proto.updateStyleEl_ = function updateStyleEl_() {\n    if (window$1.VIDEOJS_NO_DYNAMIC_STYLE === true) {\n      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\n\n      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\n\n      var techEl = this.tech_ && this.tech_.el();\n\n      if (techEl) {\n        if (_width >= 0) {\n          techEl.width = _width;\n        }\n\n        if (_height >= 0) {\n          techEl.height = _height;\n        }\n      }\n\n      return;\n    }\n\n    var width;\n    var height;\n    var aspectRatio;\n    var idClass; // The aspect ratio is either used directly or to calculate width and height.\n\n    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\n      // Use any aspectRatio that's been specifically set\n      aspectRatio = this.aspectRatio_;\n    } else if (this.videoWidth() > 0) {\n      // Otherwise try to get the aspect ratio from the video metadata\n      aspectRatio = this.videoWidth() + ':' + this.videoHeight();\n    } else {\n      // Or use a default. The video element's is 2:1, but 16:9 is more common.\n      aspectRatio = '16:9';\n    } // Get the ratio as a decimal we can use to calculate dimensions\n\n\n    var ratioParts = aspectRatio.split(':');\n    var ratioMultiplier = ratioParts[1] / ratioParts[0];\n\n    if (this.width_ !== undefined) {\n      // Use any width that's been specifically set\n      width = this.width_;\n    } else if (this.height_ !== undefined) {\n      // Or calulate the width from the aspect ratio if a height has been set\n      width = this.height_ / ratioMultiplier;\n    } else {\n      // Or use the video's metadata, or use the video el's default of 300\n      width = this.videoWidth() || 300;\n    }\n\n    if (this.height_ !== undefined) {\n      // Use any height that's been specifically set\n      height = this.height_;\n    } else {\n      // Otherwise calculate the height from the ratio and the width\n      height = width * ratioMultiplier;\n    } // Ensure the CSS class is valid by starting with an alpha character\n\n\n    if (/^[^a-zA-Z]/.test(this.id())) {\n      idClass = 'dimensions-' + this.id();\n    } else {\n      idClass = this.id() + '-dimensions';\n    } // Ensure the right class is still on the player for the style element\n\n\n    this.addClass(idClass);\n    setTextContent(this.styleEl_, \"\\n      .\" + idClass + \" {\\n        width: \" + width + \"px;\\n        height: \" + height + \"px;\\n      }\\n\\n      .\" + idClass + \".vjs-fluid {\\n        padding-top: \" + ratioMultiplier * 100 + \"%;\\n      }\\n    \");\n  }\n  /**\n   * Load/Create an instance of playback {@link Tech} including element\n   * and API methods. Then append the `Tech` element in `Player` as a child.\n   *\n   * @param {string} techName\n   *        name of the playback technology\n   *\n   * @param {string} source\n   *        video source\n   *\n   * @private\n   */\n  ;\n\n  _proto.loadTech_ = function loadTech_(techName, source) {\n    var _this3 = this; // Pause and remove current playback technology\n\n\n    if (this.tech_) {\n      this.unloadTech_();\n    }\n\n    var titleTechName = toTitleCase(techName);\n    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1); // get rid of the HTML5 video tag as soon as we are using another tech\n\n    if (titleTechName !== 'Html5' && this.tag) {\n      Tech.getTech('Html5').disposeMediaElement(this.tag);\n      this.tag.player = null;\n      this.tag = null;\n    }\n\n    this.techName_ = titleTechName; // Turn off API access because we're loading a new tech that might load asynchronously\n\n    this.isReady_ = false; // if autoplay is a string we pass false to the tech\n    // because the player is going to handle autoplay on `loadstart`\n\n    var autoplay = typeof this.autoplay() === 'string' ? false : this.autoplay(); // Grab tech-specific options from player options and add source and parent element to use.\n\n    var techOptions = {\n      source: source,\n      autoplay: autoplay,\n      'nativeControlsForTouch': this.options_.nativeControlsForTouch,\n      'playerId': this.id(),\n      'techId': this.id() + \"_\" + camelTechName + \"_api\",\n      'playsinline': this.options_.playsinline,\n      'preload': this.options_.preload,\n      'loop': this.options_.loop,\n      'disablePictureInPicture': this.options_.disablePictureInPicture,\n      'muted': this.options_.muted,\n      'poster': this.poster(),\n      'language': this.language(),\n      'playerElIngest': this.playerElIngest_ || false,\n      'vtt.js': this.options_['vtt.js'],\n      'canOverridePoster': !!this.options_.techCanOverridePoster,\n      'enableSourceset': this.options_.enableSourceset,\n      'Promise': this.options_.Promise\n    };\n    ALL.names.forEach(function (name) {\n      var props = ALL[name];\n      techOptions[props.getterName] = _this3[props.privateName];\n    });\n    assign(techOptions, this.options_[titleTechName]);\n    assign(techOptions, this.options_[camelTechName]);\n    assign(techOptions, this.options_[techName.toLowerCase()]);\n\n    if (this.tag) {\n      techOptions.tag = this.tag;\n    }\n\n    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\n      techOptions.startTime = this.cache_.currentTime;\n    } // Initialize tech instance\n\n\n    var TechClass = Tech.getTech(techName);\n\n    if (!TechClass) {\n      throw new Error(\"No Tech named '\" + titleTechName + \"' exists! '\" + titleTechName + \"' should be registered using videojs.registerTech()'\");\n    }\n\n    this.tech_ = new TechClass(techOptions); // player.triggerReady is always async, so don't need this to be async\n\n    this.tech_.ready(bind(this, this.handleTechReady_), true);\n    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_); // Listen to all HTML5-defined events and trigger them on the player\n\n    TECH_EVENTS_RETRIGGER.forEach(function (event) {\n      _this3.on(_this3.tech_, event, _this3[\"handleTech\" + toTitleCase(event) + \"_\"]);\n    });\n    Object.keys(TECH_EVENTS_QUEUE).forEach(function (event) {\n      _this3.on(_this3.tech_, event, function (eventObj) {\n        if (_this3.tech_.playbackRate() === 0 && _this3.tech_.seeking()) {\n          _this3.queuedCallbacks_.push({\n            callback: _this3[\"handleTech\" + TECH_EVENTS_QUEUE[event] + \"_\"].bind(_this3),\n            event: eventObj\n          });\n\n          return;\n        }\n\n        _this3[\"handleTech\" + TECH_EVENTS_QUEUE[event] + \"_\"](eventObj);\n      });\n    });\n    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);\n    this.on(this.tech_, 'sourceset', this.handleTechSourceset_);\n    this.on(this.tech_, 'waiting', this.handleTechWaiting_);\n    this.on(this.tech_, 'ended', this.handleTechEnded_);\n    this.on(this.tech_, 'seeking', this.handleTechSeeking_);\n    this.on(this.tech_, 'play', this.handleTechPlay_);\n    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);\n    this.on(this.tech_, 'pause', this.handleTechPause_);\n    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);\n    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);\n    this.on(this.tech_, 'fullscreenerror', this.handleTechFullscreenError_);\n    this.on(this.tech_, 'enterpictureinpicture', this.handleTechEnterPictureInPicture_);\n    this.on(this.tech_, 'leavepictureinpicture', this.handleTechLeavePictureInPicture_);\n    this.on(this.tech_, 'error', this.handleTechError_);\n    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);\n    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);\n    this.on(this.tech_, 'textdata', this.handleTechTextData_);\n    this.on(this.tech_, 'ratechange', this.handleTechRateChange_);\n    this.usingNativeControls(this.techGet_('controls'));\n\n    if (this.controls() && !this.usingNativeControls()) {\n      this.addTechControlsListeners_();\n    } // Add the tech element in the DOM if it was not already there\n    // Make sure to not insert the original video element if using Html5\n\n\n    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\n      prependTo(this.tech_.el(), this.el());\n    } // Get rid of the original video tag reference after the first tech is loaded\n\n\n    if (this.tag) {\n      this.tag.player = null;\n      this.tag = null;\n    }\n  }\n  /**\n   * Unload and dispose of the current playback {@link Tech}.\n   *\n   * @private\n   */\n  ;\n\n  _proto.unloadTech_ = function unloadTech_() {\n    var _this4 = this; // Save the current text tracks so that we can reuse the same text tracks with the next tech\n\n\n    ALL.names.forEach(function (name) {\n      var props = ALL[name];\n      _this4[props.privateName] = _this4[props.getterName]();\n    });\n    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\n    this.isReady_ = false;\n    this.tech_.dispose();\n    this.tech_ = false;\n\n    if (this.isPosterFromTech_) {\n      this.poster_ = '';\n      this.trigger('posterchange');\n    }\n\n    this.isPosterFromTech_ = false;\n  }\n  /**\n   * Return a reference to the current {@link Tech}.\n   * It will print a warning by default about the danger of using the tech directly\n   * but any argument that is passed in will silence the warning.\n   *\n   * @param {*} [safety]\n   *        Anything passed in to silence the warning\n   *\n   * @return {Tech}\n   *         The Tech\n   */\n  ;\n\n  _proto.tech = function tech(safety) {\n    if (safety === undefined) {\n      log.warn('Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n' + 'See https://github.com/videojs/video.js/issues/2617 for more info.\\n');\n    }\n\n    return this.tech_;\n  }\n  /**\n   * Set up click and touch listeners for the playback element\n   *\n   * - On desktops: a click on the video itself will toggle playback\n   * - On mobile devices: a click on the video toggles controls\n   *   which is done by toggling the user state between active and\n   *   inactive\n   * - A tap can signal that a user has become active or has become inactive\n   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n   *   quick tap should hide them again (signaling the user is in an inactive\n   *   viewing state)\n   * - In addition to this, we still want the user to be considered inactive after\n   *   a few seconds of inactivity.\n   *\n   * > Note: the only part of iOS interaction we can't mimic with this setup\n   * is a touch and hold on the video element counting as activity in order to\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\n   * on any controls will still keep the user active\n   *\n   * @private\n   */\n  ;\n\n  _proto.addTechControlsListeners_ = function addTechControlsListeners_() {\n    // Make sure to remove all the previous listeners in case we are called multiple times.\n    this.removeTechControlsListeners_(); // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\n    // trigger mousedown/up.\n    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\n    // Any touch events are set to block the mousedown event from happening\n\n    this.on(this.tech_, 'mouseup', this.handleTechClick_);\n    this.on(this.tech_, 'dblclick', this.handleTechDoubleClick_); // If the controls were hidden we don't want that to change without a tap event\n    // so we'll check if the controls were already showing before reporting user\n    // activity\n\n    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_); // The tap listener needs to come after the touchend listener because the tap\n    // listener cancels out any reportedUserActivity when setting userActive(false)\n\n    this.on(this.tech_, 'tap', this.handleTechTap_);\n  }\n  /**\n   * Remove the listeners used for click and tap controls. This is needed for\n   * toggling to controls disabled, where a tap/touch should do nothing.\n   *\n   * @private\n   */\n  ;\n\n  _proto.removeTechControlsListeners_ = function removeTechControlsListeners_() {\n    // We don't want to just use `this.off()` because there might be other needed\n    // listeners added by techs that extend this.\n    this.off(this.tech_, 'tap', this.handleTechTap_);\n    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);\n    this.off(this.tech_, 'mouseup', this.handleTechClick_);\n    this.off(this.tech_, 'dblclick', this.handleTechDoubleClick_);\n  }\n  /**\n   * Player waits for the tech to be ready\n   *\n   * @private\n   */\n  ;\n\n  _proto.handleTechReady_ = function handleTechReady_() {\n    this.triggerReady(); // Keep the same volume as before\n\n    if (this.cache_.volume) {\n      this.techCall_('setVolume', this.cache_.volume);\n    } // Look if the tech found a higher resolution poster while loading\n\n\n    this.handleTechPosterChange_(); // Update the duration if available\n\n    this.handleTechDurationChange_();\n  }\n  /**\n   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This\n   * function will also trigger {@link Player#firstplay} if it is the first loadstart\n   * for a video.\n   *\n   * @fires Player#loadstart\n   * @fires Player#firstplay\n   * @listens Tech#loadstart\n   * @private\n   */\n  ;\n\n  _proto.handleTechLoadStart_ = function handleTechLoadStart_() {\n    // TODO: Update to use `emptied` event instead. See #1277.\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-seeking'); // reset the error state\n\n    this.error(null); // Update the duration\n\n    this.handleTechDurationChange_(); // If it's already playing we want to trigger a firstplay event now.\n    // The firstplay event relies on both the play and loadstart events\n    // which can happen in any order for a new source\n\n    if (!this.paused()) {\n      /**\n       * Fired when the user agent begins looking for media data\n       *\n       * @event Player#loadstart\n       * @type {EventTarget~Event}\n       */\n      this.trigger('loadstart');\n      this.trigger('firstplay');\n    } else {\n      // reset the hasStarted state\n      this.hasStarted(false);\n      this.trigger('loadstart');\n    } // autoplay happens after loadstart for the browser,\n    // so we mimic that behavior\n\n\n    this.manualAutoplay_(this.autoplay());\n  }\n  /**\n   * Handle autoplay string values, rather than the typical boolean\n   * values that should be handled by the tech. Note that this is not\n   * part of any specification. Valid values and what they do can be\n   * found on the autoplay getter at Player#autoplay()\n   */\n  ;\n\n  _proto.manualAutoplay_ = function manualAutoplay_(type) {\n    var _this5 = this;\n\n    if (!this.tech_ || typeof type !== 'string') {\n      return;\n    }\n\n    var muted = function muted() {\n      var previouslyMuted = _this5.muted();\n\n      _this5.muted(true);\n\n      var restoreMuted = function restoreMuted() {\n        _this5.muted(previouslyMuted);\n      }; // restore muted on play terminatation\n\n\n      _this5.playTerminatedQueue_.push(restoreMuted);\n\n      var mutedPromise = _this5.play();\n\n      if (!isPromise(mutedPromise)) {\n        return;\n      }\n\n      return mutedPromise[\"catch\"](restoreMuted);\n    };\n\n    var promise; // if muted defaults to true\n    // the only thing we can do is call play\n\n    if (type === 'any' && this.muted() !== true) {\n      promise = this.play();\n\n      if (isPromise(promise)) {\n        promise = promise[\"catch\"](muted);\n      }\n    } else if (type === 'muted' && this.muted() !== true) {\n      promise = muted();\n    } else {\n      promise = this.play();\n    }\n\n    if (!isPromise(promise)) {\n      return;\n    }\n\n    return promise.then(function () {\n      _this5.trigger({\n        type: 'autoplay-success',\n        autoplay: type\n      });\n    })[\"catch\"](function (e) {\n      _this5.trigger({\n        type: 'autoplay-failure',\n        autoplay: type\n      });\n    });\n  }\n  /**\n   * Update the internal source caches so that we return the correct source from\n   * `src()`, `currentSource()`, and `currentSources()`.\n   *\n   * > Note: `currentSources` will not be updated if the source that is passed in exists\n   *         in the current `currentSources` cache.\n   *\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        A string or object source to update our caches to.\n   */\n  ;\n\n  _proto.updateSourceCaches_ = function updateSourceCaches_(srcObj) {\n    if (srcObj === void 0) {\n      srcObj = '';\n    }\n\n    var src = srcObj;\n    var type = '';\n\n    if (typeof src !== 'string') {\n      src = srcObj.src;\n      type = srcObj.type;\n    } // make sure all the caches are set to default values\n    // to prevent null checking\n\n\n    this.cache_.source = this.cache_.source || {};\n    this.cache_.sources = this.cache_.sources || []; // try to get the type of the src that was passed in\n\n    if (src && !type) {\n      type = findMimetype(this, src);\n    } // update `currentSource` cache always\n\n\n    this.cache_.source = mergeOptions({}, srcObj, {\n      src: src,\n      type: type\n    });\n    var matchingSources = this.cache_.sources.filter(function (s) {\n      return s.src && s.src === src;\n    });\n    var sourceElSources = [];\n    var sourceEls = this.$$('source');\n    var matchingSourceEls = [];\n\n    for (var i = 0; i < sourceEls.length; i++) {\n      var sourceObj = getAttributes(sourceEls[i]);\n      sourceElSources.push(sourceObj);\n\n      if (sourceObj.src && sourceObj.src === src) {\n        matchingSourceEls.push(sourceObj.src);\n      }\n    } // if we have matching source els but not matching sources\n    // the current source cache is not up to date\n\n\n    if (matchingSourceEls.length && !matchingSources.length) {\n      this.cache_.sources = sourceElSources; // if we don't have matching source or source els set the\n      // sources cache to the `currentSource` cache\n    } else if (!matchingSources.length) {\n      this.cache_.sources = [this.cache_.source];\n    } // update the tech `src` cache\n\n\n    this.cache_.src = src;\n  }\n  /**\n   * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}\n   * causing the media element to reload.\n   *\n   * It will fire for the initial source and each subsequent source.\n   * This event is a custom event from Video.js and is triggered by the {@link Tech}.\n   *\n   * The event object for this event contains a `src` property that will contain the source\n   * that was available when the event was triggered. This is generally only necessary if Video.js\n   * is switching techs while the source was being changed.\n   *\n   * It is also fired when `load` is called on the player (or media element)\n   * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}\n   * says that the resource selection algorithm needs to be aborted and restarted.\n   * In this case, it is very likely that the `src` property will be set to the\n   * empty string `\"\"` to indicate we do not know what the source will be but\n   * that it is changing.\n   *\n   * *This event is currently still experimental and may change in minor releases.*\n   * __To use this, pass `enableSourceset` option to the player.__\n   *\n   * @event Player#sourceset\n   * @type {EventTarget~Event}\n   * @prop {string} src\n   *                The source url available when the `sourceset` was triggered.\n   *                It will be an empty string if we cannot know what the source is\n   *                but know that the source will change.\n   */\n\n  /**\n   * Retrigger the `sourceset` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#sourceset\n   * @listens Tech#sourceset\n   * @private\n   */\n  ;\n\n  _proto.handleTechSourceset_ = function handleTechSourceset_(event) {\n    var _this6 = this; // only update the source cache when the source\n    // was not updated using the player api\n\n\n    if (!this.changingSrc_) {\n      var updateSourceCaches = function updateSourceCaches(src) {\n        return _this6.updateSourceCaches_(src);\n      };\n\n      var playerSrc = this.currentSource().src;\n      var eventSrc = event.src; // if we have a playerSrc that is not a blob, and a tech src that is a blob\n\n      if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {\n        // if both the tech source and the player source were updated we assume\n        // something like @videojs/http-streaming did the sourceset and skip updating the source cache.\n        if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {\n          updateSourceCaches = function updateSourceCaches() {};\n        }\n      } // update the source to the initial source right away\n      // in some cases this will be empty string\n\n\n      updateSourceCaches(eventSrc); // if the `sourceset` `src` was an empty string\n      // wait for a `loadstart` to update the cache to `currentSrc`.\n      // If a sourceset happens before a `loadstart`, we reset the state\n\n      if (!event.src) {\n        this.tech_.any(['sourceset', 'loadstart'], function (e) {\n          // if a sourceset happens before a `loadstart` there\n          // is nothing to do as this `handleTechSourceset_`\n          // will be called again and this will be handled there.\n          if (e.type === 'sourceset') {\n            return;\n          }\n\n          var techSrc = _this6.techGet('currentSrc');\n\n          _this6.lastSource_.tech = techSrc;\n\n          _this6.updateSourceCaches_(techSrc);\n        });\n      }\n    }\n\n    this.lastSource_ = {\n      player: this.currentSource().src,\n      tech: event.src\n    };\n    this.trigger({\n      src: event.src,\n      type: 'sourceset'\n    });\n  }\n  /**\n   * Add/remove the vjs-has-started class\n   *\n   * @fires Player#firstplay\n   *\n   * @param {boolean} request\n   *        - true: adds the class\n   *        - false: remove the class\n   *\n   * @return {boolean}\n   *         the boolean value of hasStarted_\n   */\n  ;\n\n  _proto.hasStarted = function hasStarted(request) {\n    if (request === undefined) {\n      // act as getter, if we have no request to change\n      return this.hasStarted_;\n    }\n\n    if (request === this.hasStarted_) {\n      return;\n    }\n\n    this.hasStarted_ = request;\n\n    if (this.hasStarted_) {\n      this.addClass('vjs-has-started');\n      this.trigger('firstplay');\n    } else {\n      this.removeClass('vjs-has-started');\n    }\n  }\n  /**\n   * Fired whenever the media begins or resumes playback\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n   * @fires Player#play\n   * @listens Tech#play\n   * @private\n   */\n  ;\n\n  _proto.handleTechPlay_ = function handleTechPlay_() {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing'); // hide the poster when the user hits play\n\n    this.hasStarted(true);\n    /**\n     * Triggered whenever an {@link Tech#play} event happens. Indicates that\n     * playback has started or resumed.\n     *\n     * @event Player#play\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('play');\n  }\n  /**\n   * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n   *\n   * If there were any events queued while the playback rate was zero, fire\n   * those events now.\n   *\n   * @private\n   * @method Player#handleTechRateChange_\n   * @fires Player#ratechange\n   * @listens Tech#ratechange\n   */\n  ;\n\n  _proto.handleTechRateChange_ = function handleTechRateChange_() {\n    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {\n      this.queuedCallbacks_.forEach(function (queued) {\n        return queued.callback(queued.event);\n      });\n      this.queuedCallbacks_ = [];\n    }\n\n    this.cache_.lastPlaybackRate = this.tech_.playbackRate();\n    /**\n     * Fires when the playing speed of the audio/video is changed\n     *\n     * @event Player#ratechange\n     * @type {event}\n     */\n\n    this.trigger('ratechange');\n  }\n  /**\n   * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#waiting\n   * @listens Tech#waiting\n   * @private\n   */\n  ;\n\n  _proto.handleTechWaiting_ = function handleTechWaiting_() {\n    var _this7 = this;\n\n    this.addClass('vjs-waiting');\n    /**\n     * A readyState change on the DOM element has caused playback to stop.\n     *\n     * @event Player#waiting\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('waiting'); // Browsers may emit a timeupdate event after a waiting event. In order to prevent\n    // premature removal of the waiting class, wait for the time to change.\n\n    var timeWhenWaiting = this.currentTime();\n\n    var timeUpdateListener = function timeUpdateListener() {\n      if (timeWhenWaiting !== _this7.currentTime()) {\n        _this7.removeClass('vjs-waiting');\n\n        _this7.off('timeupdate', timeUpdateListener);\n      }\n    };\n\n    this.on('timeupdate', timeUpdateListener);\n  }\n  /**\n   * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n   * > Note: This is not consistent between browsers. See #1351\n   *\n   * @fires Player#canplay\n   * @listens Tech#canplay\n   * @private\n   */\n  ;\n\n  _proto.handleTechCanPlay_ = function handleTechCanPlay_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_FUTURE_DATA or greater.\n     *\n     * @event Player#canplay\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('canplay');\n  }\n  /**\n   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#canplaythrough\n   * @listens Tech#canplaythrough\n   * @private\n   */\n  ;\n\n  _proto.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n     * entire media file can be played without buffering.\n     *\n     * @event Player#canplaythrough\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('canplaythrough');\n  }\n  /**\n   * Retrigger the `playing` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#playing\n   * @listens Tech#playing\n   * @private\n   */\n  ;\n\n  _proto.handleTechPlaying_ = function handleTechPlaying_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media is no longer blocked from playback, and has started playing.\n     *\n     * @event Player#playing\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('playing');\n  }\n  /**\n   * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeking\n   * @listens Tech#seeking\n   * @private\n   */\n  ;\n\n  _proto.handleTechSeeking_ = function handleTechSeeking_() {\n    this.addClass('vjs-seeking');\n    /**\n     * Fired whenever the player is jumping to a new time\n     *\n     * @event Player#seeking\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('seeking');\n  }\n  /**\n   * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeked\n   * @listens Tech#seeked\n   * @private\n   */\n  ;\n\n  _proto.handleTechSeeked_ = function handleTechSeeked_() {\n    this.removeClass('vjs-seeking');\n    this.removeClass('vjs-ended');\n    /**\n     * Fired when the player has finished jumping to a new time\n     *\n     * @event Player#seeked\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('seeked');\n  }\n  /**\n   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#firstplay\n   * @listens Tech#firstplay\n   * @deprecated As of 6.0 firstplay event is deprecated.\n   *             As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.\n   * @private\n   */\n  ;\n\n  _proto.handleTechFirstPlay_ = function handleTechFirstPlay_() {\n    // If the first starttime attribute is specified\n    // then we will start at the given offset in seconds\n    if (this.options_.starttime) {\n      log.warn('Passing the `starttime` option to the player will be deprecated in 6.0');\n      this.currentTime(this.options_.starttime);\n    }\n\n    this.addClass('vjs-has-started');\n    /**\n     * Fired the first time a video is played. Not part of the HLS spec, and this is\n     * probably not the best implementation yet, so use sparingly. If you don't have a\n     * reason to prevent playback, use `myPlayer.one('play');` instead.\n     *\n     * @event Player#firstplay\n     * @deprecated As of 6.0 firstplay event is deprecated.\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('firstplay');\n  }\n  /**\n   * Retrigger the `pause` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#pause\n   * @listens Tech#pause\n   * @private\n   */\n  ;\n\n  _proto.handleTechPause_ = function handleTechPause_() {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused');\n    /**\n     * Fired whenever the media has been paused\n     *\n     * @event Player#pause\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('pause');\n  }\n  /**\n   * Retrigger the `ended` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#ended\n   * @listens Tech#ended\n   * @private\n   */\n  ;\n\n  _proto.handleTechEnded_ = function handleTechEnded_() {\n    this.addClass('vjs-ended');\n\n    if (this.options_.loop) {\n      this.currentTime(0);\n      this.play();\n    } else if (!this.paused()) {\n      this.pause();\n    }\n    /**\n     * Fired when the end of the media resource is reached (currentTime == duration)\n     *\n     * @event Player#ended\n     * @type {EventTarget~Event}\n     */\n\n\n    this.trigger('ended');\n  }\n  /**\n   * Fired when the duration of the media resource is first known or changed\n   *\n   * @listens Tech#durationchange\n   * @private\n   */\n  ;\n\n  _proto.handleTechDurationChange_ = function handleTechDurationChange_() {\n    this.duration(this.techGet_('duration'));\n  }\n  /**\n   * Handle a click on the media element to play/pause\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#mouseup\n   * @private\n   */\n  ;\n\n  _proto.handleTechClick_ = function handleTechClick_(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    } // When controls are disabled a click should not toggle playback because\n    // the click is considered a control\n\n\n    if (!this.controls_) {\n      return;\n    }\n\n    if (this.paused()) {\n      silencePromise(this.play());\n    } else {\n      this.pause();\n    }\n  }\n  /**\n   * Handle a double-click on the media element to enter/exit fullscreen\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#dblclick\n   * @private\n   */\n  ;\n\n  _proto.handleTechDoubleClick_ = function handleTechDoubleClick_(event) {\n    if (!this.controls_) {\n      return;\n    } // we do not want to toggle fullscreen state\n    // when double-clicking inside a control bar or a modal\n\n\n    var inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), function (el) {\n      return el.contains(event.target);\n    });\n\n    if (!inAllowedEls) {\n      /*\n       * options.userActions.doubleClick\n       *\n       * If `undefined` or `true`, double-click toggles fullscreen if controls are present\n       * Set to `false` to disable double-click handling\n       * Set to a function to substitute an external double-click handler\n       */\n      if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {\n        if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {\n          this.options_.userActions.doubleClick.call(this, event);\n        } else if (this.isFullscreen()) {\n          this.exitFullscreen();\n        } else {\n          this.requestFullscreen();\n        }\n      }\n    }\n  }\n  /**\n   * Handle a tap on the media element. It will toggle the user\n   * activity state, which hides and shows the controls.\n   *\n   * @listens Tech#tap\n   * @private\n   */\n  ;\n\n  _proto.handleTechTap_ = function handleTechTap_() {\n    this.userActive(!this.userActive());\n  }\n  /**\n   * Handle touch to start\n   *\n   * @listens Tech#touchstart\n   * @private\n   */\n  ;\n\n  _proto.handleTechTouchStart_ = function handleTechTouchStart_() {\n    this.userWasActive = this.userActive();\n  }\n  /**\n   * Handle touch to move\n   *\n   * @listens Tech#touchmove\n   * @private\n   */\n  ;\n\n  _proto.handleTechTouchMove_ = function handleTechTouchMove_() {\n    if (this.userWasActive) {\n      this.reportUserActivity();\n    }\n  }\n  /**\n   * Handle touch to end\n   *\n   * @param {EventTarget~Event} event\n   *        the touchend event that triggered\n   *        this function\n   *\n   * @listens Tech#touchend\n   * @private\n   */\n  ;\n\n  _proto.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {\n    // Stop the mouse events from also happening\n    event.preventDefault();\n  }\n  /**\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\n   * use stageclick events triggered from inside the SWF instead\n   *\n   * @private\n   * @listens stageclick\n   */\n  ;\n\n  _proto.handleStageClick_ = function handleStageClick_() {\n    this.reportUserActivity();\n  }\n  /**\n   * @private\n   */\n  ;\n\n  _proto.toggleFullscreenClass_ = function toggleFullscreenClass_() {\n    if (this.isFullscreen()) {\n      this.addClass('vjs-fullscreen');\n    } else {\n      this.removeClass('vjs-fullscreen');\n    }\n  }\n  /**\n   * when the document fschange event triggers it calls this\n   */\n  ;\n\n  _proto.documentFullscreenChange_ = function documentFullscreenChange_(e) {\n    var targetPlayer = e.target.player; // if another player was fullscreen\n    // do a null check for targetPlayer because older firefox's would put document as e.target\n\n    if (targetPlayer && targetPlayer !== this) {\n      return;\n    }\n\n    var el = this.el();\n    var isFs = document[this.fsApi_.fullscreenElement] === el;\n\n    if (!isFs && el.matches) {\n      isFs = el.matches(':' + this.fsApi_.fullscreen);\n    } else if (!isFs && el.msMatchesSelector) {\n      isFs = el.msMatchesSelector(':' + this.fsApi_.fullscreen);\n    }\n\n    this.isFullscreen(isFs);\n  }\n  /**\n   * Handle Tech Fullscreen Change\n   *\n   * @param {EventTarget~Event} event\n   *        the fullscreenchange event that triggered this function\n   *\n   * @param {Object} data\n   *        the data that was sent with the event\n   *\n   * @private\n   * @listens Tech#fullscreenchange\n   * @fires Player#fullscreenchange\n   */\n  ;\n\n  _proto.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {\n    if (data) {\n      if (data.nativeIOSFullscreen) {\n        this.toggleClass('vjs-ios-native-fs');\n      }\n\n      this.isFullscreen(data.isFullscreen);\n    }\n  };\n\n  _proto.handleTechFullscreenError_ = function handleTechFullscreenError_(event, err) {\n    this.trigger('fullscreenerror', err);\n  }\n  /**\n   * @private\n   */\n  ;\n\n  _proto.togglePictureInPictureClass_ = function togglePictureInPictureClass_() {\n    if (this.isInPictureInPicture()) {\n      this.addClass('vjs-picture-in-picture');\n    } else {\n      this.removeClass('vjs-picture-in-picture');\n    }\n  }\n  /**\n   * Handle Tech Enter Picture-in-Picture.\n   *\n   * @param {EventTarget~Event} event\n   *        the enterpictureinpicture event that triggered this function\n   *\n   * @private\n   * @listens Tech#enterpictureinpicture\n   */\n  ;\n\n  _proto.handleTechEnterPictureInPicture_ = function handleTechEnterPictureInPicture_(event) {\n    this.isInPictureInPicture(true);\n  }\n  /**\n   * Handle Tech Leave Picture-in-Picture.\n   *\n   * @param {EventTarget~Event} event\n   *        the leavepictureinpicture event that triggered this function\n   *\n   * @private\n   * @listens Tech#leavepictureinpicture\n   */\n  ;\n\n  _proto.handleTechLeavePictureInPicture_ = function handleTechLeavePictureInPicture_(event) {\n    this.isInPictureInPicture(false);\n  }\n  /**\n   * Fires when an error occurred during the loading of an audio/video.\n   *\n   * @private\n   * @listens Tech#error\n   */\n  ;\n\n  _proto.handleTechError_ = function handleTechError_() {\n    var error = this.tech_.error();\n    this.error(error);\n  }\n  /**\n   * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#textdata\n   * @listens Tech#textdata\n   * @private\n   */\n  ;\n\n  _proto.handleTechTextData_ = function handleTechTextData_() {\n    var data = null;\n\n    if (arguments.length > 1) {\n      data = arguments[1];\n    }\n    /**\n     * Fires when we get a textdata event from tech\n     *\n     * @event Player#textdata\n     * @type {EventTarget~Event}\n     */\n\n\n    this.trigger('textdata', data);\n  }\n  /**\n   * Get object for cached values.\n   *\n   * @return {Object}\n   *         get the current object cache\n   */\n  ;\n\n  _proto.getCache = function getCache() {\n    return this.cache_;\n  }\n  /**\n   * Resets the internal cache object.\n   *\n   * Using this function outside the player constructor or reset method may\n   * have unintended side-effects.\n   *\n   * @private\n   */\n  ;\n\n  _proto.resetCache_ = function resetCache_() {\n    this.cache_ = {\n      // Right now, the currentTime is not _really_ cached because it is always\n      // retrieved from the tech (see: currentTime). However, for completeness,\n      // we set it to zero here to ensure that if we do start actually caching\n      // it, we reset it along with everything else.\n      currentTime: 0,\n      initTime: 0,\n      inactivityTimeout: this.options_.inactivityTimeout,\n      duration: NaN,\n      lastVolume: 1,\n      lastPlaybackRate: this.defaultPlaybackRate(),\n      media: null,\n      src: '',\n      source: {},\n      sources: [],\n      volume: 1\n    };\n  }\n  /**\n   * Pass values to the playback tech\n   *\n   * @param {string} [method]\n   *        the method to call\n   *\n   * @param {Object} arg\n   *        the argument to pass\n   *\n   * @private\n   */\n  ;\n\n  _proto.techCall_ = function techCall_(method, arg) {\n    // If it's not ready yet, call method when it is\n    this.ready(function () {\n      if (method in allowedSetters) {\n        return set(this.middleware_, this.tech_, method, arg);\n      } else if (method in allowedMediators) {\n        return mediate(this.middleware_, this.tech_, method, arg);\n      }\n\n      try {\n        if (this.tech_) {\n          this.tech_[method](arg);\n        }\n      } catch (e) {\n        log(e);\n        throw e;\n      }\n    }, true);\n  }\n  /**\n   * Get calls can't wait for the tech, and sometimes don't need to.\n   *\n   * @param {string} method\n   *        Tech method\n   *\n   * @return {Function|undefined}\n   *         the method or undefined\n   *\n   * @private\n   */\n  ;\n\n  _proto.techGet_ = function techGet_(method) {\n    if (!this.tech_ || !this.tech_.isReady_) {\n      return;\n    }\n\n    if (method in allowedGetters) {\n      return get(this.middleware_, this.tech_, method);\n    } else if (method in allowedMediators) {\n      return mediate(this.middleware_, this.tech_, method);\n    } // Flash likes to die and reload when you hide or reposition it.\n    // In these cases the object methods go away and we get errors.\n    // When that happens we'll catch the errors and inform tech that it's not ready any more.\n\n\n    try {\n      return this.tech_[method]();\n    } catch (e) {\n      // When building additional tech libs, an expected method may not be defined yet\n      if (this.tech_[method] === undefined) {\n        log(\"Video.js: \" + method + \" method not defined for \" + this.techName_ + \" playback technology.\", e);\n        throw e;\n      } // When a method isn't available on the object it throws a TypeError\n\n\n      if (e.name === 'TypeError') {\n        log(\"Video.js: \" + method + \" unavailable on \" + this.techName_ + \" playback technology element.\", e);\n        this.tech_.isReady_ = false;\n        throw e;\n      } // If error unknown, just log and throw\n\n\n      log(e);\n      throw e;\n    }\n  }\n  /**\n   * Attempt to begin playback at the first opportunity.\n   *\n   * @return {Promise|undefined}\n   *         Returns a promise if the browser supports Promises (or one\n   *         was passed in as an option). This promise will be resolved on\n   *         the return value of play. If this is undefined it will fulfill the\n   *         promise chain otherwise the promise chain will be fulfilled when\n   *         the promise from play is fulfilled.\n   */\n  ;\n\n  _proto.play = function play() {\n    var _this8 = this;\n\n    var PromiseClass = this.options_.Promise || window$1.Promise;\n\n    if (PromiseClass) {\n      return new PromiseClass(function (resolve) {\n        _this8.play_(resolve);\n      });\n    }\n\n    return this.play_();\n  }\n  /**\n   * The actual logic for play, takes a callback that will be resolved on the\n   * return value of play. This allows us to resolve to the play promise if there\n   * is one on modern browsers.\n   *\n   * @private\n   * @param {Function} [callback]\n   *        The callback that should be called when the techs play is actually called\n   */\n  ;\n\n  _proto.play_ = function play_(callback) {\n    var _this9 = this;\n\n    if (callback === void 0) {\n      callback = silencePromise;\n    }\n\n    this.playCallbacks_.push(callback);\n    var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc())); // treat calls to play_ somewhat like the `one` event function\n\n    if (this.waitToPlay_) {\n      this.off(['ready', 'loadstart'], this.waitToPlay_);\n      this.waitToPlay_ = null;\n    } // if the player/tech is not ready or the src itself is not ready\n    // queue up a call to play on `ready` or `loadstart`\n\n\n    if (!this.isReady_ || !isSrcReady) {\n      this.waitToPlay_ = function (e) {\n        _this9.play_();\n      };\n\n      this.one(['ready', 'loadstart'], this.waitToPlay_); // if we are in Safari, there is a high chance that loadstart will trigger after the gesture timeperiod\n      // in that case, we need to prime the video element by calling load so it'll be ready in time\n\n      if (!isSrcReady && (IS_ANY_SAFARI || IS_IOS)) {\n        this.load();\n      }\n\n      return;\n    } // If the player/tech is ready and we have a source, we can attempt playback.\n\n\n    var val = this.techGet_('play'); // play was terminated if the returned value is null\n\n    if (val === null) {\n      this.runPlayTerminatedQueue_();\n    } else {\n      this.runPlayCallbacks_(val);\n    }\n  }\n  /**\n   * These functions will be run when if play is terminated. If play\n   * runPlayCallbacks_ is run these function will not be run. This allows us\n   * to differenciate between a terminated play and an actual call to play.\n   */\n  ;\n\n  _proto.runPlayTerminatedQueue_ = function runPlayTerminatedQueue_() {\n    var queue = this.playTerminatedQueue_.slice(0);\n    this.playTerminatedQueue_ = [];\n    queue.forEach(function (q) {\n      q();\n    });\n  }\n  /**\n   * When a callback to play is delayed we have to run these\n   * callbacks when play is actually called on the tech. This function\n   * runs the callbacks that were delayed and accepts the return value\n   * from the tech.\n   *\n   * @param {undefined|Promise} val\n   *        The return value from the tech.\n   */\n  ;\n\n  _proto.runPlayCallbacks_ = function runPlayCallbacks_(val) {\n    var callbacks = this.playCallbacks_.slice(0);\n    this.playCallbacks_ = []; // clear play terminatedQueue since we finished a real play\n\n    this.playTerminatedQueue_ = [];\n    callbacks.forEach(function (cb) {\n      cb(val);\n    });\n  }\n  /**\n   * Pause the video playback\n   *\n   * @return {Player}\n   *         A reference to the player object this function was called on\n   */\n  ;\n\n  _proto.pause = function pause() {\n    this.techCall_('pause');\n  }\n  /**\n   * Check if the player is paused or has yet to play\n   *\n   * @return {boolean}\n   *         - false: if the media is currently playing\n   *         - true: if media is not currently playing\n   */\n  ;\n\n  _proto.paused = function paused() {\n    // The initial state of paused should be true (in Safari it's actually false)\n    return this.techGet_('paused') === false ? false : true;\n  }\n  /**\n   * Get a TimeRange object representing the current ranges of time that the user\n   * has played.\n   *\n   * @return {TimeRange}\n   *         A time range object that represents all the increments of time that have\n   *         been played.\n   */\n  ;\n\n  _proto.played = function played() {\n    return this.techGet_('played') || createTimeRanges(0, 0);\n  }\n  /**\n   * Returns whether or not the user is \"scrubbing\". Scrubbing is\n   * when the user has clicked the progress bar handle and is\n   * dragging it along the progress bar.\n   *\n   * @param {boolean} [isScrubbing]\n   *        whether the user is or is not scrubbing\n   *\n   * @return {boolean}\n   *         The value of scrubbing when getting\n   */\n  ;\n\n  _proto.scrubbing = function scrubbing(isScrubbing) {\n    if (typeof isScrubbing === 'undefined') {\n      return this.scrubbing_;\n    }\n\n    this.scrubbing_ = !!isScrubbing;\n    this.techCall_('setScrubbing', this.scrubbing_);\n\n    if (isScrubbing) {\n      this.addClass('vjs-scrubbing');\n    } else {\n      this.removeClass('vjs-scrubbing');\n    }\n  }\n  /**\n   * Get or set the current time (in seconds)\n   *\n   * @param {number|string} [seconds]\n   *        The time to seek to in seconds\n   *\n   * @return {number}\n   *         - the current time in seconds when getting\n   */\n  ;\n\n  _proto.currentTime = function currentTime(seconds) {\n    if (typeof seconds !== 'undefined') {\n      if (seconds < 0) {\n        seconds = 0;\n      }\n\n      if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {\n        this.cache_.initTime = seconds;\n        this.off('canplay', this.applyInitTime_);\n        this.one('canplay', this.applyInitTime_);\n        return;\n      }\n\n      this.techCall_('setCurrentTime', seconds);\n      this.cache_.initTime = 0;\n      return;\n    } // cache last currentTime and return. default to 0 seconds\n    //\n    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n    // currentTime when scrubbing, but may not provide much performance benefit afterall.\n    // Should be tested. Also something has to read the actual current time or the cache will\n    // never get updated.\n\n\n    this.cache_.currentTime = this.techGet_('currentTime') || 0;\n    return this.cache_.currentTime;\n  }\n  /**\n   * Apply the value of initTime stored in cache as currentTime.\n   *\n   * @private\n   */\n  ;\n\n  _proto.applyInitTime_ = function applyInitTime_() {\n    this.currentTime(this.cache_.initTime);\n  }\n  /**\n   * Normally gets the length in time of the video in seconds;\n   * in all but the rarest use cases an argument will NOT be passed to the method\n   *\n   * > **NOTE**: The video must have started loading before the duration can be\n   * known, and in the case of Flash, may not be known until the video starts\n   * playing.\n   *\n   * @fires Player#durationchange\n   *\n   * @param {number} [seconds]\n   *        The duration of the video to set in seconds\n   *\n   * @return {number}\n   *         - The duration of the video in seconds when getting\n   */\n  ;\n\n  _proto.duration = function duration(seconds) {\n    if (seconds === undefined) {\n      // return NaN if the duration is not known\n      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\n    }\n\n    seconds = parseFloat(seconds); // Standardize on Infinity for signaling video is live\n\n    if (seconds < 0) {\n      seconds = Infinity;\n    }\n\n    if (seconds !== this.cache_.duration) {\n      // Cache the last set value for optimized scrubbing (esp. Flash)\n      this.cache_.duration = seconds;\n\n      if (seconds === Infinity) {\n        this.addClass('vjs-live');\n      } else {\n        this.removeClass('vjs-live');\n      }\n\n      if (!isNaN(seconds)) {\n        // Do not fire durationchange unless the duration value is known.\n        // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n\n        /**\n         * @event Player#durationchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('durationchange');\n      }\n    }\n  }\n  /**\n   * Calculates how much time is left in the video. Not part\n   * of the native video API.\n   *\n   * @return {number}\n   *         The time remaining in seconds\n   */\n  ;\n\n  _proto.remainingTime = function remainingTime() {\n    return this.duration() - this.currentTime();\n  }\n  /**\n   * A remaining time function that is intented to be used when\n   * the time is to be displayed directly to the user.\n   *\n   * @return {number}\n   *         The rounded time remaining in seconds\n   */\n  ;\n\n  _proto.remainingTimeDisplay = function remainingTimeDisplay() {\n    return Math.floor(this.duration()) - Math.floor(this.currentTime());\n  } //\n  // Kind of like an array of portions of the video that have been downloaded.\n\n  /**\n   * Get a TimeRange object with an array of the times of the video\n   * that have been downloaded. If you just want the percent of the\n   * video that's been downloaded, use bufferedPercent.\n   *\n   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n   *\n   * @return {TimeRange}\n   *         A mock TimeRange object (following HTML spec)\n   */\n  ;\n\n  _proto.buffered = function buffered() {\n    var buffered = this.techGet_('buffered');\n\n    if (!buffered || !buffered.length) {\n      buffered = createTimeRanges(0, 0);\n    }\n\n    return buffered;\n  }\n  /**\n   * Get the percent (as a decimal) of the video that's been downloaded.\n   * This method is not a part of the native HTML video API.\n   *\n   * @return {number}\n   *         A decimal between 0 and 1 representing the percent\n   *         that is buffered 0 being 0% and 1 being 100%\n   */\n  ;\n\n  _proto.bufferedPercent = function bufferedPercent$1() {\n    return bufferedPercent(this.buffered(), this.duration());\n  }\n  /**\n   * Get the ending time of the last buffered time range\n   * This is used in the progress bar to encapsulate all time ranges.\n   *\n   * @return {number}\n   *         The end of the last buffered time range\n   */\n  ;\n\n  _proto.bufferedEnd = function bufferedEnd() {\n    var buffered = this.buffered();\n    var duration = this.duration();\n    var end = buffered.end(buffered.length - 1);\n\n    if (end > duration) {\n      end = duration;\n    }\n\n    return end;\n  }\n  /**\n   * Get or set the current volume of the media\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         The current volume as a percent when getting\n   */\n  ;\n\n  _proto.volume = function volume(percentAsDecimal) {\n    var vol;\n\n    if (percentAsDecimal !== undefined) {\n      // Force value to between 0 and 1\n      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));\n      this.cache_.volume = vol;\n      this.techCall_('setVolume', vol);\n\n      if (vol > 0) {\n        this.lastVolume_(vol);\n      }\n\n      return;\n    } // Default to 1 when returning current volume.\n\n\n    vol = parseFloat(this.techGet_('volume'));\n    return isNaN(vol) ? 1 : vol;\n  }\n  /**\n   * Get the current muted state, or turn mute on or off\n   *\n   * @param {boolean} [muted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean}\n   *         - true if mute is on and getting\n   *         - false if mute is off and getting\n   */\n  ;\n\n  _proto.muted = function muted(_muted) {\n    if (_muted !== undefined) {\n      this.techCall_('setMuted', _muted);\n      return;\n    }\n\n    return this.techGet_('muted') || false;\n  }\n  /**\n   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n   * indicates the state of muted on initial playback.\n   *\n   * ```js\n   *   var myPlayer = videojs('some-player-id');\n   *\n   *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n   *\n   *   // get, should be false\n   *   console.log(myPlayer.defaultMuted());\n   *   // set to true\n   *   myPlayer.defaultMuted(true);\n   *   // get should be true\n   *   console.log(myPlayer.defaultMuted());\n   * ```\n   *\n   * @param {boolean} [defaultMuted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean|Player}\n   *         - true if defaultMuted is on and getting\n   *         - false if defaultMuted is off and getting\n   *         - A reference to the current player when setting\n   */\n  ;\n\n  _proto.defaultMuted = function defaultMuted(_defaultMuted) {\n    if (_defaultMuted !== undefined) {\n      return this.techCall_('setDefaultMuted', _defaultMuted);\n    }\n\n    return this.techGet_('defaultMuted') || false;\n  }\n  /**\n   * Get the last volume, or set it\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new last volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         the current value of lastVolume as a percent when getting\n   *\n   * @private\n   */\n  ;\n\n  _proto.lastVolume_ = function lastVolume_(percentAsDecimal) {\n    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\n      this.cache_.lastVolume = percentAsDecimal;\n      return;\n    }\n\n    return this.cache_.lastVolume;\n  }\n  /**\n   * Check if current tech can support native fullscreen\n   * (e.g. with built in controls like iOS, so not our flash swf)\n   *\n   * @return {boolean}\n   *         if native fullscreen is supported\n   */\n  ;\n\n  _proto.supportsFullScreen = function supportsFullScreen() {\n    return this.techGet_('supportsFullScreen') || false;\n  }\n  /**\n   * Check if the player is in fullscreen mode or tell the player that it\n   * is or is not in fullscreen mode.\n   *\n   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n   * property and instead document.fullscreenElement is used. But isFullscreen is\n   * still a valuable property for internal player workings.\n   *\n   * @param  {boolean} [isFS]\n   *         Set the players current fullscreen state\n   *\n   * @return {boolean}\n   *         - true if fullscreen is on and getting\n   *         - false if fullscreen is off and getting\n   */\n  ;\n\n  _proto.isFullscreen = function isFullscreen(isFS) {\n    if (isFS !== undefined) {\n      var oldValue = this.isFullscreen_;\n      this.isFullscreen_ = Boolean(isFS); // if we changed fullscreen state and we're in prefixed mode, trigger fullscreenchange\n      // this is the only place where we trigger fullscreenchange events for older browsers\n      // fullWindow mode is treated as a prefixed event and will get a fullscreenchange event as well\n\n      if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {\n        /**\n           * @event Player#fullscreenchange\n           * @type {EventTarget~Event}\n           */\n        this.trigger('fullscreenchange');\n      }\n\n      this.toggleFullscreenClass_();\n      return;\n    }\n\n    return this.isFullscreen_;\n  }\n  /**\n   * Increase the size of the video to full screen\n   * In some browsers, full screen is not supported natively, so it enters\n   * \"full window mode\", where the video fills the browser window.\n   * In browsers and devices that support native full screen, sometimes the\n   * browser's default controls will be shown, and not the Video.js custom skin.\n   * This includes most mobile devices (iOS, Android) and older versions of\n   * Safari.\n   *\n   * @param  {Object} [fullscreenOptions]\n   *         Override the player fullscreen options\n   *\n   * @fires Player#fullscreenchange\n   */\n  ;\n\n  _proto.requestFullscreen = function requestFullscreen(fullscreenOptions) {\n    var PromiseClass = this.options_.Promise || window$1.Promise;\n\n    if (PromiseClass) {\n      var self = this;\n      return new PromiseClass(function (resolve, reject) {\n        function offHandler() {\n          self.off('fullscreenerror', errorHandler);\n          self.off('fullscreenchange', changeHandler);\n        }\n\n        function changeHandler() {\n          offHandler();\n          resolve();\n        }\n\n        function errorHandler(e, err) {\n          offHandler();\n          reject(err);\n        }\n\n        self.one('fullscreenchange', changeHandler);\n        self.one('fullscreenerror', errorHandler);\n        var promise = self.requestFullscreenHelper_(fullscreenOptions);\n\n        if (promise) {\n          promise.then(offHandler, offHandler);\n          return promise;\n        }\n      });\n    }\n\n    return this.requestFullscreenHelper_();\n  };\n\n  _proto.requestFullscreenHelper_ = function requestFullscreenHelper_(fullscreenOptions) {\n    var _this10 = this;\n\n    var fsOptions; // Only pass fullscreen options to requestFullscreen in spec-compliant browsers.\n    // Use defaults or player configured option unless passed directly to this method.\n\n    if (!this.fsApi_.prefixed) {\n      fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};\n\n      if (fullscreenOptions !== undefined) {\n        fsOptions = fullscreenOptions;\n      }\n    } // This method works as follows:\n    // 1. if a fullscreen api is available, use it\n    //   1. call requestFullscreen with potential options\n    //   2. if we got a promise from above, use it to update isFullscreen()\n    // 2. otherwise, if the tech supports fullscreen, call `enterFullScreen` on it.\n    //   This is particularly used for iPhone, older iPads, and non-safari browser on iOS.\n    // 3. otherwise, use \"fullWindow\" mode\n\n\n    if (this.fsApi_.requestFullscreen) {\n      var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);\n\n      if (promise) {\n        promise.then(function () {\n          return _this10.isFullscreen(true);\n        }, function () {\n          return _this10.isFullscreen(false);\n        });\n      }\n\n      return promise;\n    } else if (this.tech_.supportsFullScreen()) {\n      // we can't take the video.js controls fullscreen but we can go fullscreen\n      // with native controls\n      this.techCall_('enterFullScreen');\n    } else {\n      // fullscreen isn't supported so we'll just stretch the video element to\n      // fill the viewport\n      this.enterFullWindow();\n    }\n  }\n  /**\n   * Return the video to its normal size after having been in full screen mode\n   *\n   * @fires Player#fullscreenchange\n   */\n  ;\n\n  _proto.exitFullscreen = function exitFullscreen() {\n    var PromiseClass = this.options_.Promise || window$1.Promise;\n\n    if (PromiseClass) {\n      var self = this;\n      return new PromiseClass(function (resolve, reject) {\n        function offHandler() {\n          self.off('fullscreenerror', errorHandler);\n          self.off('fullscreenchange', changeHandler);\n        }\n\n        function changeHandler() {\n          offHandler();\n          resolve();\n        }\n\n        function errorHandler(e, err) {\n          offHandler();\n          reject(err);\n        }\n\n        self.one('fullscreenchange', changeHandler);\n        self.one('fullscreenerror', errorHandler);\n        var promise = self.exitFullscreenHelper_();\n\n        if (promise) {\n          promise.then(offHandler, offHandler);\n          return promise;\n        }\n      });\n    }\n\n    return this.exitFullscreenHelper_();\n  };\n\n  _proto.exitFullscreenHelper_ = function exitFullscreenHelper_() {\n    var _this11 = this;\n\n    if (this.fsApi_.requestFullscreen) {\n      var promise = document[this.fsApi_.exitFullscreen]();\n\n      if (promise) {\n        promise.then(function () {\n          return _this11.isFullscreen(false);\n        });\n      }\n\n      return promise;\n    } else if (this.tech_.supportsFullScreen()) {\n      this.techCall_('exitFullScreen');\n    } else {\n      this.exitFullWindow();\n    }\n  }\n  /**\n   * When fullscreen isn't supported we can stretch the\n   * video container to as wide as the browser will let us.\n   *\n   * @fires Player#enterFullWindow\n   */\n  ;\n\n  _proto.enterFullWindow = function enterFullWindow() {\n    this.isFullscreen(true);\n    this.isFullWindow = true; // Storing original doc overflow value to return to when fullscreen is off\n\n    this.docOrigOverflow = document.documentElement.style.overflow; // Add listener for esc key to exit fullscreen\n\n    on(document, 'keydown', this.boundFullWindowOnEscKey_); // Hide any scroll bars\n\n    document.documentElement.style.overflow = 'hidden'; // Apply fullscreen styles\n\n    addClass(document.body, 'vjs-full-window');\n    /**\n     * @event Player#enterFullWindow\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('enterFullWindow');\n  }\n  /**\n   * Check for call to either exit full window or\n   * full screen on ESC key\n   *\n   * @param {string} event\n   *        Event to check for key press\n   */\n  ;\n\n  _proto.fullWindowOnEscKey = function fullWindowOnEscKey(event) {\n    if (keycode.isEventKey(event, 'Esc')) {\n      if (this.isFullscreen() === true) {\n        this.exitFullscreen();\n      } else {\n        this.exitFullWindow();\n      }\n    }\n  }\n  /**\n   * Exit full window\n   *\n   * @fires Player#exitFullWindow\n   */\n  ;\n\n  _proto.exitFullWindow = function exitFullWindow() {\n    this.isFullscreen(false);\n    this.isFullWindow = false;\n    off(document, 'keydown', this.boundFullWindowOnEscKey_); // Unhide scroll bars.\n\n    document.documentElement.style.overflow = this.docOrigOverflow; // Remove fullscreen styles\n\n    removeClass(document.body, 'vjs-full-window'); // Resize the box, controller, and poster to original sizes\n    // this.positionAll();\n\n    /**\n     * @event Player#exitFullWindow\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('exitFullWindow');\n  }\n  /**\n   * Disable Picture-in-Picture mode.\n   *\n   * @param {boolean} value\n   *                  - true will disable Picture-in-Picture mode\n   *                  - false will enable Picture-in-Picture mode\n   */\n  ;\n\n  _proto.disablePictureInPicture = function disablePictureInPicture(value) {\n    if (value === undefined) {\n      return this.techGet_('disablePictureInPicture');\n    }\n\n    this.techCall_('setDisablePictureInPicture', value);\n    this.options_.disablePictureInPicture = value;\n    this.trigger('disablepictureinpicturechanged');\n  }\n  /**\n   * Check if the player is in Picture-in-Picture mode or tell the player that it\n   * is or is not in Picture-in-Picture mode.\n   *\n   * @param  {boolean} [isPiP]\n   *         Set the players current Picture-in-Picture state\n   *\n   * @return {boolean}\n   *         - true if Picture-in-Picture is on and getting\n   *         - false if Picture-in-Picture is off and getting\n   */\n  ;\n\n  _proto.isInPictureInPicture = function isInPictureInPicture(isPiP) {\n    if (isPiP !== undefined) {\n      this.isInPictureInPicture_ = !!isPiP;\n      this.togglePictureInPictureClass_();\n      return;\n    }\n\n    return !!this.isInPictureInPicture_;\n  }\n  /**\n   * Create a floating video window always on top of other windows so that users may\n   * continue consuming media while they interact with other content sites, or\n   * applications on their device.\n   *\n   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n   *\n   * @fires Player#enterpictureinpicture\n   *\n   * @return {Promise}\n   *         A promise with a Picture-in-Picture window.\n   */\n  ;\n\n  _proto.requestPictureInPicture = function requestPictureInPicture() {\n    if ('pictureInPictureEnabled' in document && this.disablePictureInPicture() === false) {\n      /**\n       * This event fires when the player enters picture in picture mode\n       *\n       * @event Player#enterpictureinpicture\n       * @type {EventTarget~Event}\n       */\n      return this.techGet_('requestPictureInPicture');\n    }\n  }\n  /**\n   * Exit Picture-in-Picture mode.\n   *\n   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n   *\n   * @fires Player#leavepictureinpicture\n   *\n   * @return {Promise}\n   *         A promise.\n   */\n  ;\n\n  _proto.exitPictureInPicture = function exitPictureInPicture() {\n    if ('pictureInPictureEnabled' in document) {\n      /**\n       * This event fires when the player leaves picture in picture mode\n       *\n       * @event Player#leavepictureinpicture\n       * @type {EventTarget~Event}\n       */\n      return document.exitPictureInPicture();\n    }\n  }\n  /**\n   * Called when this Player has focus and a key gets pressed down, or when\n   * any Component of this player receives a key press that it doesn't handle.\n   * This allows player-wide hotkeys (either as defined below, or optionally\n   * by an external function).\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n  ;\n\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    var userActions = this.options_.userActions; // Bail out if hotkeys are not configured.\n\n    if (!userActions || !userActions.hotkeys) {\n      return;\n    } // Function that determines whether or not to exclude an element from\n    // hotkeys handling.\n\n\n    var excludeElement = function excludeElement(el) {\n      var tagName = el.tagName.toLowerCase(); // The first and easiest test is for `contenteditable` elements.\n\n      if (el.isContentEditable) {\n        return true;\n      } // Inputs matching these types will still trigger hotkey handling as\n      // they are not text inputs.\n\n\n      var allowedInputTypes = ['button', 'checkbox', 'hidden', 'radio', 'reset', 'submit'];\n\n      if (tagName === 'input') {\n        return allowedInputTypes.indexOf(el.type) === -1;\n      } // The final test is by tag name. These tags will be excluded entirely.\n\n\n      var excludedTags = ['textarea'];\n      return excludedTags.indexOf(tagName) !== -1;\n    }; // Bail out if the user is focused on an interactive form element.\n\n\n    if (excludeElement(this.el_.ownerDocument.activeElement)) {\n      return;\n    }\n\n    if (typeof userActions.hotkeys === 'function') {\n      userActions.hotkeys.call(this, event);\n    } else {\n      this.handleHotkeys(event);\n    }\n  }\n  /**\n   * Called when this Player receives a hotkey keydown event.\n   * Supported player-wide hotkeys are:\n   *\n   *   f          - toggle fullscreen\n   *   m          - toggle mute\n   *   k or Space - toggle play/pause\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   */\n  ;\n\n  _proto.handleHotkeys = function handleHotkeys(event) {\n    var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {}; // set fullscreenKey, muteKey, playPauseKey from `hotkeys`, use defaults if not set\n\n    var _hotkeys$fullscreenKe = hotkeys.fullscreenKey,\n        fullscreenKey = _hotkeys$fullscreenKe === void 0 ? function (keydownEvent) {\n      return keycode.isEventKey(keydownEvent, 'f');\n    } : _hotkeys$fullscreenKe,\n        _hotkeys$muteKey = hotkeys.muteKey,\n        muteKey = _hotkeys$muteKey === void 0 ? function (keydownEvent) {\n      return keycode.isEventKey(keydownEvent, 'm');\n    } : _hotkeys$muteKey,\n        _hotkeys$playPauseKey = hotkeys.playPauseKey,\n        playPauseKey = _hotkeys$playPauseKey === void 0 ? function (keydownEvent) {\n      return keycode.isEventKey(keydownEvent, 'k') || keycode.isEventKey(keydownEvent, 'Space');\n    } : _hotkeys$playPauseKey;\n\n    if (fullscreenKey.call(this, event)) {\n      event.preventDefault();\n      event.stopPropagation();\n      var FSToggle = Component.getComponent('FullscreenToggle');\n\n      if (document[this.fsApi_.fullscreenEnabled] !== false) {\n        FSToggle.prototype.handleClick.call(this, event);\n      }\n    } else if (muteKey.call(this, event)) {\n      event.preventDefault();\n      event.stopPropagation();\n      var MuteToggle = Component.getComponent('MuteToggle');\n      MuteToggle.prototype.handleClick.call(this, event);\n    } else if (playPauseKey.call(this, event)) {\n      event.preventDefault();\n      event.stopPropagation();\n      var PlayToggle = Component.getComponent('PlayToggle');\n      PlayToggle.prototype.handleClick.call(this, event);\n    }\n  }\n  /**\n   * Check whether the player can play a given mimetype\n   *\n   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n   *\n   * @param {string} type\n   *        The mimetype to check\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  ;\n\n  _proto.canPlayType = function canPlayType(type) {\n    var can; // Loop through each playback technology in the options order\n\n    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {\n      var techName = j[i];\n      var tech = Tech.getTech(techName); // Support old behavior of techs being registered as components.\n      // Remove once that deprecated behavior is removed.\n\n      if (!tech) {\n        tech = Component.getComponent(techName);\n      } // Check if the current tech is defined before continuing\n\n\n      if (!tech) {\n        log.error(\"The \\\"\" + techName + \"\\\" tech is undefined. Skipped browser support check for that tech.\");\n        continue;\n      } // Check if the browser supports this technology\n\n\n      if (tech.isSupported()) {\n        can = tech.canPlayType(type);\n\n        if (can) {\n          return can;\n        }\n      }\n    }\n\n    return '';\n  }\n  /**\n   * Select source based on tech-order or source-order\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n   * defaults to tech-order selection\n   *\n   * @param {Array} sources\n   *        The sources for a media asset\n   *\n   * @return {Object|boolean}\n   *         Object of source and tech order or false\n   */\n  ;\n\n  _proto.selectSource = function selectSource(sources) {\n    var _this12 = this; // Get only the techs specified in `techOrder` that exist and are supported by the\n    // current platform\n\n\n    var techs = this.options_.techOrder.map(function (techName) {\n      return [techName, Tech.getTech(techName)];\n    }).filter(function (_ref) {\n      var techName = _ref[0],\n          tech = _ref[1]; // Check if the current tech is defined before continuing\n\n      if (tech) {\n        // Check if the browser supports this technology\n        return tech.isSupported();\n      }\n\n      log.error(\"The \\\"\" + techName + \"\\\" tech is undefined. Skipped browser support check for that tech.\");\n      return false;\n    }); // Iterate over each `innerArray` element once per `outerArray` element and execute\n    // `tester` with both. If `tester` returns a non-falsy value, exit early and return\n    // that value.\n\n    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {\n      var found;\n      outerArray.some(function (outerChoice) {\n        return innerArray.some(function (innerChoice) {\n          found = tester(outerChoice, innerChoice);\n\n          if (found) {\n            return true;\n          }\n        });\n      });\n      return found;\n    };\n\n    var foundSourceAndTech;\n\n    var flip = function flip(fn) {\n      return function (a, b) {\n        return fn(b, a);\n      };\n    };\n\n    var finder = function finder(_ref2, source) {\n      var techName = _ref2[0],\n          tech = _ref2[1];\n\n      if (tech.canPlaySource(source, _this12.options_[techName.toLowerCase()])) {\n        return {\n          source: source,\n          tech: techName\n        };\n      }\n    }; // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n    // to select from them based on their priority.\n\n\n    if (this.options_.sourceOrder) {\n      // Source-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\n    } else {\n      // Tech-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\n    }\n\n    return foundSourceAndTech || false;\n  }\n  /**\n   * Get or set the video source.\n   *\n   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n   *        A SourceObject, an array of SourceObjects, or a string referencing\n   *        a URL to a media source. It is _highly recommended_ that an object\n   *        or array of objects is used here, so that source selection\n   *        algorithms can take the `type` into account.\n   *\n   *        If not provided, this method acts as a getter.\n   *\n   * @return {string|undefined}\n   *         If the `source` argument is missing, returns the current source\n   *         URL. Otherwise, returns nothing/undefined.\n   */\n  ;\n\n  _proto.src = function src(source) {\n    var _this13 = this; // getter usage\n\n\n    if (typeof source === 'undefined') {\n      return this.cache_.src || '';\n    } // filter out invalid sources and turn our source into\n    // an array of source objects\n\n\n    var sources = filterSource(source); // if a source was passed in then it is invalid because\n    // it was filtered to a zero length Array. So we have to\n    // show an error\n\n    if (!sources.length) {\n      this.setTimeout(function () {\n        this.error({\n          code: 4,\n          message: this.localize(this.options_.notSupportedMessage)\n        });\n      }, 0);\n      return;\n    } // initial sources\n\n\n    this.changingSrc_ = true;\n    this.cache_.sources = sources;\n    this.updateSourceCaches_(sources[0]); // middlewareSource is the source after it has been changed by middleware\n\n    setSource(this, sources[0], function (middlewareSource, mws) {\n      _this13.middleware_ = mws; // since sourceSet is async we have to update the cache again after we select a source since\n      // the source that is selected could be out of order from the cache update above this callback.\n\n      _this13.cache_.sources = sources;\n\n      _this13.updateSourceCaches_(middlewareSource);\n\n      var err = _this13.src_(middlewareSource);\n\n      if (err) {\n        if (sources.length > 1) {\n          return _this13.src(sources.slice(1));\n        }\n\n        _this13.changingSrc_ = false; // We need to wrap this in a timeout to give folks a chance to add error event handlers\n\n        _this13.setTimeout(function () {\n          this.error({\n            code: 4,\n            message: this.localize(this.options_.notSupportedMessage)\n          });\n        }, 0); // we could not find an appropriate tech, but let's still notify the delegate that this is it\n        // this needs a better comment about why this is needed\n\n\n        _this13.triggerReady();\n\n        return;\n      }\n\n      setTech(mws, _this13.tech_);\n    });\n  }\n  /**\n   * Set the source object on the tech, returns a boolean that indicates whether\n   * there is a tech that can play the source or not\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object to set on the Tech\n   *\n   * @return {boolean}\n   *         - True if there is no Tech to playback this source\n   *         - False otherwise\n   *\n   * @private\n   */\n  ;\n\n  _proto.src_ = function src_(source) {\n    var _this14 = this;\n\n    var sourceTech = this.selectSource([source]);\n\n    if (!sourceTech) {\n      return true;\n    }\n\n    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\n      this.changingSrc_ = true; // load this technology with the chosen source\n\n      this.loadTech_(sourceTech.tech, sourceTech.source);\n      this.tech_.ready(function () {\n        _this14.changingSrc_ = false;\n      });\n      return false;\n    } // wait until the tech is ready to set the source\n    // and set it synchronously if possible (#2326)\n\n\n    this.ready(function () {\n      // The setSource tech method was added with source handlers\n      // so older techs won't support it\n      // We need to check the direct prototype for the case where subclasses\n      // of the tech do not support source handlers\n      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\n        this.techCall_('setSource', source);\n      } else {\n        this.techCall_('src', source.src);\n      }\n\n      this.changingSrc_ = false;\n    }, true);\n    return false;\n  }\n  /**\n   * Begin loading the src data.\n   */\n  ;\n\n  _proto.load = function load() {\n    this.techCall_('load');\n  }\n  /**\n   * Reset the player. Loads the first tech in the techOrder,\n   * removes all the text tracks in the existing `tech`,\n   * and calls `reset` on the `tech`.\n   */\n  ;\n\n  _proto.reset = function reset() {\n    var _this15 = this;\n\n    var PromiseClass = this.options_.Promise || window$1.Promise;\n\n    if (this.paused() || !PromiseClass) {\n      this.doReset_();\n    } else {\n      var playPromise = this.play();\n      silencePromise(playPromise.then(function () {\n        return _this15.doReset_();\n      }));\n    }\n  };\n\n  _proto.doReset_ = function doReset_() {\n    if (this.tech_) {\n      this.tech_.clearTracks('text');\n    }\n\n    this.resetCache_();\n    this.poster('');\n    this.loadTech_(this.options_.techOrder[0], null);\n    this.techCall_('reset');\n    this.resetControlBarUI_();\n\n    if (isEvented(this)) {\n      this.trigger('playerreset');\n    }\n  }\n  /**\n   * Reset Control Bar's UI by calling sub-methods that reset\n   * all of Control Bar's components\n   */\n  ;\n\n  _proto.resetControlBarUI_ = function resetControlBarUI_() {\n    this.resetProgressBar_();\n    this.resetPlaybackRate_();\n    this.resetVolumeBar_();\n  }\n  /**\n   * Reset tech's progress so progress bar is reset in the UI\n   */\n  ;\n\n  _proto.resetProgressBar_ = function resetProgressBar_() {\n    this.currentTime(0);\n    var _this$controlBar = this.controlBar,\n        durationDisplay = _this$controlBar.durationDisplay,\n        remainingTimeDisplay = _this$controlBar.remainingTimeDisplay;\n\n    if (durationDisplay) {\n      durationDisplay.updateContent();\n    }\n\n    if (remainingTimeDisplay) {\n      remainingTimeDisplay.updateContent();\n    }\n  }\n  /**\n   * Reset Playback ratio\n   */\n  ;\n\n  _proto.resetPlaybackRate_ = function resetPlaybackRate_() {\n    this.playbackRate(this.defaultPlaybackRate());\n    this.handleTechRateChange_();\n  }\n  /**\n   * Reset Volume bar\n   */\n  ;\n\n  _proto.resetVolumeBar_ = function resetVolumeBar_() {\n    this.volume(1.0);\n    this.trigger('volumechange');\n  }\n  /**\n   * Returns all of the current source objects.\n   *\n   * @return {Tech~SourceObject[]}\n   *         The current source objects\n   */\n  ;\n\n  _proto.currentSources = function currentSources() {\n    var source = this.currentSource();\n    var sources = []; // assume `{}` or `{ src }`\n\n    if (Object.keys(source).length !== 0) {\n      sources.push(source);\n    }\n\n    return this.cache_.sources || sources;\n  }\n  /**\n   * Returns the current source object.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object\n   */\n  ;\n\n  _proto.currentSource = function currentSource() {\n    return this.cache_.source || {};\n  }\n  /**\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n   * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.\n   *\n   * @return {string}\n   *         The current source\n   */\n  ;\n\n  _proto.currentSrc = function currentSrc() {\n    return this.currentSource() && this.currentSource().src || '';\n  }\n  /**\n   * Get the current source type e.g. video/mp4\n   * This can allow you rebuild the current source object so that you could load the same\n   * source and tech later\n   *\n   * @return {string}\n   *         The source MIME type\n   */\n  ;\n\n  _proto.currentType = function currentType() {\n    return this.currentSource() && this.currentSource().type || '';\n  }\n  /**\n   * Get or set the preload attribute\n   *\n   * @param {boolean} [value]\n   *        - true means that we should preload\n   *        - false means that we should not preload\n   *\n   * @return {string}\n   *         The preload attribute value when getting\n   */\n  ;\n\n  _proto.preload = function preload(value) {\n    if (value !== undefined) {\n      this.techCall_('setPreload', value);\n      this.options_.preload = value;\n      return;\n    }\n\n    return this.techGet_('preload');\n  }\n  /**\n   * Get or set the autoplay option. When this is a boolean it will\n   * modify the attribute on the tech. When this is a string the attribute on\n   * the tech will be removed and `Player` will handle autoplay on loadstarts.\n   *\n   * @param {boolean|string} [value]\n   *        - true: autoplay using the browser behavior\n   *        - false: do not autoplay\n   *        - 'play': call play() on every loadstart\n   *        - 'muted': call muted() then play() on every loadstart\n   *        - 'any': call play() on every loadstart. if that fails call muted() then play().\n   *        - *: values other than those listed here will be set `autoplay` to true\n   *\n   * @return {boolean|string}\n   *         The current value of autoplay when getting\n   */\n  ;\n\n  _proto.autoplay = function autoplay(value) {\n    // getter usage\n    if (value === undefined) {\n      return this.options_.autoplay || false;\n    }\n\n    var techAutoplay; // if the value is a valid string set it to that\n\n    if (typeof value === 'string' && /(any|play|muted)/.test(value)) {\n      this.options_.autoplay = value;\n      this.manualAutoplay_(value);\n      techAutoplay = false; // any falsy value sets autoplay to false in the browser,\n      // lets do the same\n    } else if (!value) {\n      this.options_.autoplay = false; // any other value (ie truthy) sets autoplay to true\n    } else {\n      this.options_.autoplay = true;\n    }\n\n    techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay; // if we don't have a tech then we do not queue up\n    // a setAutoplay call on tech ready. We do this because the\n    // autoplay option will be passed in the constructor and we\n    // do not need to set it twice\n\n    if (this.tech_) {\n      this.techCall_('setAutoplay', techAutoplay);\n    }\n  }\n  /**\n   * Set or unset the playsinline attribute.\n   * Playsinline tells the browser that non-fullscreen playback is preferred.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should try to play inline by default\n   *        - false means that we should use the browser's default playback mode,\n   *          which in most cases is inline. iOS Safari is a notable exception\n   *          and plays fullscreen by default.\n   *\n   * @return {string|Player}\n   *         - the current value of playsinline\n   *         - the player when setting\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */\n  ;\n\n  _proto.playsinline = function playsinline(value) {\n    if (value !== undefined) {\n      this.techCall_('setPlaysinline', value);\n      this.options_.playsinline = value;\n      return this;\n    }\n\n    return this.techGet_('playsinline');\n  }\n  /**\n   * Get or set the loop attribute on the video element.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should loop the video\n   *        - false means that we should not loop the video\n   *\n   * @return {boolean}\n   *         The current value of loop when getting\n   */\n  ;\n\n  _proto.loop = function loop(value) {\n    if (value !== undefined) {\n      this.techCall_('setLoop', value);\n      this.options_.loop = value;\n      return;\n    }\n\n    return this.techGet_('loop');\n  }\n  /**\n   * Get or set the poster image source url\n   *\n   * @fires Player#posterchange\n   *\n   * @param {string} [src]\n   *        Poster image source URL\n   *\n   * @return {string}\n   *         The current value of poster when getting\n   */\n  ;\n\n  _proto.poster = function poster(src) {\n    if (src === undefined) {\n      return this.poster_;\n    } // The correct way to remove a poster is to set as an empty string\n    // other falsey values will throw errors\n\n\n    if (!src) {\n      src = '';\n    }\n\n    if (src === this.poster_) {\n      return;\n    } // update the internal poster variable\n\n\n    this.poster_ = src; // update the tech's poster\n\n    this.techCall_('setPoster', src);\n    this.isPosterFromTech_ = false; // alert components that the poster has been set\n\n    /**\n     * This event fires when the poster image is changed on the player.\n     *\n     * @event Player#posterchange\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('posterchange');\n  }\n  /**\n   * Some techs (e.g. YouTube) can provide a poster source in an\n   * asynchronous way. We want the poster component to use this\n   * poster source so that it covers up the tech's controls.\n   * (YouTube's play button). However we only want to use this\n   * source if the player user hasn't set a poster through\n   * the normal APIs.\n   *\n   * @fires Player#posterchange\n   * @listens Tech#posterchange\n   * @private\n   */\n  ;\n\n  _proto.handleTechPosterChange_ = function handleTechPosterChange_() {\n    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {\n      var newPoster = this.tech_.poster() || '';\n\n      if (newPoster !== this.poster_) {\n        this.poster_ = newPoster;\n        this.isPosterFromTech_ = true; // Let components know the poster has changed\n\n        this.trigger('posterchange');\n      }\n    }\n  }\n  /**\n   * Get or set whether or not the controls are showing.\n   *\n   * @fires Player#controlsenabled\n   *\n   * @param {boolean} [bool]\n   *        - true to turn controls on\n   *        - false to turn controls off\n   *\n   * @return {boolean}\n   *         The current value of controls when getting\n   */\n  ;\n\n  _proto.controls = function controls(bool) {\n    if (bool === undefined) {\n      return !!this.controls_;\n    }\n\n    bool = !!bool; // Don't trigger a change event unless it actually changed\n\n    if (this.controls_ === bool) {\n      return;\n    }\n\n    this.controls_ = bool;\n\n    if (this.usingNativeControls()) {\n      this.techCall_('setControls', bool);\n    }\n\n    if (this.controls_) {\n      this.removeClass('vjs-controls-disabled');\n      this.addClass('vjs-controls-enabled');\n      /**\n       * @event Player#controlsenabled\n       * @type {EventTarget~Event}\n       */\n\n      this.trigger('controlsenabled');\n\n      if (!this.usingNativeControls()) {\n        this.addTechControlsListeners_();\n      }\n    } else {\n      this.removeClass('vjs-controls-enabled');\n      this.addClass('vjs-controls-disabled');\n      /**\n       * @event Player#controlsdisabled\n       * @type {EventTarget~Event}\n       */\n\n      this.trigger('controlsdisabled');\n\n      if (!this.usingNativeControls()) {\n        this.removeTechControlsListeners_();\n      }\n    }\n  }\n  /**\n   * Toggle native controls on/off. Native controls are the controls built into\n   * devices (e.g. default iPhone controls), Flash, or other techs\n   * (e.g. Vimeo Controls)\n   * **This should only be set by the current tech, because only the tech knows\n   * if it can support native controls**\n   *\n   * @fires Player#usingnativecontrols\n   * @fires Player#usingcustomcontrols\n   *\n   * @param {boolean} [bool]\n   *        - true to turn native controls on\n   *        - false to turn native controls off\n   *\n   * @return {boolean}\n   *         The current value of native controls when getting\n   */\n  ;\n\n  _proto.usingNativeControls = function usingNativeControls(bool) {\n    if (bool === undefined) {\n      return !!this.usingNativeControls_;\n    }\n\n    bool = !!bool; // Don't trigger a change event unless it actually changed\n\n    if (this.usingNativeControls_ === bool) {\n      return;\n    }\n\n    this.usingNativeControls_ = bool;\n\n    if (this.usingNativeControls_) {\n      this.addClass('vjs-using-native-controls');\n      /**\n       * player is using the native device controls\n       *\n       * @event Player#usingnativecontrols\n       * @type {EventTarget~Event}\n       */\n\n      this.trigger('usingnativecontrols');\n    } else {\n      this.removeClass('vjs-using-native-controls');\n      /**\n       * player is using the custom HTML controls\n       *\n       * @event Player#usingcustomcontrols\n       * @type {EventTarget~Event}\n       */\n\n      this.trigger('usingcustomcontrols');\n    }\n  }\n  /**\n   * Set or get the current MediaError\n   *\n   * @fires Player#error\n   *\n   * @param  {MediaError|string|number} [err]\n   *         A MediaError or a string/number to be turned\n   *         into a MediaError\n   *\n   * @return {MediaError|null}\n   *         The current MediaError when getting (or null)\n   */\n  ;\n\n  _proto.error = function error(err) {\n    if (err === undefined) {\n      return this.error_ || null;\n    } // Suppress the first error message for no compatible source until\n    // user interaction\n\n\n    if (this.options_.suppressNotSupportedError && err && err.code === 4) {\n      var triggerSuppressedError = function triggerSuppressedError() {\n        this.error(err);\n      };\n\n      this.options_.suppressNotSupportedError = false;\n      this.any(['click', 'touchstart'], triggerSuppressedError);\n      this.one('loadstart', function () {\n        this.off(['click', 'touchstart'], triggerSuppressedError);\n      });\n      return;\n    } // restoring to default\n\n\n    if (err === null) {\n      this.error_ = err;\n      this.removeClass('vjs-error');\n\n      if (this.errorDisplay) {\n        this.errorDisplay.close();\n      }\n\n      return;\n    }\n\n    this.error_ = new MediaError(err); // add the vjs-error classname to the player\n\n    this.addClass('vjs-error'); // log the name of the error type and any message\n    // IE11 logs \"[object object]\" and required you to expand message to see error object\n\n    log.error(\"(CODE:\" + this.error_.code + \" \" + MediaError.errorTypes[this.error_.code] + \")\", this.error_.message, this.error_);\n    /**\n     * @event Player#error\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('error');\n    return;\n  }\n  /**\n   * Report user activity\n   *\n   * @param {Object} event\n   *        Event object\n   */\n  ;\n\n  _proto.reportUserActivity = function reportUserActivity(event) {\n    this.userActivity_ = true;\n  }\n  /**\n   * Get/set if user is active\n   *\n   * @fires Player#useractive\n   * @fires Player#userinactive\n   *\n   * @param {boolean} [bool]\n   *        - true if the user is active\n   *        - false if the user is inactive\n   *\n   * @return {boolean}\n   *         The current value of userActive when getting\n   */\n  ;\n\n  _proto.userActive = function userActive(bool) {\n    if (bool === undefined) {\n      return this.userActive_;\n    }\n\n    bool = !!bool;\n\n    if (bool === this.userActive_) {\n      return;\n    }\n\n    this.userActive_ = bool;\n\n    if (this.userActive_) {\n      this.userActivity_ = true;\n      this.removeClass('vjs-user-inactive');\n      this.addClass('vjs-user-active');\n      /**\n       * @event Player#useractive\n       * @type {EventTarget~Event}\n       */\n\n      this.trigger('useractive');\n      return;\n    } // Chrome/Safari/IE have bugs where when you change the cursor it can\n    // trigger a mousemove event. This causes an issue when you're hiding\n    // the cursor when the user is inactive, and a mousemove signals user\n    // activity. Making it impossible to go into inactive mode. Specifically\n    // this happens in fullscreen when we really need to hide the cursor.\n    //\n    // When this gets resolved in ALL browsers it can be removed\n    // https://code.google.com/p/chromium/issues/detail?id=103041\n\n\n    if (this.tech_) {\n      this.tech_.one('mousemove', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n      });\n    }\n\n    this.userActivity_ = false;\n    this.removeClass('vjs-user-active');\n    this.addClass('vjs-user-inactive');\n    /**\n     * @event Player#userinactive\n     * @type {EventTarget~Event}\n     */\n\n    this.trigger('userinactive');\n  }\n  /**\n   * Listen for user activity based on timeout value\n   *\n   * @private\n   */\n  ;\n\n  _proto.listenForUserActivity_ = function listenForUserActivity_() {\n    var mouseInProgress;\n    var lastMoveX;\n    var lastMoveY;\n    var handleActivity = bind(this, this.reportUserActivity);\n\n    var handleMouseMove = function handleMouseMove(e) {\n      // #1068 - Prevent mousemove spamming\n      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\n      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\n        lastMoveX = e.screenX;\n        lastMoveY = e.screenY;\n        handleActivity();\n      }\n    };\n\n    var handleMouseDown = function handleMouseDown() {\n      handleActivity(); // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n\n      this.clearInterval(mouseInProgress); // Setting userActivity=true now and setting the interval to the same time\n      // as the activityCheck interval (250) should ensure we never miss the\n      // next activityCheck\n\n      mouseInProgress = this.setInterval(handleActivity, 250);\n    };\n\n    var handleMouseUpAndMouseLeave = function handleMouseUpAndMouseLeave(event) {\n      handleActivity(); // Stop the interval that maintains activity if the mouse/touch is down\n\n      this.clearInterval(mouseInProgress);\n    }; // Any mouse movement will be considered user activity\n\n\n    this.on('mousedown', handleMouseDown);\n    this.on('mousemove', handleMouseMove);\n    this.on('mouseup', handleMouseUpAndMouseLeave);\n    this.on('mouseleave', handleMouseUpAndMouseLeave);\n    var controlBar = this.getChild('controlBar'); // Fixes bug on Android & iOS where when tapping progressBar (when control bar is displayed)\n    // controlBar would no longer be hidden by default timeout.\n\n    if (controlBar && !IS_IOS && !IS_ANDROID) {\n      controlBar.on('mouseenter', function (event) {\n        this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;\n        this.player().options_.inactivityTimeout = 0;\n      });\n      controlBar.on('mouseleave', function (event) {\n        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;\n      });\n    } // Listen for keyboard navigation\n    // Shouldn't need to use inProgress interval because of key repeat\n\n\n    this.on('keydown', handleActivity);\n    this.on('keyup', handleActivity); // Run an interval every 250 milliseconds instead of stuffing everything into\n    // the mousemove/touchmove function itself, to prevent performance degradation.\n    // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n    // then gets picked up by this loop\n    // http://ejohn.org/blog/learning-from-twitter/\n\n    var inactivityTimeout;\n    this.setInterval(function () {\n      // Check to see if mouse/touch activity has happened\n      if (!this.userActivity_) {\n        return;\n      } // Reset the activity tracker\n\n\n      this.userActivity_ = false; // If the user state was inactive, set the state to active\n\n      this.userActive(true); // Clear any existing inactivity timeout to start the timer over\n\n      this.clearTimeout(inactivityTimeout);\n      var timeout = this.options_.inactivityTimeout;\n\n      if (timeout <= 0) {\n        return;\n      } // In <timeout> milliseconds, if no more activity has occurred the\n      // user will be considered inactive\n\n\n      inactivityTimeout = this.setTimeout(function () {\n        // Protect against the case where the inactivityTimeout can trigger just\n        // before the next user activity is picked up by the activity check loop\n        // causing a flicker\n        if (!this.userActivity_) {\n          this.userActive(false);\n        }\n      }, timeout);\n    }, 250);\n  }\n  /**\n   * Gets or sets the current playback rate. A playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\n   * playback, for instance.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n   *\n   * @param {number} [rate]\n   *       New playback rate to set.\n   *\n   * @return {number}\n   *         The current playback rate when getting or 1.0\n   */\n  ;\n\n  _proto.playbackRate = function playbackRate(rate) {\n    if (rate !== undefined) {\n      // NOTE: this.cache_.lastPlaybackRate is set from the tech handler\n      // that is registered above\n      this.techCall_('setPlaybackRate', rate);\n      return;\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');\n    }\n\n    return 1.0;\n  }\n  /**\n   * Gets or sets the current default playback rate. A default playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n   * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not\n   * not the current playbackRate.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n   *\n   * @param {number} [rate]\n   *       New default playback rate to set.\n   *\n   * @return {number|Player}\n   *         - The default playback rate when getting or 1.0\n   *         - the player when setting\n   */\n  ;\n\n  _proto.defaultPlaybackRate = function defaultPlaybackRate(rate) {\n    if (rate !== undefined) {\n      return this.techCall_('setDefaultPlaybackRate', rate);\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.techGet_('defaultPlaybackRate');\n    }\n\n    return 1.0;\n  }\n  /**\n   * Gets or sets the audio flag\n   *\n   * @param {boolean} bool\n   *        - true signals that this is an audio player\n   *        - false signals that this is not an audio player\n   *\n   * @return {boolean}\n   *         The current value of isAudio when getting\n   */\n  ;\n\n  _proto.isAudio = function isAudio(bool) {\n    if (bool !== undefined) {\n      this.isAudio_ = !!bool;\n      return;\n    }\n\n    return !!this.isAudio_;\n  }\n  /**\n   * A helper method for adding a {@link TextTrack} to our\n   * {@link TextTrackList}.\n   *\n   * In addition to the W3C settings we allow adding additional info through options.\n   *\n   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n   *\n   * @param {string} [kind]\n   *        the kind of TextTrack you are adding\n   *\n   * @param {string} [label]\n   *        the label to give the TextTrack label\n   *\n   * @param {string} [language]\n   *        the language to set on the TextTrack\n   *\n   * @return {TextTrack|undefined}\n   *         the TextTrack that was added or undefined\n   *         if there is no tech\n   */\n  ;\n\n  _proto.addTextTrack = function addTextTrack(kind, label, language) {\n    if (this.tech_) {\n      return this.tech_.addTextTrack(kind, label, language);\n    }\n  }\n  /**\n   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.\n   * When manualCleanup is set to false, the track will be automatically removed\n   * on source changes.\n   *\n   * @param {Object} options\n   *        Options to pass to {@link HTMLTrackElement} during creation. See\n   *        {@link HTMLTrackElement} for object properties that you should use.\n   *\n   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   *                                       removed on a source change\n   *\n   * @return {HtmlTrackElement}\n   *         the HTMLTrackElement that was created and added\n   *         to the HtmlTrackElementList and the remote\n   *         TextTrackList\n   *\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   *             to \"false\" in upcoming versions of Video.js\n   */\n  ;\n\n  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    if (this.tech_) {\n      return this.tech_.addRemoteTextTrack(options, manualCleanup);\n    }\n  }\n  /**\n   * Remove a remote {@link TextTrack} from the respective\n   * {@link TextTrackList} and {@link HtmlTrackElementList}.\n   *\n   * @param {Object} track\n   *        Remote {@link TextTrack} to remove\n   *\n   * @return {undefined}\n   *         does not return anything\n   */\n  ;\n\n  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(obj) {\n    if (obj === void 0) {\n      obj = {};\n    }\n\n    var _obj = obj,\n        track = _obj.track;\n\n    if (!track) {\n      track = obj;\n    } // destructure the input into an object with a track argument, defaulting to arguments[0]\n    // default the whole argument to an empty object if nothing was passed in\n\n\n    if (this.tech_) {\n      return this.tech_.removeRemoteTextTrack(track);\n    }\n  }\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object|undefined}\n   *         An object with supported media playback quality metrics or undefined if there\n   *         is no tech or the tech does not support it.\n   */\n  ;\n\n  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return this.techGet_('getVideoPlaybackQuality');\n  }\n  /**\n   * Get video width\n   *\n   * @return {number}\n   *         current video width\n   */\n  ;\n\n  _proto.videoWidth = function videoWidth() {\n    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\n  }\n  /**\n   * Get video height\n   *\n   * @return {number}\n   *         current video height\n   */\n  ;\n\n  _proto.videoHeight = function videoHeight() {\n    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\n  }\n  /**\n   * The player's language code\n   * NOTE: The language should be set in the player options if you want the\n   * the controls to be built with a specific language. Changing the language\n   * later will not update controls text.\n   *\n   * @param {string} [code]\n   *        the language code to set the player to\n   *\n   * @return {string}\n   *         The current language code when getting\n   */\n  ;\n\n  _proto.language = function language(code) {\n    if (code === undefined) {\n      return this.language_;\n    }\n\n    this.language_ = String(code).toLowerCase();\n  }\n  /**\n   * Get the player's language dictionary\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n   * Languages specified directly in the player options have precedence\n   *\n   * @return {Array}\n   *         An array of of supported languages\n   */\n  ;\n\n  _proto.languages = function languages() {\n    return mergeOptions(Player.prototype.options_.languages, this.languages_);\n  }\n  /**\n   * returns a JavaScript object reperesenting the current track\n   * information. **DOES not return it as JSON**\n   *\n   * @return {Object}\n   *         Object representing the current of track info\n   */\n  ;\n\n  _proto.toJSON = function toJSON() {\n    var options = mergeOptions(this.options_);\n    var tracks = options.tracks;\n    options.tracks = [];\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i]; // deep merge tracks and null out player so no circular references\n\n      track = mergeOptions(track);\n      track.player = undefined;\n      options.tracks[i] = track;\n    }\n\n    return options;\n  }\n  /**\n   * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n   * component) that immediately overlays the player with arbitrary\n   * content and removes itself when closed.\n   *\n   * @param {string|Function|Element|Array|null} content\n   *        Same as {@link ModalDialog#content}'s param of the same name.\n   *        The most straight-forward usage is to provide a string or DOM\n   *        element.\n   *\n   * @param {Object} [options]\n   *        Extra options which will be passed on to the {@link ModalDialog}.\n   *\n   * @return {ModalDialog}\n   *         the {@link ModalDialog} that was created\n   */\n  ;\n\n  _proto.createModal = function createModal(content, options) {\n    var _this16 = this;\n\n    options = options || {};\n    options.content = content || '';\n    var modal = new ModalDialog(this, options);\n    this.addChild(modal);\n    modal.on('dispose', function () {\n      _this16.removeChild(modal);\n    });\n    modal.open();\n    return modal;\n  }\n  /**\n   * Change breakpoint classes when the player resizes.\n   *\n   * @private\n   */\n  ;\n\n  _proto.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {\n    if (!this.responsive()) {\n      return;\n    }\n\n    var currentBreakpoint = this.currentBreakpoint();\n    var currentWidth = this.currentWidth();\n\n    for (var i = 0; i < BREAKPOINT_ORDER.length; i++) {\n      var candidateBreakpoint = BREAKPOINT_ORDER[i];\n      var maxWidth = this.breakpoints_[candidateBreakpoint];\n\n      if (currentWidth <= maxWidth) {\n        // The current breakpoint did not change, nothing to do.\n        if (currentBreakpoint === candidateBreakpoint) {\n          return;\n        } // Only remove a class if there is a current breakpoint.\n\n\n        if (currentBreakpoint) {\n          this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);\n        }\n\n        this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);\n        this.breakpoint_ = candidateBreakpoint;\n        break;\n      }\n    }\n  }\n  /**\n   * Removes the current breakpoint.\n   *\n   * @private\n   */\n  ;\n\n  _proto.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {\n    var className = this.currentBreakpointClass();\n    this.breakpoint_ = '';\n\n    if (className) {\n      this.removeClass(className);\n    }\n  }\n  /**\n   * Get or set breakpoints on the player.\n   *\n   * Calling this method with an object or `true` will remove any previous\n   * custom breakpoints and start from the defaults again.\n   *\n   * @param  {Object|boolean} [breakpoints]\n   *         If an object is given, it can be used to provide custom\n   *         breakpoints. If `true` is given, will set default breakpoints.\n   *         If this argument is not given, will simply return the current\n   *         breakpoints.\n   *\n   * @param  {number} [breakpoints.tiny]\n   *         The maximum width for the \"vjs-layout-tiny\" class.\n   *\n   * @param  {number} [breakpoints.xsmall]\n   *         The maximum width for the \"vjs-layout-x-small\" class.\n   *\n   * @param  {number} [breakpoints.small]\n   *         The maximum width for the \"vjs-layout-small\" class.\n   *\n   * @param  {number} [breakpoints.medium]\n   *         The maximum width for the \"vjs-layout-medium\" class.\n   *\n   * @param  {number} [breakpoints.large]\n   *         The maximum width for the \"vjs-layout-large\" class.\n   *\n   * @param  {number} [breakpoints.xlarge]\n   *         The maximum width for the \"vjs-layout-x-large\" class.\n   *\n   * @param  {number} [breakpoints.huge]\n   *         The maximum width for the \"vjs-layout-huge\" class.\n   *\n   * @return {Object}\n   *         An object mapping breakpoint names to maximum width values.\n   */\n  ;\n\n  _proto.breakpoints = function breakpoints(_breakpoints) {\n    // Used as a getter.\n    if (_breakpoints === undefined) {\n      return assign(this.breakpoints_);\n    }\n\n    this.breakpoint_ = '';\n    this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints); // When breakpoint definitions change, we need to update the currently\n    // selected breakpoint.\n\n    this.updateCurrentBreakpoint_(); // Clone the breakpoints before returning.\n\n    return assign(this.breakpoints_);\n  }\n  /**\n   * Get or set a flag indicating whether or not this player should adjust\n   * its UI based on its dimensions.\n   *\n   * @param  {boolean} value\n   *         Should be `true` if the player should adjust its UI based on its\n   *         dimensions; otherwise, should be `false`.\n   *\n   * @return {boolean}\n   *         Will be `true` if this player should adjust its UI based on its\n   *         dimensions; otherwise, will be `false`.\n   */\n  ;\n\n  _proto.responsive = function responsive(value) {\n    // Used as a getter.\n    if (value === undefined) {\n      return this.responsive_;\n    }\n\n    value = Boolean(value);\n    var current = this.responsive_; // Nothing changed.\n\n    if (value === current) {\n      return;\n    } // The value actually changed, set it.\n\n\n    this.responsive_ = value; // Start listening for breakpoints and set the initial breakpoint if the\n    // player is now responsive.\n\n    if (value) {\n      this.on('playerresize', this.updateCurrentBreakpoint_);\n      this.updateCurrentBreakpoint_(); // Stop listening for breakpoints if the player is no longer responsive.\n    } else {\n      this.off('playerresize', this.updateCurrentBreakpoint_);\n      this.removeCurrentBreakpoint_();\n    }\n\n    return value;\n  }\n  /**\n   * Get current breakpoint name, if any.\n   *\n   * @return {string}\n   *         If there is currently a breakpoint set, returns a the key from the\n   *         breakpoints object matching it. Otherwise, returns an empty string.\n   */\n  ;\n\n  _proto.currentBreakpoint = function currentBreakpoint() {\n    return this.breakpoint_;\n  }\n  /**\n   * Get the current breakpoint class name.\n   *\n   * @return {string}\n   *         The matching class name (e.g. `\"vjs-layout-tiny\"` or\n   *         `\"vjs-layout-large\"`) for the current breakpoint. Empty string if\n   *         there is no current breakpoint.\n   */\n  ;\n\n  _proto.currentBreakpointClass = function currentBreakpointClass() {\n    return BREAKPOINT_CLASSES[this.breakpoint_] || '';\n  }\n  /**\n   * An object that describes a single piece of media.\n   *\n   * Properties that are not part of this type description will be retained; so,\n   * this can be viewed as a generic metadata storage mechanism as well.\n   *\n   * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}\n   * @typedef  {Object} Player~MediaObject\n   *\n   * @property {string} [album]\n   *           Unused, except if this object is passed to the `MediaSession`\n   *           API.\n   *\n   * @property {string} [artist]\n   *           Unused, except if this object is passed to the `MediaSession`\n   *           API.\n   *\n   * @property {Object[]} [artwork]\n   *           Unused, except if this object is passed to the `MediaSession`\n   *           API. If not specified, will be populated via the `poster`, if\n   *           available.\n   *\n   * @property {string} [poster]\n   *           URL to an image that will display before playback.\n   *\n   * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]\n   *           A single source object, an array of source objects, or a string\n   *           referencing a URL to a media source. It is _highly recommended_\n   *           that an object or array of objects is used here, so that source\n   *           selection algorithms can take the `type` into account.\n   *\n   * @property {string} [title]\n   *           Unused, except if this object is passed to the `MediaSession`\n   *           API.\n   *\n   * @property {Object[]} [textTracks]\n   *           An array of objects to be used to create text tracks, following\n   *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.\n   *           For ease of removal, these will be created as \"remote\" text\n   *           tracks and set to automatically clean up on source changes.\n   *\n   *           These objects may have properties like `src`, `kind`, `label`,\n   *           and `language`, see {@link Tech#createRemoteTextTrack}.\n   */\n\n  /**\n   * Populate the player using a {@link Player~MediaObject|MediaObject}.\n   *\n   * @param  {Player~MediaObject} media\n   *         A media object.\n   *\n   * @param  {Function} ready\n   *         A callback to be called when the player is ready.\n   */\n  ;\n\n  _proto.loadMedia = function loadMedia(media, ready) {\n    var _this17 = this;\n\n    if (!media || typeof media !== 'object') {\n      return;\n    }\n\n    this.reset(); // Clone the media object so it cannot be mutated from outside.\n\n    this.cache_.media = mergeOptions(media);\n    var _this$cache_$media = this.cache_.media,\n        artwork = _this$cache_$media.artwork,\n        poster = _this$cache_$media.poster,\n        src = _this$cache_$media.src,\n        textTracks = _this$cache_$media.textTracks; // If `artwork` is not given, create it using `poster`.\n\n    if (!artwork && poster) {\n      this.cache_.media.artwork = [{\n        src: poster,\n        type: getMimetype(poster)\n      }];\n    }\n\n    if (src) {\n      this.src(src);\n    }\n\n    if (poster) {\n      this.poster(poster);\n    }\n\n    if (Array.isArray(textTracks)) {\n      textTracks.forEach(function (tt) {\n        return _this17.addRemoteTextTrack(tt, false);\n      });\n    }\n\n    this.ready(ready);\n  }\n  /**\n   * Get a clone of the current {@link Player~MediaObject} for this player.\n   *\n   * If the `loadMedia` method has not been used, will attempt to return a\n   * {@link Player~MediaObject} based on the current state of the player.\n   *\n   * @return {Player~MediaObject}\n   */\n  ;\n\n  _proto.getMedia = function getMedia() {\n    if (!this.cache_.media) {\n      var poster = this.poster();\n      var src = this.currentSources();\n      var textTracks = Array.prototype.map.call(this.remoteTextTracks(), function (tt) {\n        return {\n          kind: tt.kind,\n          label: tt.label,\n          language: tt.language,\n          src: tt.src\n        };\n      });\n      var media = {\n        src: src,\n        textTracks: textTracks\n      };\n\n      if (poster) {\n        media.poster = poster;\n        media.artwork = [{\n          src: media.poster,\n          type: getMimetype(media.poster)\n        }];\n      }\n\n      return media;\n    }\n\n    return mergeOptions(this.cache_.media);\n  }\n  /**\n   * Gets tag settings\n   *\n   * @param {Element} tag\n   *        The player tag\n   *\n   * @return {Object}\n   *         An object containing all of the settings\n   *         for a player tag\n   */\n  ;\n\n  Player.getTagSettings = function getTagSettings(tag) {\n    var baseOptions = {\n      sources: [],\n      tracks: []\n    };\n    var tagOptions = getAttributes(tag);\n    var dataSetup = tagOptions['data-setup'];\n\n    if (hasClass(tag, 'vjs-fill')) {\n      tagOptions.fill = true;\n    }\n\n    if (hasClass(tag, 'vjs-fluid')) {\n      tagOptions.fluid = true;\n    } // Check if data-setup attr exists.\n\n\n    if (dataSetup !== null) {\n      // Parse options JSON\n      // If empty string, make it a parsable json object.\n      var _safeParseTuple = safeParseTuple(dataSetup || '{}'),\n          err = _safeParseTuple[0],\n          data = _safeParseTuple[1];\n\n      if (err) {\n        log.error(err);\n      }\n\n      assign(tagOptions, data);\n    }\n\n    assign(baseOptions, tagOptions); // Get tag children settings\n\n    if (tag.hasChildNodes()) {\n      var children = tag.childNodes;\n\n      for (var i = 0, j = children.length; i < j; i++) {\n        var child = children[i]; // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n\n        var childName = child.nodeName.toLowerCase();\n\n        if (childName === 'source') {\n          baseOptions.sources.push(getAttributes(child));\n        } else if (childName === 'track') {\n          baseOptions.tracks.push(getAttributes(child));\n        }\n      }\n    }\n\n    return baseOptions;\n  }\n  /**\n   * Determine whether or not flexbox is supported\n   *\n   * @return {boolean}\n   *         - true if flexbox is supported\n   *         - false if flexbox is not supported\n   */\n  ;\n\n  _proto.flexNotSupported_ = function flexNotSupported_() {\n    var elem = document.createElement('i'); // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\n    // common flex features that we can rely on when checking for flex support.\n\n    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style || // IE10-specific (2012 flex spec), available for completeness\n    'msFlexOrder' in elem.style);\n  }\n  /**\n   * Set debug mode to enable/disable logs at info level.\n   *\n   * @param {boolean} enabled\n   * @fires Player#debugon\n   * @fires Player#debugoff\n   */\n  ;\n\n  _proto.debug = function debug(enabled) {\n    if (enabled === undefined) {\n      return this.debugEnabled_;\n    }\n\n    if (enabled) {\n      this.trigger('debugon');\n      this.previousLogLevel_ = this.log.level;\n      this.log.level('debug');\n      this.debugEnabled_ = true;\n    } else {\n      this.trigger('debugoff');\n      this.log.level(this.previousLogLevel_);\n      this.previousLogLevel_ = undefined;\n      this.debugEnabled_ = false;\n    }\n  };\n\n  return Player;\n}(Component);\n/**\n * Get the {@link VideoTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n *\n * @return {VideoTrackList}\n *         the current video track list\n *\n * @method Player.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n *\n * @return {AudioTrackList}\n *         the current audio track list\n *\n * @method Player.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n *\n * @return {TextTrackList}\n *         the current text track list\n *\n * @method Player.prototype.textTracks\n */\n\n/**\n * Get the remote {@link TextTrackList}\n *\n * @return {TextTrackList}\n *         The current remote text track list\n *\n * @method Player.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote {@link HtmlTrackElementList} tracks.\n *\n * @return {HtmlTrackElementList}\n *         The current remote text track element list\n *\n * @method Player.prototype.remoteTextTrackEls\n */\n\n\nALL.names.forEach(function (name) {\n  var props = ALL[name];\n\n  Player.prototype[props.getterName] = function () {\n    if (this.tech_) {\n      return this.tech_[props.getterName]();\n    } // if we have not yet loadTech_, we create {video,audio,text}Tracks_\n    // these will be passed to the tech during loading\n\n\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n/**\n * Get or set the `Player`'s crossorigin option. For the HTML5 player, this\n * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n * behavior.\n *\n * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n *\n * @param {string} [value]\n *        The value to set the `Player`'s crossorigin to. If an argument is\n *        given, must be one of `anonymous` or `use-credentials`.\n *\n * @return {string|undefined}\n *         - The current crossorigin value of the `Player` when getting.\n *         - undefined when setting\n */\n\nPlayer.prototype.crossorigin = Player.prototype.crossOrigin;\n/**\n * Global enumeration of players.\n *\n * The keys are the player IDs and the values are either the {@link Player}\n * instance or `null` for disposed players.\n *\n * @type {Object}\n */\n\nPlayer.players = {};\nvar navigator = window$1.navigator;\n/*\n * Player instance options, surfaced using options\n * options = Player.prototype.options_\n * Make changes in options, not here.\n *\n * @type {Object}\n * @private\n */\n\nPlayer.prototype.options_ = {\n  // Default order of fallback technology\n  techOrder: Tech.defaultTechOrder_,\n  html5: {},\n  flash: {},\n  // default inactivity timeout\n  inactivityTimeout: 2000,\n  // default playback rates\n  playbackRates: [],\n  // Add playback rate selection by adding rates\n  // 'playbackRates': [0.5, 1, 1.5, 2],\n  liveui: false,\n  // Included control sets\n  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'liveTracker', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],\n  language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\n  // locales and their language translations\n  languages: {},\n  // Default message to show when a video cannot be played.\n  notSupportedMessage: 'No compatible source was found for this media.',\n  fullscreen: {\n    options: {\n      navigationUI: 'hide'\n    }\n  },\n  breakpoints: {},\n  responsive: false\n};\n[\n/**\n * Returns whether or not the player is in the \"ended\" state.\n *\n * @return {Boolean} True if the player is in the ended state, false if not.\n * @method Player#ended\n */\n'ended',\n/**\n * Returns whether or not the player is in the \"seeking\" state.\n *\n * @return {Boolean} True if the player is in the seeking state, false if not.\n * @method Player#seeking\n */\n'seeking',\n/**\n * Returns the TimeRanges of the media that are currently available\n * for seeking to.\n *\n * @return {TimeRanges} the seekable intervals of the media timeline\n * @method Player#seekable\n */\n'seekable',\n/**\n * Returns the current state of network activity for the element, from\n * the codes in the list below.\n * - NETWORK_EMPTY (numeric value 0)\n *   The element has not yet been initialised. All attributes are in\n *   their initial states.\n * - NETWORK_IDLE (numeric value 1)\n *   The element's resource selection algorithm is active and has\n *   selected a resource, but it is not actually using the network at\n *   this time.\n * - NETWORK_LOADING (numeric value 2)\n *   The user agent is actively trying to download data.\n * - NETWORK_NO_SOURCE (numeric value 3)\n *   The element's resource selection algorithm is active, but it has\n *   not yet found a resource to use.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n * @return {number} the current network activity state\n * @method Player#networkState\n */\n'networkState',\n/**\n * Returns a value that expresses the current state of the element\n * with respect to rendering the current playback position, from the\n * codes in the list below.\n * - HAVE_NOTHING (numeric value 0)\n *   No information regarding the media resource is available.\n * - HAVE_METADATA (numeric value 1)\n *   Enough of the resource has been obtained that the duration of the\n *   resource is available.\n * - HAVE_CURRENT_DATA (numeric value 2)\n *   Data for the immediate current playback position is available.\n * - HAVE_FUTURE_DATA (numeric value 3)\n *   Data for the immediate current playback position is available, as\n *   well as enough data for the user agent to advance the current\n *   playback position in the direction of playback.\n * - HAVE_ENOUGH_DATA (numeric value 4)\n *   The user agent estimates that enough data is available for\n *   playback to proceed uninterrupted.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n * @return {number} the current playback rendering state\n * @method Player#readyState\n */\n'readyState'].forEach(function (fn) {\n  Player.prototype[fn] = function () {\n    return this.techGet_(fn);\n  };\n});\nTECH_EVENTS_RETRIGGER.forEach(function (event) {\n  Player.prototype[\"handleTech\" + toTitleCase(event) + \"_\"] = function () {\n    return this.trigger(event);\n  };\n});\n/**\n * Fired when the player has initial duration and dimension information\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the player has downloaded data at the current playback position\n *\n * @event Player#loadeddata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the current playback position has changed *\n * During playback this is fired every 15-250 milliseconds, depending on the\n * playback technology in use.\n *\n * @event Player#timeupdate\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the volume changes\n *\n * @event Player#volumechange\n * @type {EventTarget~Event}\n */\n\n/**\n * Reports whether or not a player has a plugin available.\n *\n * This does not report whether or not the plugin has ever been initialized\n * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n *\n * @method Player#hasPlugin\n * @param  {string}  name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player has the requested plugin available.\n */\n\n/**\n * Reports whether or not a player is using a plugin by name.\n *\n * For basic plugins, this only reports whether the plugin has _ever_ been\n * initialized on this player.\n *\n * @method Player#usingPlugin\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player is using the requested plugin.\n */\n\nComponent.registerComponent('Player', Player);\n/**\n * The base plugin name.\n *\n * @private\n * @constant\n * @type {string}\n */\n\nvar BASE_PLUGIN_NAME = 'plugin';\n/**\n * The key on which a player's active plugins cache is stored.\n *\n * @private\n * @constant\n * @type     {string}\n */\n\nvar PLUGIN_CACHE_KEY = 'activePlugins_';\n/**\n * Stores registered plugins in a private space.\n *\n * @private\n * @type    {Object}\n */\n\nvar pluginStorage = {};\n/**\n * Reports whether or not a plugin has been registered.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @return {boolean}\n *          Whether or not the plugin has been registered.\n */\n\nvar pluginExists = function pluginExists(name) {\n  return pluginStorage.hasOwnProperty(name);\n};\n/**\n * Get a single registered plugin by name.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @return {Function|undefined}\n *          The plugin (or undefined).\n */\n\n\nvar getPlugin = function getPlugin(name) {\n  return pluginExists(name) ? pluginStorage[name] : undefined;\n};\n/**\n * Marks a plugin as \"active\" on a player.\n *\n * Also, ensures that the player has an object for tracking active plugins.\n *\n * @private\n * @param   {Player} player\n *          A Video.js player instance.\n *\n * @param   {string} name\n *          The name of a plugin.\n */\n\n\nvar markPluginAsActive = function markPluginAsActive(player, name) {\n  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n  player[PLUGIN_CACHE_KEY][name] = true;\n};\n/**\n * Triggers a pair of plugin setup events.\n *\n * @private\n * @param  {Player} player\n *         A Video.js player instance.\n *\n * @param  {Plugin~PluginEventHash} hash\n *         A plugin event hash.\n *\n * @param  {boolean} [before]\n *         If true, prefixes the event name with \"before\". In other words,\n *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n */\n\n\nvar triggerSetupEvent = function triggerSetupEvent(player, hash, before) {\n  var eventName = (before ? 'before' : '') + 'pluginsetup';\n  player.trigger(eventName, hash);\n  player.trigger(eventName + ':' + hash.name, hash);\n};\n/**\n * Takes a basic plugin function and returns a wrapper function which marks\n * on the player that the plugin has been activated.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Function} plugin\n *          The basic plugin.\n *\n * @return {Function}\n *          A wrapper function for the given plugin.\n */\n\n\nvar createBasicPlugin = function createBasicPlugin(name, plugin) {\n  var basicPluginWrapper = function basicPluginWrapper() {\n    // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n    // regardless, but we want the hash to be consistent with the hash provided\n    // for advanced plugins.\n    //\n    // The only potentially counter-intuitive thing here is the `instance` in\n    // the \"pluginsetup\" event is the value returned by the `plugin` function.\n    triggerSetupEvent(this, {\n      name: name,\n      plugin: plugin,\n      instance: null\n    }, true);\n    var instance = plugin.apply(this, arguments);\n    markPluginAsActive(this, name);\n    triggerSetupEvent(this, {\n      name: name,\n      plugin: plugin,\n      instance: instance\n    });\n    return instance;\n  };\n\n  Object.keys(plugin).forEach(function (prop) {\n    basicPluginWrapper[prop] = plugin[prop];\n  });\n  return basicPluginWrapper;\n};\n/**\n * Takes a plugin sub-class and returns a factory function for generating\n * instances of it.\n *\n * This factory function will replace itself with an instance of the requested\n * sub-class of Plugin.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Plugin} PluginSubClass\n *          The advanced plugin.\n *\n * @return {Function}\n */\n\n\nvar createPluginFactory = function createPluginFactory(name, PluginSubClass) {\n  // Add a `name` property to the plugin prototype so that each plugin can\n  // refer to itself by name.\n  PluginSubClass.prototype.name = name;\n  return function () {\n    triggerSetupEvent(this, {\n      name: name,\n      plugin: PluginSubClass,\n      instance: null\n    }, true);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var instance = _construct(PluginSubClass, [this].concat(args)); // The plugin is replaced by a function that returns the current instance.\n\n\n    this[name] = function () {\n      return instance;\n    };\n\n    triggerSetupEvent(this, instance.getEventHash());\n    return instance;\n  };\n};\n/**\n * Parent class for all advanced plugins.\n *\n * @mixes   module:evented~EventedMixin\n * @mixes   module:stateful~StatefulMixin\n * @fires   Player#beforepluginsetup\n * @fires   Player#beforepluginsetup:$name\n * @fires   Player#pluginsetup\n * @fires   Player#pluginsetup:$name\n * @listens Player#dispose\n * @throws  {Error}\n *          If attempting to instantiate the base {@link Plugin} class\n *          directly instead of via a sub-class.\n */\n\n\nvar Plugin = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of this class.\n   *\n   * Sub-classes should call `super` to ensure plugins are properly initialized.\n   *\n   * @param {Player} player\n   *        A Video.js player instance.\n   */\n  function Plugin(player) {\n    if (this.constructor === Plugin) {\n      throw new Error('Plugin must be sub-classed; not directly instantiated.');\n    }\n\n    this.player = player;\n\n    if (!this.log) {\n      this.log = this.player.log.createLogger(this.name);\n    } // Make this object evented, but remove the added `trigger` method so we\n    // use the prototype version instead.\n\n\n    evented(this);\n    delete this.trigger;\n    stateful(this, this.constructor.defaultState);\n    markPluginAsActive(player, this.name); // Auto-bind the dispose method so we can use it as a listener and unbind\n    // it later easily.\n\n    this.dispose = bind(this, this.dispose); // If the player is disposed, dispose the plugin.\n\n    player.on('dispose', this.dispose);\n  }\n  /**\n   * Get the version of the plugin that was set on <pluginName>.VERSION\n   */\n\n\n  var _proto = Plugin.prototype;\n\n  _proto.version = function version() {\n    return this.constructor.VERSION;\n  }\n  /**\n   * Each event triggered by plugins includes a hash of additional data with\n   * conventional properties.\n   *\n   * This returns that object or mutates an existing hash.\n   *\n   * @param   {Object} [hash={}]\n   *          An object to be used as event an event hash.\n   *\n   * @return {Plugin~PluginEventHash}\n   *          An event hash object with provided properties mixed-in.\n   */\n  ;\n\n  _proto.getEventHash = function getEventHash(hash) {\n    if (hash === void 0) {\n      hash = {};\n    }\n\n    hash.name = this.name;\n    hash.plugin = this.constructor;\n    hash.instance = this;\n    return hash;\n  }\n  /**\n   * Triggers an event on the plugin object and overrides\n   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash={}]\n   *          Additional data hash to merge with a\n   *          {@link Plugin~PluginEventHash|PluginEventHash}.\n   *\n   * @return {boolean}\n   *          Whether or not default was prevented.\n   */\n  ;\n\n  _proto.trigger = function trigger$1(event, hash) {\n    if (hash === void 0) {\n      hash = {};\n    }\n\n    return trigger(this.eventBusEl_, event, this.getEventHash(hash));\n  }\n  /**\n   * Handles \"statechanged\" events on the plugin. No-op by default, override by\n   * subclassing.\n   *\n   * @abstract\n   * @param    {Event} e\n   *           An event object provided by a \"statechanged\" event.\n   *\n   * @param    {Object} e.changes\n   *           An object describing changes that occurred with the \"statechanged\"\n   *           event.\n   */\n  ;\n\n  _proto.handleStateChanged = function handleStateChanged(e) {}\n  /**\n   * Disposes a plugin.\n   *\n   * Subclasses can override this if they want, but for the sake of safety,\n   * it's probably best to subscribe the \"dispose\" event.\n   *\n   * @fires Plugin#dispose\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    var name = this.name,\n        player = this.player;\n    /**\n     * Signals that a advanced plugin is about to be disposed.\n     *\n     * @event Plugin#dispose\n     * @type  {EventTarget~Event}\n     */\n\n    this.trigger('dispose');\n    this.off();\n    player.off('dispose', this.dispose); // Eliminate any possible sources of leaking memory by clearing up\n    // references between the player and the plugin instance and nulling out\n    // the plugin's state and replacing methods with a function that throws.\n\n    player[PLUGIN_CACHE_KEY][name] = false;\n    this.player = this.state = null; // Finally, replace the plugin name on the player with a new factory\n    // function, so that the plugin is ready to be set up again.\n\n    player[name] = createPluginFactory(name, pluginStorage[name]);\n  }\n  /**\n   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n   *\n   * @param   {string|Function} plugin\n   *          If a string, matches the name of a plugin. If a function, will be\n   *          tested directly.\n   *\n   * @return {boolean}\n   *          Whether or not a plugin is a basic plugin.\n   */\n  ;\n\n  Plugin.isBasic = function isBasic(plugin) {\n    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n  }\n  /**\n   * Register a Video.js plugin.\n   *\n   * @param   {string} name\n   *          The name of the plugin to be registered. Must be a string and\n   *          must not match an existing plugin or a method on the `Player`\n   *          prototype.\n   *\n   * @param   {Function} plugin\n   *          A sub-class of `Plugin` or a function for basic plugins.\n   *\n   * @return {Function}\n   *          For advanced plugins, a factory function for that plugin. For\n   *          basic plugins, a wrapper function that initializes the plugin.\n   */\n  ;\n\n  Plugin.registerPlugin = function registerPlugin(name, plugin) {\n    if (typeof name !== 'string') {\n      throw new Error(\"Illegal plugin name, \\\"\" + name + \"\\\", must be a string, was \" + typeof name + \".\");\n    }\n\n    if (pluginExists(name)) {\n      log.warn(\"A plugin named \\\"\" + name + \"\\\" already exists. You may want to avoid re-registering plugins!\");\n    } else if (Player.prototype.hasOwnProperty(name)) {\n      throw new Error(\"Illegal plugin name, \\\"\" + name + \"\\\", cannot share a name with an existing player method!\");\n    }\n\n    if (typeof plugin !== 'function') {\n      throw new Error(\"Illegal plugin for \\\"\" + name + \"\\\", must be a function, was \" + typeof plugin + \".\");\n    }\n\n    pluginStorage[name] = plugin; // Add a player prototype method for all sub-classed plugins (but not for\n    // the base Plugin class).\n\n    if (name !== BASE_PLUGIN_NAME) {\n      if (Plugin.isBasic(plugin)) {\n        Player.prototype[name] = createBasicPlugin(name, plugin);\n      } else {\n        Player.prototype[name] = createPluginFactory(name, plugin);\n      }\n    }\n\n    return plugin;\n  }\n  /**\n   * De-register a Video.js plugin.\n   *\n   * @param  {string} name\n   *         The name of the plugin to be de-registered. Must be a string that\n   *         matches an existing plugin.\n   *\n   * @throws {Error}\n   *         If an attempt is made to de-register the base plugin.\n   */\n  ;\n\n  Plugin.deregisterPlugin = function deregisterPlugin(name) {\n    if (name === BASE_PLUGIN_NAME) {\n      throw new Error('Cannot de-register base plugin.');\n    }\n\n    if (pluginExists(name)) {\n      delete pluginStorage[name];\n      delete Player.prototype[name];\n    }\n  }\n  /**\n   * Gets an object containing multiple Video.js plugins.\n   *\n   * @param   {Array} [names]\n   *          If provided, should be an array of plugin names. Defaults to _all_\n   *          plugin names.\n   *\n   * @return {Object|undefined}\n   *          An object containing plugin(s) associated with their name(s) or\n   *          `undefined` if no matching plugins exist).\n   */\n  ;\n\n  Plugin.getPlugins = function getPlugins(names) {\n    if (names === void 0) {\n      names = Object.keys(pluginStorage);\n    }\n\n    var result;\n    names.forEach(function (name) {\n      var plugin = getPlugin(name);\n\n      if (plugin) {\n        result = result || {};\n        result[name] = plugin;\n      }\n    });\n    return result;\n  }\n  /**\n   * Gets a plugin's version, if available\n   *\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @return {string}\n   *          The plugin's version or an empty string.\n   */\n  ;\n\n  Plugin.getPluginVersion = function getPluginVersion(name) {\n    var plugin = getPlugin(name);\n    return plugin && plugin.VERSION || '';\n  };\n\n  return Plugin;\n}();\n/**\n * Gets a plugin by name if it exists.\n *\n * @static\n * @method   getPlugin\n * @memberOf Plugin\n * @param    {string} name\n *           The name of a plugin.\n *\n * @returns  {Function|undefined}\n *           The plugin (or `undefined`).\n */\n\n\nPlugin.getPlugin = getPlugin;\n/**\n * The name of the base plugin class as it is registered.\n *\n * @type {string}\n */\n\nPlugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\nPlugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n/**\n * Documented in player.js\n *\n * @ignore\n */\n\nPlayer.prototype.usingPlugin = function (name) {\n  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n};\n/**\n * Documented in player.js\n *\n * @ignore\n */\n\n\nPlayer.prototype.hasPlugin = function (name) {\n  return !!pluginExists(name);\n};\n/**\n * Signals that a plugin is about to be set up on a player.\n *\n * @event    Player#beforepluginsetup\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin is about to be set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#beforepluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin has just been set up on a player.\n *\n * @event    Player#pluginsetup\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin has just been set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#pluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * @typedef  {Object} Plugin~PluginEventHash\n *\n * @property {string} instance\n *           For basic plugins, the return value of the plugin function. For\n *           advanced plugins, the plugin instance on which the event is fired.\n *\n * @property {string} name\n *           The name of the plugin.\n *\n * @property {string} plugin\n *           For basic plugins, the plugin function. For advanced plugins, the\n *           plugin class/constructor.\n */\n\n/**\n * @file extend.js\n * @module extend\n */\n\n/**\n * Used to subclass an existing class by emulating ES subclassing using the\n * `extends` keyword.\n *\n * @function\n * @example\n * var MyComponent = videojs.extend(videojs.getComponent('Component'), {\n *   myCustomMethod: function() {\n *     // Do things in my method.\n *   }\n * });\n *\n * @param    {Function} superClass\n *           The class to inherit from\n *\n * @param    {Object}   [subClassMethods={}]\n *           Methods of the new class\n *\n * @return   {Function}\n *           The new class with subClassMethods that inherited superClass.\n */\n\n\nvar extend = function extend(superClass, subClassMethods) {\n  if (subClassMethods === void 0) {\n    subClassMethods = {};\n  }\n\n  var subClass = function subClass() {\n    superClass.apply(this, arguments);\n  };\n\n  var methods = {};\n\n  if (typeof subClassMethods === 'object') {\n    if (subClassMethods.constructor !== Object.prototype.constructor) {\n      subClass = subClassMethods.constructor;\n    }\n\n    methods = subClassMethods;\n  } else if (typeof subClassMethods === 'function') {\n    subClass = subClassMethods;\n  }\n\n  _inherits(subClass, superClass); // this is needed for backward-compatibility and node compatibility.\n\n\n  if (superClass) {\n    subClass.super_ = superClass;\n  } // Extend subObj's prototype with functions and other properties from props\n\n\n  for (var name in methods) {\n    if (methods.hasOwnProperty(name)) {\n      subClass.prototype[name] = methods[name];\n    }\n  }\n\n  return subClass;\n};\n/**\n * @file video.js\n * @module videojs\n */\n\n/**\n * Normalize an `id` value by trimming off a leading `#`\n *\n * @private\n * @param   {string} id\n *          A string, maybe with a leading `#`.\n *\n * @return {string}\n *          The string, without any leading `#`.\n */\n\n\nvar normalizeId = function normalizeId(id) {\n  return id.indexOf('#') === 0 ? id.slice(1) : id;\n};\n/**\n * The `videojs()` function doubles as the main function for users to create a\n * {@link Player} instance as well as the main library namespace.\n *\n * It can also be used as a getter for a pre-existing {@link Player} instance.\n * However, we _strongly_ recommend using `videojs.getPlayer()` for this\n * purpose because it avoids any potential for unintended initialization.\n *\n * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n * of our JSDoc template, we cannot properly document this as both a function\n * and a namespace, so its function signature is documented here.\n *\n * #### Arguments\n * ##### id\n * string|Element, **required**\n *\n * Video element or video element ID.\n *\n * ##### options\n * Object, optional\n *\n * Options object for providing settings.\n * See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n *\n * ##### ready\n * {@link Component~ReadyCallback}, optional\n *\n * A function to be called when the {@link Player} and {@link Tech} are ready.\n *\n * #### Return Value\n *\n * The `videojs()` function returns a {@link Player} instance.\n *\n * @namespace\n *\n * @borrows AudioTrack as AudioTrack\n * @borrows Component.getComponent as getComponent\n * @borrows module:computed-style~computedStyle as computedStyle\n * @borrows module:events.on as on\n * @borrows module:events.one as one\n * @borrows module:events.off as off\n * @borrows module:events.trigger as trigger\n * @borrows EventTarget as EventTarget\n * @borrows module:extend~extend as extend\n * @borrows module:fn.bind as bind\n * @borrows module:format-time.formatTime as formatTime\n * @borrows module:format-time.resetFormatTime as resetFormatTime\n * @borrows module:format-time.setFormatTime as setFormatTime\n * @borrows module:merge-options.mergeOptions as mergeOptions\n * @borrows module:middleware.use as use\n * @borrows Player.players as players\n * @borrows Plugin.registerPlugin as registerPlugin\n * @borrows Plugin.deregisterPlugin as deregisterPlugin\n * @borrows Plugin.getPlugins as getPlugins\n * @borrows Plugin.getPlugin as getPlugin\n * @borrows Plugin.getPluginVersion as getPluginVersion\n * @borrows Tech.getTech as getTech\n * @borrows Tech.registerTech as registerTech\n * @borrows TextTrack as TextTrack\n * @borrows module:time-ranges.createTimeRanges as createTimeRange\n * @borrows module:time-ranges.createTimeRanges as createTimeRanges\n * @borrows module:url.isCrossOrigin as isCrossOrigin\n * @borrows module:url.parseUrl as parseUrl\n * @borrows VideoTrack as VideoTrack\n *\n * @param  {string|Element} id\n *         Video element or video element ID.\n *\n * @param  {Object} [options]\n *         Options object for providing settings.\n *         See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n *\n * @param  {Component~ReadyCallback} [ready]\n *         A function to be called when the {@link Player} and {@link Tech} are\n *         ready.\n *\n * @return {Player}\n *         The `videojs()` function returns a {@link Player|Player} instance.\n */\n\n\nfunction videojs$1(id, options, ready) {\n  var player = videojs$1.getPlayer(id);\n\n  if (player) {\n    if (options) {\n      log.warn(\"Player \\\"\" + id + \"\\\" is already initialised. Options will not be applied.\");\n    }\n\n    if (ready) {\n      player.ready(ready);\n    }\n\n    return player;\n  }\n\n  var el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;\n\n  if (!isEl(el)) {\n    throw new TypeError('The element or ID supplied is not valid. (videojs)');\n  } // document.body.contains(el) will only check if el is contained within that one document.\n  // This causes problems for elements in iframes.\n  // Instead, use the element's ownerDocument instead of the global document.\n  // This will make sure that the element is indeed in the dom of that document.\n  // Additionally, check that the document in question has a default view.\n  // If the document is no longer attached to the dom, the defaultView of the document will be null.\n\n\n  if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {\n    log.warn('The element supplied is not included in the DOM');\n  }\n\n  options = options || {};\n  videojs$1.hooks('beforesetup').forEach(function (hookFunction) {\n    var opts = hookFunction(el, mergeOptions(options));\n\n    if (!isObject(opts) || Array.isArray(opts)) {\n      log.error('please return an object in beforesetup hooks');\n      return;\n    }\n\n    options = mergeOptions(options, opts);\n  }); // We get the current \"Player\" component here in case an integration has\n  // replaced it with a custom player.\n\n  var PlayerComponent = Component.getComponent('Player');\n  player = new PlayerComponent(el, options, ready);\n  videojs$1.hooks('setup').forEach(function (hookFunction) {\n    return hookFunction(player);\n  });\n  return player;\n}\n/**\n * An Object that contains lifecycle hooks as keys which point to an array\n * of functions that are run when a lifecycle is triggered\n *\n * @private\n */\n\n\nvideojs$1.hooks_ = {};\n/**\n * Get a list of hooks for a specific lifecycle\n *\n * @param  {string} type\n *         the lifecyle to get hooks from\n *\n * @param  {Function|Function[]} [fn]\n *         Optionally add a hook (or hooks) to the lifecycle that your are getting.\n *\n * @return {Array}\n *         an array of hooks, or an empty array if there are none.\n */\n\nvideojs$1.hooks = function (type, fn) {\n  videojs$1.hooks_[type] = videojs$1.hooks_[type] || [];\n\n  if (fn) {\n    videojs$1.hooks_[type] = videojs$1.hooks_[type].concat(fn);\n  }\n\n  return videojs$1.hooks_[type];\n};\n/**\n * Add a function hook to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\n\n\nvideojs$1.hook = function (type, fn) {\n  videojs$1.hooks(type, fn);\n};\n/**\n * Add a function hook that will only run once to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\n\n\nvideojs$1.hookOnce = function (type, fn) {\n  videojs$1.hooks(type, [].concat(fn).map(function (original) {\n    var wrapper = function wrapper() {\n      videojs$1.removeHook(type, wrapper);\n      return original.apply(void 0, arguments);\n    };\n\n    return wrapper;\n  }));\n};\n/**\n * Remove a hook from a specific videojs lifecycle.\n *\n * @param  {string} type\n *         the lifecycle that the function hooked to\n *\n * @param  {Function} fn\n *         The hooked function to remove\n *\n * @return {boolean}\n *         The function that was removed or undef\n */\n\n\nvideojs$1.removeHook = function (type, fn) {\n  var index = videojs$1.hooks(type).indexOf(fn);\n\n  if (index <= -1) {\n    return false;\n  }\n\n  videojs$1.hooks_[type] = videojs$1.hooks_[type].slice();\n  videojs$1.hooks_[type].splice(index, 1);\n  return true;\n}; // Add default styles\n\n\nif (window$1.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\n  var style = $('.vjs-styles-defaults');\n\n  if (!style) {\n    style = createStyleElement('vjs-styles-defaults');\n    var head = $('head');\n\n    if (head) {\n      head.insertBefore(style, head.firstChild);\n    }\n\n    setTextContent(style, \"\\n      .video-js {\\n        width: 300px;\\n        height: 150px;\\n      }\\n\\n      .vjs-fluid {\\n        padding-top: 56.25%\\n      }\\n    \");\n  }\n} // Run Auto-load players\n// You have to wait at least once in case this script is loaded after your\n// video in the DOM (weird behavior only with minified version)\n\n\nautoSetupTimeout(1, videojs$1);\n/**\n * Current Video.js version. Follows [semantic versioning](https://semver.org/).\n *\n * @type {string}\n */\n\nvideojs$1.VERSION = version;\n/**\n * The global options object. These are the settings that take effect\n * if no overrides are specified when the player is created.\n *\n * @type {Object}\n */\n\nvideojs$1.options = Player.prototype.options_;\n/**\n * Get an object with the currently created players, keyed by player ID\n *\n * @return {Object}\n *         The created players\n */\n\nvideojs$1.getPlayers = function () {\n  return Player.players;\n};\n/**\n * Get a single player based on an ID or DOM element.\n *\n * This is useful if you want to check if an element or ID has an associated\n * Video.js player, but not create one if it doesn't.\n *\n * @param   {string|Element} id\n *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -\n *          or a string matching the `id` of such an element.\n *\n * @return {Player|undefined}\n *          A player instance or `undefined` if there is no player instance\n *          matching the argument.\n */\n\n\nvideojs$1.getPlayer = function (id) {\n  var players = Player.players;\n  var tag;\n\n  if (typeof id === 'string') {\n    var nId = normalizeId(id);\n    var player = players[nId];\n\n    if (player) {\n      return player;\n    }\n\n    tag = $('#' + nId);\n  } else {\n    tag = id;\n  }\n\n  if (isEl(tag)) {\n    var _tag = tag,\n        _player = _tag.player,\n        playerId = _tag.playerId; // Element may have a `player` property referring to an already created\n    // player instance. If so, return that.\n\n    if (_player || players[playerId]) {\n      return _player || players[playerId];\n    }\n  }\n};\n/**\n * Returns an array of all current players.\n *\n * @return {Array}\n *         An array of all players. The array will be in the order that\n *         `Object.keys` provides, which could potentially vary between\n *         JavaScript engines.\n *\n */\n\n\nvideojs$1.getAllPlayers = function () {\n  return (// Disposed players leave a key with a `null` value, so we need to make sure\n    // we filter those out.\n    Object.keys(Player.players).map(function (k) {\n      return Player.players[k];\n    }).filter(Boolean)\n  );\n};\n\nvideojs$1.players = Player.players;\nvideojs$1.getComponent = Component.getComponent;\n/**\n * Register a component so it can referred to by name. Used when adding to other\n * components, either through addChild `component.addChild('myComponent')` or through\n * default children options  `{ children: ['myComponent'] }`.\n *\n * > NOTE: You could also just initialize the component before adding.\n * `component.addChild(new MyComponent());`\n *\n * @param {string} name\n *        The class name of the component\n *\n * @param {Component} comp\n *        The component class\n *\n * @return {Component}\n *         The newly registered component\n */\n\nvideojs$1.registerComponent = function (name, comp) {\n  if (Tech.isTech(comp)) {\n    log.warn(\"The \" + name + \" tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)\");\n  }\n\n  Component.registerComponent.call(Component, name, comp);\n};\n\nvideojs$1.getTech = Tech.getTech;\nvideojs$1.registerTech = Tech.registerTech;\nvideojs$1.use = use;\n/**\n * An object that can be returned by a middleware to signify\n * that the middleware is being terminated.\n *\n * @type {object}\n * @property {object} middleware.TERMINATOR\n */\n\nObject.defineProperty(videojs$1, 'middleware', {\n  value: {},\n  writeable: false,\n  enumerable: true\n});\nObject.defineProperty(videojs$1.middleware, 'TERMINATOR', {\n  value: TERMINATOR,\n  writeable: false,\n  enumerable: true\n});\n/**\n * A reference to the {@link module:browser|browser utility module} as an object.\n *\n * @type {Object}\n * @see  {@link module:browser|browser}\n */\n\nvideojs$1.browser = browser;\n/**\n * Use {@link module:browser.TOUCH_ENABLED|browser.TOUCH_ENABLED} instead; only\n * included for backward-compatibility with 4.x.\n *\n * @deprecated Since version 5.0, use {@link module:browser.TOUCH_ENABLED|browser.TOUCH_ENABLED instead.\n * @type {boolean}\n */\n\nvideojs$1.TOUCH_ENABLED = TOUCH_ENABLED;\nvideojs$1.extend = extend;\nvideojs$1.mergeOptions = mergeOptions;\nvideojs$1.bind = bind;\nvideojs$1.registerPlugin = Plugin.registerPlugin;\nvideojs$1.deregisterPlugin = Plugin.deregisterPlugin;\n/**\n * Deprecated method to register a plugin with Video.js\n *\n * @deprecated videojs.plugin() is deprecated; use videojs.registerPlugin() instead\n *\n * @param {string} name\n *        The plugin name\n *\n * @param {Plugin|Function} plugin\n *         The plugin sub-class or function\n */\n\nvideojs$1.plugin = function (name, plugin) {\n  log.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\n  return Plugin.registerPlugin(name, plugin);\n};\n\nvideojs$1.getPlugins = Plugin.getPlugins;\nvideojs$1.getPlugin = Plugin.getPlugin;\nvideojs$1.getPluginVersion = Plugin.getPluginVersion;\n/**\n * Adding languages so that they're available to all players.\n * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n *\n * @param {string} code\n *        The language code or dictionary property\n *\n * @param {Object} data\n *        The data values to be translated\n *\n * @return {Object}\n *         The resulting language dictionary object\n */\n\nvideojs$1.addLanguage = function (code, data) {\n  var _mergeOptions;\n\n  code = ('' + code).toLowerCase();\n  videojs$1.options.languages = mergeOptions(videojs$1.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));\n  return videojs$1.options.languages[code];\n};\n/**\n * A reference to the {@link module:log|log utility module} as an object.\n *\n * @type {Function}\n * @see  {@link module:log|log}\n */\n\n\nvideojs$1.log = log;\nvideojs$1.createLogger = createLogger$1;\nvideojs$1.createTimeRange = videojs$1.createTimeRanges = createTimeRanges;\nvideojs$1.formatTime = formatTime;\nvideojs$1.setFormatTime = setFormatTime;\nvideojs$1.resetFormatTime = resetFormatTime;\nvideojs$1.parseUrl = parseUrl;\nvideojs$1.isCrossOrigin = isCrossOrigin;\nvideojs$1.EventTarget = EventTarget;\nvideojs$1.on = on;\nvideojs$1.one = one;\nvideojs$1.off = off;\nvideojs$1.trigger = trigger;\n/**\n * A cross-browser XMLHttpRequest wrapper.\n *\n * @function\n * @param    {Object} options\n *           Settings for the request.\n *\n * @return   {XMLHttpRequest|XDomainRequest}\n *           The request object.\n *\n * @see      https://github.com/Raynos/xhr\n */\n\nvideojs$1.xhr = XHR;\nvideojs$1.TextTrack = TextTrack;\nvideojs$1.AudioTrack = AudioTrack;\nvideojs$1.VideoTrack = VideoTrack;\n['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {\n  videojs$1[k] = function () {\n    log.warn(\"videojs.\" + k + \"() is deprecated; use videojs.dom.\" + k + \"() instead\");\n    return Dom[k].apply(null, arguments);\n  };\n});\nvideojs$1.computedStyle = computedStyle;\n/**\n * A reference to the {@link module:dom|DOM utility module} as an object.\n *\n * @type {Object}\n * @see  {@link module:dom|dom}\n */\n\nvideojs$1.dom = Dom;\n/**\n * A reference to the {@link module:url|URL utility module} as an object.\n *\n * @type {Object}\n * @see  {@link module:url|url}\n */\n\nvideojs$1.url = Url;\nvideojs$1.defineLazyProperty = defineLazyProperty;\n/*! @name @videojs/http-streaming @version 2.2.4 @license Apache-2.0 */\n\n/**\n * @file resolve-url.js - Handling how URLs are resolved and manipulated\n */\n\nvar resolveUrl = _resolveUrl;\n/**\n * Checks whether xhr request was redirected and returns correct url depending\n * on `handleManifestRedirects` option\n *\n * @api private\n *\n * @param  {string} url - an url being requested\n * @param  {XMLHttpRequest} req - xhr request result\n *\n * @return {string}\n */\n\nvar resolveManifestRedirect = function resolveManifestRedirect(handleManifestRedirect, url, req) {\n  // To understand how the responseURL below is set and generated:\n  // - https://fetch.spec.whatwg.org/#concept-response-url\n  // - https://fetch.spec.whatwg.org/#atomic-http-redirect-handling\n  if (handleManifestRedirect && req && req.responseURL && url !== req.responseURL) {\n    return req.responseURL;\n  }\n\n  return url;\n};\n\nvar log$1 = videojs$1.log;\n\nvar createPlaylistID = function createPlaylistID(index, uri) {\n  return index + \"-\" + uri;\n};\n/**\n * Parses a given m3u8 playlist\n *\n * @param {string} manifestString\n *        The downloaded manifest string\n * @param {Object[]} [customTagParsers]\n *        An array of custom tag parsers for the m3u8-parser instance\n * @param {Object[]} [customTagMappers]\n *         An array of custom tag mappers for the m3u8-parser instance\n * @return {Object}\n *         The manifest object\n */\n\n\nvar parseManifest = function parseManifest(_ref) {\n  var manifestString = _ref.manifestString,\n      _ref$customTagParsers = _ref.customTagParsers,\n      customTagParsers = _ref$customTagParsers === void 0 ? [] : _ref$customTagParsers,\n      _ref$customTagMappers = _ref.customTagMappers,\n      customTagMappers = _ref$customTagMappers === void 0 ? [] : _ref$customTagMappers;\n  var parser = new Parser();\n  customTagParsers.forEach(function (customParser) {\n    return parser.addParser(customParser);\n  });\n  customTagMappers.forEach(function (mapper) {\n    return parser.addTagMapper(mapper);\n  });\n  parser.push(manifestString);\n  parser.end();\n  return parser.manifest;\n};\n/**\n * Loops through all supported media groups in master and calls the provided\n * callback for each group\n *\n * @param {Object} master\n *        The parsed master manifest object\n * @param {Function} callback\n *        Callback to call for each media group\n */\n\n\nvar forEachMediaGroup = function forEachMediaGroup(master, callback) {\n  ['AUDIO', 'SUBTITLES'].forEach(function (mediaType) {\n    for (var groupKey in master.mediaGroups[mediaType]) {\n      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n        callback(mediaProperties, mediaType, groupKey, labelKey);\n      }\n    }\n  });\n};\n/**\n * Adds properties and attributes to the playlist to keep consistent functionality for\n * playlists throughout VHS.\n *\n * @param {Object} config\n *        Arguments object\n * @param {Object} config.playlist\n *        The media playlist\n * @param {string} [config.uri]\n *        The uri to the media playlist (if media playlist is not from within a master\n *        playlist)\n * @param {string} id\n *        ID to use for the playlist\n */\n\n\nvar setupMediaPlaylist = function setupMediaPlaylist(_ref2) {\n  var playlist = _ref2.playlist,\n      uri = _ref2.uri,\n      id = _ref2.id;\n  playlist.id = id;\n\n  if (uri) {\n    // For media playlists, m3u8-parser does not have access to a URI, as HLS media\n    // playlists do not contain their own source URI, but one is needed for consistency in\n    // VHS.\n    playlist.uri = uri;\n  } // For HLS master playlists, even though certain attributes MUST be defined, the\n  // stream may still be played without them.\n  // For HLS media playlists, m3u8-parser does not attach an attributes object to the\n  // manifest.\n  //\n  // To avoid undefined reference errors through the project, and make the code easier\n  // to write/read, add an empty attributes object for these cases.\n\n\n  playlist.attributes = playlist.attributes || {};\n};\n/**\n * Adds ID, resolvedUri, and attributes properties to each playlist of the master, where\n * necessary. In addition, creates playlist IDs for each playlist and adds playlist ID to\n * playlist references to the playlists array.\n *\n * @param {Object} master\n *        The master playlist\n */\n\n\nvar setupMediaPlaylists = function setupMediaPlaylists(master) {\n  var i = master.playlists.length;\n\n  while (i--) {\n    var playlist = master.playlists[i];\n    setupMediaPlaylist({\n      playlist: playlist,\n      id: createPlaylistID(i, playlist.uri)\n    });\n    playlist.resolvedUri = resolveUrl(master.uri, playlist.uri);\n    master.playlists[playlist.id] = playlist; // URI reference added for backwards compatibility\n\n    master.playlists[playlist.uri] = playlist; // Although the spec states an #EXT-X-STREAM-INF tag MUST have a BANDWIDTH attribute,\n    // the stream can be played without it. Although an attributes property may have been\n    // added to the playlist to prevent undefined references, issue a warning to fix the\n    // manifest.\n\n    if (!playlist.attributes.BANDWIDTH) {\n      log$1.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n    }\n  }\n};\n/**\n * Adds resolvedUri properties to each media group.\n *\n * @param {Object} master\n *        The master playlist\n */\n\n\nvar resolveMediaGroupUris = function resolveMediaGroupUris(master) {\n  forEachMediaGroup(master, function (properties) {\n    if (properties.uri) {\n      properties.resolvedUri = resolveUrl(master.uri, properties.uri);\n    }\n  });\n};\n/**\n * Creates a master playlist wrapper to insert a sole media playlist into.\n *\n * @param {Object} media\n *        Media playlist\n * @param {string} uri\n *        The media URI\n *\n * @return {Object}\n *         Master playlist\n */\n\n\nvar masterForMedia = function masterForMedia(media, uri) {\n  var id = createPlaylistID(0, uri);\n  var master = {\n    mediaGroups: {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    },\n    uri: window$1.location.href,\n    resolvedUri: window$1.location.href,\n    playlists: [{\n      uri: uri,\n      id: id,\n      resolvedUri: uri,\n      // m3u8-parser does not attach an attributes property to media playlists so make\n      // sure that the property is attached to avoid undefined reference errors\n      attributes: {}\n    }]\n  }; // set up ID reference\n\n  master.playlists[id] = master.playlists[0]; // URI reference added for backwards compatibility\n\n  master.playlists[uri] = master.playlists[0];\n  return master;\n};\n/**\n * Does an in-place update of the master manifest to add updated playlist URI references\n * as well as other properties needed by VHS that aren't included by the parser.\n *\n * @param {Object} master\n *        Master manifest object\n * @param {string} uri\n *        The source URI\n */\n\n\nvar addPropertiesToMaster = function addPropertiesToMaster(master, uri) {\n  master.uri = uri;\n\n  for (var i = 0; i < master.playlists.length; i++) {\n    if (!master.playlists[i].uri) {\n      // Set up phony URIs for the playlists since playlists are referenced by their URIs\n      // throughout VHS, but some formats (e.g., DASH) don't have external URIs\n      // TODO: consider adding dummy URIs in mpd-parser\n      var phonyUri = \"placeholder-uri-\" + i;\n      master.playlists[i].uri = phonyUri;\n    }\n  }\n\n  forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {\n    if (!properties.playlists || !properties.playlists.length || properties.playlists[0].uri) {\n      return;\n    } // Set up phony URIs for the media group playlists since playlists are referenced by\n    // their URIs throughout VHS, but some formats (e.g., DASH) don't have external URIs\n\n\n    var phonyUri = \"placeholder-uri-\" + mediaType + \"-\" + groupKey + \"-\" + labelKey;\n    var id = createPlaylistID(0, phonyUri);\n    properties.playlists[0].uri = phonyUri;\n    properties.playlists[0].id = id; // setup ID and URI references (URI for backwards compatibility)\n\n    master.playlists[id] = properties.playlists[0];\n    master.playlists[phonyUri] = properties.playlists[0];\n  });\n  setupMediaPlaylists(master);\n  resolveMediaGroupUris(master);\n};\n\nvar mergeOptions$1 = videojs$1.mergeOptions,\n    EventTarget$1 = videojs$1.EventTarget;\n/**\n  * Returns a new array of segments that is the result of merging\n  * properties from an older list of segments onto an updated\n  * list. No properties on the updated playlist will be overridden.\n  *\n  * @param {Array} original the outdated list of segments\n  * @param {Array} update the updated list of segments\n  * @param {number=} offset the index of the first update\n  * segment in the original segment list. For non-live playlists,\n  * this should always be zero and does not need to be\n  * specified. For live playlists, it should be the difference\n  * between the media sequence numbers in the original and updated\n  * playlists.\n  * @return a list of merged segment objects\n  */\n\nvar updateSegments = function updateSegments(original, update, offset) {\n  var result = update.slice();\n  offset = offset || 0;\n  var length = Math.min(original.length, update.length + offset);\n\n  for (var i = offset; i < length; i++) {\n    result[i - offset] = mergeOptions$1(original[i], result[i - offset]);\n  }\n\n  return result;\n};\n\nvar resolveSegmentUris = function resolveSegmentUris(segment, baseUri) {\n  if (!segment.resolvedUri) {\n    segment.resolvedUri = resolveUrl(baseUri, segment.uri);\n  }\n\n  if (segment.key && !segment.key.resolvedUri) {\n    segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);\n  }\n\n  if (segment.map && !segment.map.resolvedUri) {\n    segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);\n  }\n};\n/**\n  * Returns a new master playlist that is the result of merging an\n  * updated media playlist into the original version. If the\n  * updated media playlist does not match any of the playlist\n  * entries in the original master playlist, null is returned.\n  *\n  * @param {Object} master a parsed master M3U8 object\n  * @param {Object} media a parsed media M3U8 object\n  * @return {Object} a new object that represents the original\n  * master playlist with the updated media playlist merged in, or\n  * null if the merge produced no change.\n  */\n\n\nvar updateMaster = function updateMaster(master, media) {\n  var result = mergeOptions$1(master, {});\n  var playlist = result.playlists[media.id];\n\n  if (!playlist) {\n    return null;\n  } // consider the playlist unchanged if the number of segments is equal, the media\n  // sequence number is unchanged, and this playlist hasn't become the end of the playlist\n\n\n  if (playlist.segments && media.segments && playlist.segments.length === media.segments.length && playlist.endList === media.endList && playlist.mediaSequence === media.mediaSequence) {\n    return null;\n  }\n\n  var mergedPlaylist = mergeOptions$1(playlist, media); // if the update could overlap existing segment information, merge the two segment lists\n\n  if (playlist.segments) {\n    mergedPlaylist.segments = updateSegments(playlist.segments, media.segments, media.mediaSequence - playlist.mediaSequence);\n  } // resolve any segment URIs to prevent us from having to do it later\n\n\n  mergedPlaylist.segments.forEach(function (segment) {\n    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n  }); // TODO Right now in the playlists array there are two references to each playlist, one\n  // that is referenced by index, and one by URI. The index reference may no longer be\n  // necessary.\n\n  for (var i = 0; i < result.playlists.length; i++) {\n    if (result.playlists[i].id === media.id) {\n      result.playlists[i] = mergedPlaylist;\n    }\n  }\n\n  result.playlists[media.id] = mergedPlaylist; // URI reference added for backwards compatibility\n\n  result.playlists[media.uri] = mergedPlaylist;\n  return result;\n};\n/**\n * Calculates the time to wait before refreshing a live playlist\n *\n * @param {Object} media\n *        The current media\n * @param {boolean} update\n *        True if there were any updates from the last refresh, false otherwise\n * @return {number}\n *         The time in ms to wait before refreshing the live playlist\n */\n\n\nvar refreshDelay = function refreshDelay(media, update) {\n  var lastSegment = media.segments[media.segments.length - 1];\n  var delay;\n\n  if (update && lastSegment && lastSegment.duration) {\n    delay = lastSegment.duration * 1000;\n  } else {\n    // if the playlist is unchanged since the last reload or last segment duration\n    // cannot be determined, try again after half the target duration\n    delay = (media.targetDuration || 10) * 500;\n  }\n\n  return delay;\n};\n/**\n * Load a playlist from a remote location\n *\n * @class PlaylistLoader\n * @extends Stream\n * @param {string|Object} src url or object of manifest\n * @param {boolean} withCredentials the withCredentials xhr option\n * @class\n */\n\n\nvar PlaylistLoader = /*#__PURE__*/function (_EventTarget) {\n  _inheritsLoose(PlaylistLoader, _EventTarget);\n\n  function PlaylistLoader(src, vhs, options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _EventTarget.call(this) || this;\n\n    if (!src) {\n      throw new Error('A non-empty playlist URL or object is required');\n    }\n\n    var _options = options,\n        _options$withCredenti = _options.withCredentials,\n        withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti,\n        _options$handleManife = _options.handleManifestRedirects,\n        handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;\n    _this.src = src;\n    _this.vhs_ = vhs;\n    _this.withCredentials = withCredentials;\n    _this.handleManifestRedirects = handleManifestRedirects;\n    var vhsOptions = vhs.options_;\n    _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];\n    _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || []; // initialize the loader state\n\n    _this.state = 'HAVE_NOTHING'; // live playlist staleness timeout\n\n    _this.on('mediaupdatetimeout', function () {\n      if (_this.state !== 'HAVE_METADATA') {\n        // only refresh the media playlist if no other activity is going on\n        return;\n      }\n\n      _this.state = 'HAVE_CURRENT_METADATA';\n      _this.request = _this.vhs_.xhr({\n        uri: resolveUrl(_this.master.uri, _this.media().uri),\n        withCredentials: _this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this.request) {\n          return;\n        }\n\n        if (error) {\n          return _this.playlistRequestError(_this.request, _this.media(), 'HAVE_METADATA');\n        }\n\n        _this.haveMetadata({\n          playlistString: _this.request.responseText,\n          url: _this.media().uri,\n          id: _this.media().id\n        });\n      });\n    });\n\n    return _this;\n  }\n\n  var _proto = PlaylistLoader.prototype;\n\n  _proto.playlistRequestError = function playlistRequestError(xhr, playlist, startingState) {\n    var uri = playlist.uri,\n        id = playlist.id; // any in-flight request is now finished\n\n    this.request = null;\n\n    if (startingState) {\n      this.state = startingState;\n    }\n\n    this.error = {\n      playlist: this.master.playlists[id],\n      status: xhr.status,\n      message: \"HLS playlist request error at URL: \" + uri + \".\",\n      responseText: xhr.responseText,\n      code: xhr.status >= 500 ? 4 : 2\n    };\n    this.trigger('error');\n  }\n  /**\n   * Update the playlist loader's state in response to a new or updated playlist.\n   *\n   * @param {string} [playlistString]\n   *        Playlist string (if playlistObject is not provided)\n   * @param {Object} [playlistObject]\n   *        Playlist object (if playlistString is not provided)\n   * @param {string} url\n   *        URL of playlist\n   * @param {string} id\n   *        ID to use for playlist\n   */\n  ;\n\n  _proto.haveMetadata = function haveMetadata(_ref) {\n    var _this2 = this;\n\n    var playlistString = _ref.playlistString,\n        playlistObject = _ref.playlistObject,\n        url = _ref.url,\n        id = _ref.id; // any in-flight request is now finished\n\n    this.request = null;\n    this.state = 'HAVE_METADATA';\n    var playlist = playlistObject || parseManifest({\n      manifestString: playlistString,\n      customTagParsers: this.customTagParsers,\n      customTagMappers: this.customTagMappers\n    });\n    setupMediaPlaylist({\n      playlist: playlist,\n      uri: url,\n      id: id\n    }); // merge this playlist into the master\n\n    var update = updateMaster(this.master, playlist);\n    this.targetDuration = playlist.targetDuration;\n\n    if (update) {\n      this.master = update;\n      this.media_ = this.master.playlists[id];\n    } else {\n      this.trigger('playlistunchanged');\n    } // refresh live playlists after a target duration passes\n\n\n    if (!this.media().endList) {\n      window$1.clearTimeout(this.mediaUpdateTimeout);\n      this.mediaUpdateTimeout = window$1.setTimeout(function () {\n        _this2.trigger('mediaupdatetimeout');\n      }, refreshDelay(this.media(), !!update));\n    }\n\n    this.trigger('loadedplaylist');\n  }\n  /**\n    * Abort any outstanding work and clean up.\n    */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.trigger('dispose');\n    this.stopRequest();\n    window$1.clearTimeout(this.mediaUpdateTimeout);\n    window$1.clearTimeout(this.finalRenditionTimeout);\n    this.off();\n  };\n\n  _proto.stopRequest = function stopRequest() {\n    if (this.request) {\n      var oldRequest = this.request;\n      this.request = null;\n      oldRequest.onreadystatechange = null;\n      oldRequest.abort();\n    }\n  }\n  /**\n    * When called without any arguments, returns the currently\n    * active media playlist. When called with a single argument,\n    * triggers the playlist loader to asynchronously switch to the\n    * specified media playlist. Calling this method while the\n    * loader is in the HAVE_NOTHING causes an error to be emitted\n    * but otherwise has no effect.\n    *\n    * @param {Object=} playlist the parsed media playlist\n    * object to switch to\n    * @param {boolean=} is this the last available playlist\n    *\n    * @return {Playlist} the current loaded media\n    */\n  ;\n\n  _proto.media = function media(playlist, isFinalRendition) {\n    var _this3 = this; // getter\n\n\n    if (!playlist) {\n      return this.media_;\n    } // setter\n\n\n    if (this.state === 'HAVE_NOTHING') {\n      throw new Error('Cannot switch media playlist from ' + this.state);\n    } // find the playlist object if the target playlist has been\n    // specified by URI\n\n\n    if (typeof playlist === 'string') {\n      if (!this.master.playlists[playlist]) {\n        throw new Error('Unknown playlist URI: ' + playlist);\n      }\n\n      playlist = this.master.playlists[playlist];\n    }\n\n    window$1.clearTimeout(this.finalRenditionTimeout);\n\n    if (isFinalRendition) {\n      var delay = playlist.targetDuration / 2 * 1000 || 5 * 1000;\n      this.finalRenditionTimeout = window$1.setTimeout(this.media.bind(this, playlist, false), delay);\n      return;\n    }\n\n    var startingState = this.state;\n    var mediaChange = !this.media_ || playlist.id !== this.media_.id; // switch to fully loaded playlists immediately\n\n    if (this.master.playlists[playlist.id].endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved\n    // media playlist or, for the case of demuxed audio, a resolved audio media group)\n    playlist.endList && playlist.segments.length) {\n      // abort outstanding playlist requests\n      if (this.request) {\n        this.request.onreadystatechange = null;\n        this.request.abort();\n        this.request = null;\n      }\n\n      this.state = 'HAVE_METADATA';\n      this.media_ = playlist; // trigger media change if the active media has been updated\n\n      if (mediaChange) {\n        this.trigger('mediachanging');\n\n        if (startingState === 'HAVE_MASTER') {\n          // The initial playlist was a master manifest, and the first media selected was\n          // also provided (in the form of a resolved playlist object) as part of the\n          // source object (rather than just a URL). Therefore, since the media playlist\n          // doesn't need to be requested, loadedmetadata won't trigger as part of the\n          // normal flow, and needs an explicit trigger here.\n          this.trigger('loadedmetadata');\n        } else {\n          this.trigger('mediachange');\n        }\n      }\n\n      return;\n    } // switching to the active playlist is a no-op\n\n\n    if (!mediaChange) {\n      return;\n    }\n\n    this.state = 'SWITCHING_MEDIA'; // there is already an outstanding playlist request\n\n    if (this.request) {\n      if (playlist.resolvedUri === this.request.url) {\n        // requesting to switch to the same playlist multiple times\n        // has no effect after the first\n        return;\n      }\n\n      this.request.onreadystatechange = null;\n      this.request.abort();\n      this.request = null;\n    } // request the new playlist\n\n\n    if (this.media_) {\n      this.trigger('mediachanging');\n    }\n\n    this.request = this.vhs_.xhr({\n      uri: playlist.resolvedUri,\n      withCredentials: this.withCredentials\n    }, function (error, req) {\n      // disposed\n      if (!_this3.request) {\n        return;\n      }\n\n      playlist.resolvedUri = resolveManifestRedirect(_this3.handleManifestRedirects, playlist.resolvedUri, req);\n\n      if (error) {\n        return _this3.playlistRequestError(_this3.request, playlist, startingState);\n      }\n\n      _this3.haveMetadata({\n        playlistString: req.responseText,\n        url: playlist.uri,\n        id: playlist.id\n      }); // fire loadedmetadata the first time a media playlist is loaded\n\n\n      if (startingState === 'HAVE_MASTER') {\n        _this3.trigger('loadedmetadata');\n      } else {\n        _this3.trigger('mediachange');\n      }\n    });\n  }\n  /**\n   * pause loading of the playlist\n   */\n  ;\n\n  _proto.pause = function pause() {\n    this.stopRequest();\n    window$1.clearTimeout(this.mediaUpdateTimeout);\n\n    if (this.state === 'HAVE_NOTHING') {\n      // If we pause the loader before any data has been retrieved, its as if we never\n      // started, so reset to an unstarted state.\n      this.started = false;\n    } // Need to restore state now that no activity is happening\n\n\n    if (this.state === 'SWITCHING_MEDIA') {\n      // if the loader was in the process of switching media, it should either return to\n      // HAVE_MASTER or HAVE_METADATA depending on if the loader has loaded a media\n      // playlist yet. This is determined by the existence of loader.media_\n      if (this.media_) {\n        this.state = 'HAVE_METADATA';\n      } else {\n        this.state = 'HAVE_MASTER';\n      }\n    } else if (this.state === 'HAVE_CURRENT_METADATA') {\n      this.state = 'HAVE_METADATA';\n    }\n  }\n  /**\n   * start loading of the playlist\n   */\n  ;\n\n  _proto.load = function load(isFinalRendition) {\n    var _this4 = this;\n\n    window$1.clearTimeout(this.mediaUpdateTimeout);\n    var media = this.media();\n\n    if (isFinalRendition) {\n      var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n      this.mediaUpdateTimeout = window$1.setTimeout(function () {\n        return _this4.load();\n      }, delay);\n      return;\n    }\n\n    if (!this.started) {\n      this.start();\n      return;\n    }\n\n    if (media && !media.endList) {\n      this.trigger('mediaupdatetimeout');\n    } else {\n      this.trigger('loadedplaylist');\n    }\n  }\n  /**\n   * start loading of the playlist\n   */\n  ;\n\n  _proto.start = function start() {\n    var _this5 = this;\n\n    this.started = true;\n\n    if (typeof this.src === 'object') {\n      // in the case of an entirely constructed manifest object (meaning there's no actual\n      // manifest on a server), default the uri to the page's href\n      if (!this.src.uri) {\n        this.src.uri = window$1.location.href;\n      } // resolvedUri is added on internally after the initial request. Since there's no\n      // request for pre-resolved manifests, add on resolvedUri here.\n\n\n      this.src.resolvedUri = this.src.uri; // Since a manifest object was passed in as the source (instead of a URL), the first\n      // request can be skipped (since the top level of the manifest, at a minimum, is\n      // already available as a parsed manifest object). However, if the manifest object\n      // represents a master playlist, some media playlists may need to be resolved before\n      // the starting segment list is available. Therefore, go directly to setup of the\n      // initial playlist, and let the normal flow continue from there.\n      //\n      // Note that the call to setup is asynchronous, as other sections of VHS may assume\n      // that the first request is asynchronous.\n\n      setTimeout(function () {\n        _this5.setupInitialPlaylist(_this5.src);\n      }, 0);\n      return;\n    } // request the specified URL\n\n\n    this.request = this.vhs_.xhr({\n      uri: this.src,\n      withCredentials: this.withCredentials\n    }, function (error, req) {\n      // disposed\n      if (!_this5.request) {\n        return;\n      } // clear the loader's request reference\n\n\n      _this5.request = null;\n\n      if (error) {\n        _this5.error = {\n          status: req.status,\n          message: \"HLS playlist request error at URL: \" + _this5.src + \".\",\n          responseText: req.responseText,\n          // MEDIA_ERR_NETWORK\n          code: 2\n        };\n\n        if (_this5.state === 'HAVE_NOTHING') {\n          _this5.started = false;\n        }\n\n        return _this5.trigger('error');\n      }\n\n      _this5.src = resolveManifestRedirect(_this5.handleManifestRedirects, _this5.src, req);\n      var manifest = parseManifest({\n        manifestString: req.responseText,\n        customTagParsers: _this5.customTagParsers,\n        customTagMappers: _this5.customTagMappers\n      });\n\n      _this5.setupInitialPlaylist(manifest);\n    });\n  };\n\n  _proto.srcUri = function srcUri() {\n    return typeof this.src === 'string' ? this.src : this.src.uri;\n  }\n  /**\n   * Given a manifest object that's either a master or media playlist, trigger the proper\n   * events and set the state of the playlist loader.\n   *\n   * If the manifest object represents a master playlist, `loadedplaylist` will be\n   * triggered to allow listeners to select a playlist. If none is selected, the loader\n   * will default to the first one in the playlists array.\n   *\n   * If the manifest object represents a media playlist, `loadedplaylist` will be\n   * triggered followed by `loadedmetadata`, as the only available playlist is loaded.\n   *\n   * In the case of a media playlist, a master playlist object wrapper with one playlist\n   * will be created so that all logic can handle playlists in the same fashion (as an\n   * assumed manifest object schema).\n   *\n   * @param {Object} manifest\n   *        The parsed manifest object\n   */\n  ;\n\n  _proto.setupInitialPlaylist = function setupInitialPlaylist(manifest) {\n    this.state = 'HAVE_MASTER';\n\n    if (manifest.playlists) {\n      this.master = manifest;\n      addPropertiesToMaster(this.master, this.srcUri()); // If the initial master playlist has playlists wtih segments already resolved,\n      // then resolve URIs in advance, as they are usually done after a playlist request,\n      // which may not happen if the playlist is resolved.\n\n      manifest.playlists.forEach(function (playlist) {\n        if (playlist.segments) {\n          playlist.segments.forEach(function (segment) {\n            resolveSegmentUris(segment, playlist.resolvedUri);\n          });\n        }\n      });\n      this.trigger('loadedplaylist');\n\n      if (!this.request) {\n        // no media playlist was specifically selected so start\n        // from the first listed one\n        this.media(this.master.playlists[0]);\n      }\n\n      return;\n    } // In order to support media playlists passed in as vhs-json, the case where the uri\n    // is not provided as part of the manifest should be considered, and an appropriate\n    // default used.\n\n\n    var uri = this.srcUri() || window$1.location.href;\n    this.master = masterForMedia(manifest, uri);\n    this.haveMetadata({\n      playlistObject: manifest,\n      url: uri,\n      id: this.master.playlists[0].id\n    });\n    this.trigger('loadedmetadata');\n  };\n\n  return PlaylistLoader;\n}(EventTarget$1);\n/**\n * ranges\n *\n * Utilities for working with TimeRanges.\n *\n */\n\n\nvar TIME_FUDGE_FACTOR = 1 / 30; // Comparisons between time values such as current time and the end of the buffered range\n// can be misleading because of precision differences or when the current media has poorly\n// aligned audio and video, which can cause values to be slightly off from what you would\n// expect. This value is what we consider to be safe to use in such comparisons to account\n// for these scenarios.\n\nvar SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\n\nvar filterRanges = function filterRanges(timeRanges, predicate) {\n  var results = [];\n  var i;\n\n  if (timeRanges && timeRanges.length) {\n    // Search for ranges that match the predicate\n    for (i = 0; i < timeRanges.length; i++) {\n      if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n        results.push([timeRanges.start(i), timeRanges.end(i)]);\n      }\n    }\n  }\n\n  return videojs$1.createTimeRanges(results);\n};\n/**\n * Attempts to find the buffered TimeRange that contains the specified\n * time.\n *\n * @param {TimeRanges} buffered - the TimeRanges object to query\n * @param {number} time  - the time to filter on.\n * @return {TimeRanges} a new TimeRanges object\n */\n\n\nvar findRange = function findRange(buffered, time) {\n  return filterRanges(buffered, function (start, end) {\n    return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;\n  });\n};\n/**\n * Returns the TimeRanges that begin later than the specified time.\n *\n * @param {TimeRanges} timeRanges - the TimeRanges object to query\n * @param {number} time - the time to filter on.\n * @return {TimeRanges} a new TimeRanges object.\n */\n\n\nvar findNextRange = function findNextRange(timeRanges, time) {\n  return filterRanges(timeRanges, function (start) {\n    return start - TIME_FUDGE_FACTOR >= time;\n  });\n};\n/**\n * Returns gaps within a list of TimeRanges\n *\n * @param {TimeRanges} buffered - the TimeRanges object\n * @return {TimeRanges} a TimeRanges object of gaps\n */\n\n\nvar findGaps = function findGaps(buffered) {\n  if (buffered.length < 2) {\n    return videojs$1.createTimeRanges();\n  }\n\n  var ranges = [];\n\n  for (var i = 1; i < buffered.length; i++) {\n    var start = buffered.end(i - 1);\n    var end = buffered.start(i);\n    ranges.push([start, end]);\n  }\n\n  return videojs$1.createTimeRanges(ranges);\n};\n/**\n * Calculate the intersection of two TimeRanges\n *\n * @param {TimeRanges} bufferA\n * @param {TimeRanges} bufferB\n * @return {TimeRanges} The interesection of `bufferA` with `bufferB`\n */\n\n\nvar bufferIntersection = function bufferIntersection(bufferA, bufferB) {\n  var start = null;\n  var end = null;\n  var arity = 0;\n  var extents = [];\n  var ranges = [];\n\n  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\n    return videojs$1.createTimeRange();\n  } // Handle the case where we have both buffers and create an\n  // intersection of the two\n\n\n  var count = bufferA.length; // A) Gather up all start and end times\n\n  while (count--) {\n    extents.push({\n      time: bufferA.start(count),\n      type: 'start'\n    });\n    extents.push({\n      time: bufferA.end(count),\n      type: 'end'\n    });\n  }\n\n  count = bufferB.length;\n\n  while (count--) {\n    extents.push({\n      time: bufferB.start(count),\n      type: 'start'\n    });\n    extents.push({\n      time: bufferB.end(count),\n      type: 'end'\n    });\n  } // B) Sort them by time\n\n\n  extents.sort(function (a, b) {\n    return a.time - b.time;\n  }); // C) Go along one by one incrementing arity for start and decrementing\n  //    arity for ends\n\n  for (count = 0; count < extents.length; count++) {\n    if (extents[count].type === 'start') {\n      arity++; // D) If arity is ever incremented to 2 we are entering an\n      //    overlapping range\n\n      if (arity === 2) {\n        start = extents[count].time;\n      }\n    } else if (extents[count].type === 'end') {\n      arity--; // E) If arity is ever decremented to 1 we leaving an\n      //    overlapping range\n\n      if (arity === 1) {\n        end = extents[count].time;\n      }\n    } // F) Record overlapping ranges\n\n\n    if (start !== null && end !== null) {\n      ranges.push([start, end]);\n      start = null;\n      end = null;\n    }\n  }\n\n  return videojs$1.createTimeRanges(ranges);\n};\n/**\n * Gets a human readable string for a TimeRange\n *\n * @param {TimeRange} range\n * @return {string} a human readable string\n */\n\n\nvar printableRange = function printableRange(range) {\n  var strArr = [];\n\n  if (!range || !range.length) {\n    return '';\n  }\n\n  for (var i = 0; i < range.length; i++) {\n    strArr.push(range.start(i) + ' => ' + range.end(i));\n  }\n\n  return strArr.join(', ');\n};\n/**\n * Calculates the amount of time left in seconds until the player hits the end of the\n * buffer and causes a rebuffer\n *\n * @param {TimeRange} buffered\n *        The state of the buffer\n * @param {Numnber} currentTime\n *        The current time of the player\n * @param {number} playbackRate\n *        The current playback rate of the player. Defaults to 1.\n * @return {number}\n *         Time until the player has to start rebuffering in seconds.\n * @function timeUntilRebuffer\n */\n\n\nvar timeUntilRebuffer = function timeUntilRebuffer(buffered, currentTime, playbackRate) {\n  if (playbackRate === void 0) {\n    playbackRate = 1;\n  }\n\n  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n  return (bufferedEnd - currentTime) / playbackRate;\n};\n/**\n * Converts a TimeRanges object into an array representation\n *\n * @param {TimeRanges} timeRanges\n * @return {Array}\n */\n\n\nvar timeRangesToArray = function timeRangesToArray(timeRanges) {\n  var timeRangesList = [];\n\n  for (var i = 0; i < timeRanges.length; i++) {\n    timeRangesList.push({\n      start: timeRanges.start(i),\n      end: timeRanges.end(i)\n    });\n  }\n\n  return timeRangesList;\n};\n/**\n * Determines if two time range objects are different.\n *\n * @param {TimeRange} a\n *        the first time range object to check\n *\n * @param {TimeRange} b\n *        the second time range object to check\n *\n * @return {Boolean}\n *         Whether the time range objects differ\n */\n\n\nvar isRangeDifferent = function isRangeDifferent(a, b) {\n  // same object\n  if (a === b) {\n    return false;\n  } // one or the other is undefined\n\n\n  if (!a && b || !b && a) {\n    return true;\n  } // length is different\n\n\n  if (a.length !== b.length) {\n    return true;\n  } // see if any start/end pair is different\n\n\n  for (var i = 0; i < a.length; i++) {\n    if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {\n      return true;\n    }\n  } // if the length and every pair is the same\n  // this is the same time range\n\n\n  return false;\n};\n/**\n * @file playlist.js\n *\n * Playlist related utilities.\n */\n\n\nvar createTimeRange = videojs$1.createTimeRange;\n/**\n * walk backward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\n\nvar backwardDuration = function backwardDuration(playlist, endSequence) {\n  var result = 0;\n  var i = endSequence - playlist.mediaSequence; // if a start time is available for segment immediately following\n  // the interval, use it\n\n  var segment = playlist.segments[i]; // Walk backward until we find the latest segment with timeline\n  // information that is earlier than endSequence\n\n  if (segment) {\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: segment.start,\n        precise: true\n      };\n    }\n\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - segment.duration,\n        precise: true\n      };\n    }\n  }\n\n  while (i--) {\n    segment = playlist.segments[i];\n\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: result + segment.end,\n        precise: true\n      };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: result + segment.start,\n        precise: true\n      };\n    }\n  }\n\n  return {\n    result: result,\n    precise: false\n  };\n};\n/**\n * walk forward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {number} endSequence the mediaSequence to stop walking on\n */\n\n\nvar forwardDuration = function forwardDuration(playlist, endSequence) {\n  var result = 0;\n  var segment;\n  var i = endSequence - playlist.mediaSequence; // Walk forward until we find the earliest segment with timeline\n  // information\n\n  for (; i < playlist.segments.length; i++) {\n    segment = playlist.segments[i];\n\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: segment.start - result,\n        precise: true\n      };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - result,\n        precise: true\n      };\n    }\n  } // indicate we didn't find a useful duration estimate\n\n\n  return {\n    result: -1,\n    precise: false\n  };\n};\n/**\n  * Calculate the media duration from the segments associated with a\n  * playlist. The duration of a subinterval of the available segments\n  * may be calculated by specifying an end index.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {number=} endSequence an exclusive upper boundary\n  * for the playlist.  Defaults to playlist length.\n  * @param {number} expired the amount of time that has dropped\n  * off the front of the playlist in a live scenario\n  * @return {number} the duration between the first available segment\n  * and end index.\n  */\n\n\nvar intervalDuration = function intervalDuration(playlist, endSequence, expired) {\n  if (typeof endSequence === 'undefined') {\n    endSequence = playlist.mediaSequence + playlist.segments.length;\n  }\n\n  if (endSequence < playlist.mediaSequence) {\n    return 0;\n  } // do a backward walk to estimate the duration\n\n\n  var backward = backwardDuration(playlist, endSequence);\n\n  if (backward.precise) {\n    // if we were able to base our duration estimate on timing\n    // information provided directly from the Media Source, return\n    // it\n    return backward.result;\n  } // walk forward to see if a precise duration estimate can be made\n  // that way\n\n\n  var forward = forwardDuration(playlist, endSequence);\n\n  if (forward.precise) {\n    // we found a segment that has been buffered and so it's\n    // position is known precisely\n    return forward.result;\n  } // return the less-precise, playlist-based duration estimate\n\n\n  return backward.result + expired;\n};\n/**\n  * Calculates the duration of a playlist. If a start and end index\n  * are specified, the duration will be for the subset of the media\n  * timeline between those two indices. The total duration for live\n  * playlists is always Infinity.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {number=} endSequence an exclusive upper\n  * boundary for the playlist. Defaults to the playlist media\n  * sequence number plus its length.\n  * @param {number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {number} the duration between the start index and end\n  * index.\n  */\n\n\nvar duration = function duration(playlist, endSequence, expired) {\n  if (!playlist) {\n    return 0;\n  }\n\n  if (typeof expired !== 'number') {\n    expired = 0;\n  } // if a slice of the total duration is not requested, use\n  // playlist-level duration indicators when they're present\n\n\n  if (typeof endSequence === 'undefined') {\n    // if present, use the duration specified in the playlist\n    if (playlist.totalDuration) {\n      return playlist.totalDuration;\n    } // duration should be Infinity for live playlists\n\n\n    if (!playlist.endList) {\n      return window$1.Infinity;\n    }\n  } // calculate the total duration based on the segment durations\n\n\n  return intervalDuration(playlist, endSequence, expired);\n};\n/**\n  * Calculate the time between two indexes in the current playlist\n  * neight the start- nor the end-index need to be within the current\n  * playlist in which case, the targetDuration of the playlist is used\n  * to approximate the durations of the segments\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {number} startIndex\n  * @param {number} endIndex\n  * @return {number} the number of seconds between startIndex and endIndex\n  */\n\n\nvar sumDurations = function sumDurations(playlist, startIndex, endIndex) {\n  var durations = 0;\n\n  if (startIndex > endIndex) {\n    var _ref = [endIndex, startIndex];\n    startIndex = _ref[0];\n    endIndex = _ref[1];\n  }\n\n  if (startIndex < 0) {\n    for (var i = startIndex; i < Math.min(0, endIndex); i++) {\n      durations += playlist.targetDuration;\n    }\n\n    startIndex = 0;\n  }\n\n  for (var _i = startIndex; _i < endIndex; _i++) {\n    durations += playlist.segments[_i].duration;\n  }\n\n  return durations;\n};\n/**\n * Determines the media index of the segment corresponding to the safe edge of the live\n * window which is the duration of the last segment plus 2 target durations from the end\n * of the playlist.\n *\n * A liveEdgePadding can be provided which will be used instead of calculating the safe live edge.\n * This corresponds to suggestedPresentationDelay in DASH manifests.\n *\n * @param {Object} playlist\n *        a media playlist object\n * @param {number} [liveEdgePadding]\n *        A number in seconds indicating how far from the end we want to be.\n *        If provided, this value is used instead of calculating the safe live index from the target durations.\n *        Corresponds to suggestedPresentationDelay in DASH manifests.\n * @return {number}\n *         The media index of the segment at the safe live point. 0 if there is no \"safe\"\n *         point.\n * @function safeLiveIndex\n */\n\n\nvar safeLiveIndex = function safeLiveIndex(playlist, liveEdgePadding) {\n  if (!playlist.segments.length) {\n    return 0;\n  }\n\n  var i = playlist.segments.length;\n  var lastSegmentDuration = playlist.segments[i - 1].duration || playlist.targetDuration;\n  var safeDistance = typeof liveEdgePadding === 'number' ? liveEdgePadding : lastSegmentDuration + playlist.targetDuration * 2;\n\n  if (safeDistance === 0) {\n    return i;\n  }\n\n  var distanceFromEnd = 0;\n\n  while (i--) {\n    distanceFromEnd += playlist.segments[i].duration;\n\n    if (distanceFromEnd >= safeDistance) {\n      break;\n    }\n  }\n\n  return Math.max(0, i);\n};\n/**\n * Calculates the playlist end time\n *\n * @param {Object} playlist a media playlist object\n * @param {number=} expired the amount of time that has\n *                  dropped off the front of the playlist in a live scenario\n * @param {boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n *                        playlist end calculation should consider the safe live end\n *                        (truncate the playlist end by three segments). This is normally\n *                        used for calculating the end of the playlist's seekable range.\n *                        This takes into account the value of liveEdgePadding.\n *                        Setting liveEdgePadding to 0 is equivalent to setting this to false.\n * @param {number} liveEdgePadding a number indicating how far from the end of the playlist we should be in seconds.\n *                 If this is provided, it is used in the safe live end calculation.\n *                 Setting useSafeLiveEnd=false or liveEdgePadding=0 are equivalent.\n *                 Corresponds to suggestedPresentationDelay in DASH manifests.\n * @return {number} the end time of playlist\n * @function playlistEnd\n */\n\n\nvar playlistEnd = function playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding) {\n  if (!playlist || !playlist.segments) {\n    return null;\n  }\n\n  if (playlist.endList) {\n    return duration(playlist);\n  }\n\n  if (expired === null) {\n    return null;\n  }\n\n  expired = expired || 0;\n  var endSequence = useSafeLiveEnd ? safeLiveIndex(playlist, liveEdgePadding) : playlist.segments.length;\n  return intervalDuration(playlist, playlist.mediaSequence + endSequence, expired);\n};\n/**\n  * Calculates the interval of time that is currently seekable in a\n  * playlist. The returned time ranges are relative to the earliest\n  * moment in the specified playlist that is still available. A full\n  * seekable implementation for live streams would need to offset\n  * these values by the duration of content that has expired from the\n  * stream.\n  *\n  * @param {Object} playlist a media playlist object\n  * dropped off the front of the playlist in a live scenario\n  * @param {number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @param {number} liveEdgePadding how far from the end of the playlist we should be in seconds.\n  *        Corresponds to suggestedPresentationDelay in DASH manifests.\n  * @return {TimeRanges} the periods of time that are valid targets\n  * for seeking\n  */\n\n\nvar seekable = function seekable(playlist, expired, liveEdgePadding) {\n  var useSafeLiveEnd = true;\n  var seekableStart = expired || 0;\n  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);\n\n  if (seekableEnd === null) {\n    return createTimeRange();\n  }\n\n  return createTimeRange(seekableStart, seekableEnd);\n};\n/**\n * Determine the index and estimated starting time of the segment that\n * contains a specified playback position in a media playlist.\n *\n * @param {Object} playlist the media playlist to query\n * @param {number} currentTime The number of seconds since the earliest\n * possible position to determine the containing segment for\n * @param {number} startIndex\n * @param {number} startTime\n * @return {Object}\n */\n\n\nvar getMediaInfoForTime = function getMediaInfoForTime(playlist, currentTime, startIndex, startTime) {\n  var i;\n  var segment;\n  var numSegments = playlist.segments.length;\n  var time = currentTime - startTime;\n\n  if (time < 0) {\n    // Walk backward from startIndex in the playlist, adding durations\n    // until we find a segment that contains `time` and return it\n    if (startIndex > 0) {\n      for (i = startIndex - 1; i >= 0; i--) {\n        segment = playlist.segments[i];\n        time += segment.duration + TIME_FUDGE_FACTOR;\n\n        if (time > 0) {\n          return {\n            mediaIndex: i,\n            startTime: startTime - sumDurations(playlist, startIndex, i)\n          };\n        }\n      }\n    } // We were unable to find a good segment within the playlist\n    // so select the first segment\n\n\n    return {\n      mediaIndex: 0,\n      startTime: currentTime\n    };\n  } // When startIndex is negative, we first walk forward to first segment\n  // adding target durations. If we \"run out of time\" before getting to\n  // the first segment, return the first segment\n\n\n  if (startIndex < 0) {\n    for (i = startIndex; i < 0; i++) {\n      time -= playlist.targetDuration;\n\n      if (time < 0) {\n        return {\n          mediaIndex: 0,\n          startTime: currentTime\n        };\n      }\n    }\n\n    startIndex = 0;\n  } // Walk forward from startIndex in the playlist, subtracting durations\n  // until we find a segment that contains `time` and return it\n\n\n  for (i = startIndex; i < numSegments; i++) {\n    segment = playlist.segments[i];\n    time -= segment.duration + TIME_FUDGE_FACTOR;\n\n    if (time < 0) {\n      return {\n        mediaIndex: i,\n        startTime: startTime + sumDurations(playlist, startIndex, i)\n      };\n    }\n  } // We are out of possible candidates so load the last one...\n\n\n  return {\n    mediaIndex: numSegments - 1,\n    startTime: currentTime\n  };\n};\n/**\n * Check whether the playlist is blacklisted or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is blacklisted or not\n * @function isBlacklisted\n */\n\n\nvar isBlacklisted = function isBlacklisted(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n};\n/**\n * Check whether the playlist is compatible with current playback configuration or has\n * been blacklisted permanently for being incompatible.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is incompatible or not\n * @function isIncompatible\n */\n\n\nvar isIncompatible = function isIncompatible(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n};\n/**\n * Check whether the playlist is enabled or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is enabled or not\n * @function isEnabled\n */\n\n\nvar isEnabled = function isEnabled(playlist) {\n  var blacklisted = isBlacklisted(playlist);\n  return !playlist.disabled && !blacklisted;\n};\n/**\n * Check whether the playlist has been manually disabled through the representations api.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is disabled manually or not\n * @function isDisabled\n */\n\n\nvar isDisabled = function isDisabled(playlist) {\n  return playlist.disabled;\n};\n/**\n * Returns whether the current playlist is an AES encrypted HLS stream\n *\n * @return {boolean} true if it's an AES encrypted HLS stream\n */\n\n\nvar isAes = function isAes(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].key) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Checks if the playlist has a value for the specified attribute\n *\n * @param {string} attr\n *        Attribute to check for\n * @param {Object} playlist\n *        The media playlist object\n * @return {boolean}\n *         Whether the playlist contains a value for the attribute or not\n * @function hasAttribute\n */\n\n\nvar hasAttribute = function hasAttribute(attr, playlist) {\n  return playlist.attributes && playlist.attributes[attr];\n};\n/**\n * Estimates the time required to complete a segment download from the specified playlist\n *\n * @param {number} segmentDuration\n *        Duration of requested segment\n * @param {number} bandwidth\n *        Current measured bandwidth of the player\n * @param {Object} playlist\n *        The media playlist object\n * @param {number=} bytesReceived\n *        Number of bytes already received for the request. Defaults to 0\n * @return {number|NaN}\n *         The estimated time to request the segment. NaN if bandwidth information for\n *         the given playlist is unavailable\n * @function estimateSegmentRequestTime\n */\n\n\nvar estimateSegmentRequestTime = function estimateSegmentRequestTime(segmentDuration, bandwidth, playlist, bytesReceived) {\n  if (bytesReceived === void 0) {\n    bytesReceived = 0;\n  }\n\n  if (!hasAttribute('BANDWIDTH', playlist)) {\n    return NaN;\n  }\n\n  var size = segmentDuration * playlist.attributes.BANDWIDTH;\n  return (size - bytesReceived * 8) / bandwidth;\n};\n/*\n * Returns whether the current playlist is the lowest rendition\n *\n * @return {Boolean} true if on lowest rendition\n */\n\n\nvar isLowestEnabledRendition = function isLowestEnabledRendition(master, media) {\n  if (master.playlists.length === 1) {\n    return true;\n  }\n\n  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n  return master.playlists.filter(function (playlist) {\n    if (!isEnabled(playlist)) {\n      return false;\n    }\n\n    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n  }).length === 0;\n}; // exports\n\n\nvar Playlist = {\n  duration: duration,\n  seekable: seekable,\n  safeLiveIndex: safeLiveIndex,\n  getMediaInfoForTime: getMediaInfoForTime,\n  isEnabled: isEnabled,\n  isDisabled: isDisabled,\n  isBlacklisted: isBlacklisted,\n  isIncompatible: isIncompatible,\n  playlistEnd: playlistEnd,\n  isAes: isAes,\n  hasAttribute: hasAttribute,\n  estimateSegmentRequestTime: estimateSegmentRequestTime,\n  isLowestEnabledRendition: isLowestEnabledRendition\n};\n/**\n * @file xhr.js\n */\n\nvar videojsXHR = videojs$1.xhr,\n    mergeOptions$1$1 = videojs$1.mergeOptions;\n\nvar callbackWrapper = function callbackWrapper(request, error, response, callback) {\n  var reqResponse = request.responseType === 'arraybuffer' ? request.response : request.responseText;\n\n  if (!error && reqResponse) {\n    request.responseTime = Date.now();\n    request.roundTripTime = request.responseTime - request.requestTime;\n    request.bytesReceived = reqResponse.byteLength || reqResponse.length;\n\n    if (!request.bandwidth) {\n      request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\n    }\n  }\n\n  if (response.headers) {\n    request.responseHeaders = response.headers;\n  } // videojs.xhr now uses a specific code on the error\n  // object to signal that a request has timed out instead\n  // of setting a boolean on the request object\n\n\n  if (error && error.code === 'ETIMEDOUT') {\n    request.timedout = true;\n  } // videojs.xhr no longer considers status codes outside of 200 and 0\n  // (for file uris) to be errors, but the old XHR did, so emulate that\n  // behavior. Status 206 may be used in response to byterange requests.\n\n\n  if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\n    error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));\n  }\n\n  callback(error, request);\n};\n\nvar xhrFactory = function xhrFactory() {\n  var xhr = function XhrFunction(options, callback) {\n    // Add a default timeout\n    options = mergeOptions$1$1({\n      timeout: 45e3\n    }, options); // Allow an optional user-specified function to modify the option\n    // object before we construct the xhr request\n\n    var beforeRequest = XhrFunction.beforeRequest || videojs$1.Vhs.xhr.beforeRequest;\n\n    if (beforeRequest && typeof beforeRequest === 'function') {\n      var newOptions = beforeRequest(options);\n\n      if (newOptions) {\n        options = newOptions;\n      }\n    }\n\n    var request = videojsXHR(options, function (error, response) {\n      return callbackWrapper(request, error, response, callback);\n    });\n    var originalAbort = request.abort;\n\n    request.abort = function () {\n      request.aborted = true;\n      return originalAbort.apply(request, arguments);\n    };\n\n    request.uri = options.uri;\n    request.requestTime = Date.now();\n    return request;\n  };\n\n  return xhr;\n};\n/**\n * Turns segment byterange into a string suitable for use in\n * HTTP Range requests\n *\n * @param {Object} byterange - an object with two values defining the start and end\n *                             of a byte-range\n */\n\n\nvar byterangeStr = function byterangeStr(byterange) {\n  // `byterangeEnd` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  var byterangeEnd = byterange.offset + byterange.length - 1;\n  var byterangeStart = byterange.offset;\n  return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n};\n/**\n * Defines headers for use in the xhr request for a particular segment.\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n */\n\n\nvar segmentXhrHeaders = function segmentXhrHeaders(segment) {\n  var headers = {};\n\n  if (segment.byterange) {\n    headers.Range = byterangeStr(segment.byterange);\n  }\n\n  return headers;\n};\n/**\n * @file bin-utils.js\n */\n\n/**\n * convert a TimeRange to text\n *\n * @param {TimeRange} range the timerange to use for conversion\n * @param {number} i the iterator on the range to convert\n */\n\n\nvar textRange = function textRange(range, i) {\n  return range.start(i) + '-' + range.end(i);\n};\n/**\n * format a number as hex string\n *\n * @param {number} e The number\n * @param {number} i the iterator\n */\n\n\nvar formatHexString = function formatHexString(e, i) {\n  var value = e.toString(16);\n  return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\n};\n\nvar formatAsciiString = function formatAsciiString(e) {\n  if (e >= 0x20 && e < 0x7e) {\n    return String.fromCharCode(e);\n  }\n\n  return '.';\n};\n/**\n * Creates an object for sending to a web worker modifying properties that are TypedArrays\n * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n *\n * @param {Object} message\n *        Object of properties and values to send to the web worker\n * @return {Object}\n *         Modified message with TypedArray values expanded\n * @function createTransferableMessage\n */\n\n\nvar createTransferableMessage = function createTransferableMessage(message) {\n  var transferable = {};\n  Object.keys(message).forEach(function (key) {\n    var value = message[key];\n\n    if (ArrayBuffer.isView(value)) {\n      transferable[key] = {\n        bytes: value.buffer,\n        byteOffset: value.byteOffset,\n        byteLength: value.byteLength\n      };\n    } else {\n      transferable[key] = value;\n    }\n  });\n  return transferable;\n};\n/**\n * Returns a unique string identifier for a media initialization\n * segment.\n */\n\n\nvar initSegmentId = function initSegmentId(initSegment) {\n  var byterange = initSegment.byterange || {\n    length: Infinity,\n    offset: 0\n  };\n  return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');\n};\n/**\n * Returns a unique string identifier for a media segment key.\n */\n\n\nvar segmentKeyId = function segmentKeyId(key) {\n  return key.resolvedUri;\n};\n/**\n * utils to help dump binary data to the console\n */\n\n\nvar hexDump = function hexDump(data) {\n  var bytes = Array.prototype.slice.call(data);\n  var step = 16;\n  var result = '';\n  var hex;\n  var ascii;\n\n  for (var j = 0; j < bytes.length / step; j++) {\n    hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\n    ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\n    result += hex + ' ' + ascii + '\\n';\n  }\n\n  return result;\n};\n\nvar tagDump = function tagDump(_ref) {\n  var bytes = _ref.bytes;\n  return hexDump(bytes);\n};\n\nvar textRanges = function textRanges(ranges) {\n  var result = '';\n  var i;\n\n  for (i = 0; i < ranges.length; i++) {\n    result += textRange(ranges, i) + ' ';\n  }\n\n  return result;\n};\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createTransferableMessage: createTransferableMessage,\n  initSegmentId: initSegmentId,\n  segmentKeyId: segmentKeyId,\n  hexDump: hexDump,\n  tagDump: tagDump,\n  textRanges: textRanges\n}); // TODO handle fmp4 case where the timing info is accurate and doesn't involve transmux\n// 25% was arbitrarily chosen, and may need to be refined over time.\n\nvar SEGMENT_END_FUDGE_PERCENT = 0.25;\n/**\n * Converts a player time (any time that can be gotten/set from player.currentTime(),\n * e.g., any time within player.seekable().start(0) to player.seekable().end(0)) to a\n * program time (any time referencing the real world (e.g., EXT-X-PROGRAM-DATE-TIME)).\n *\n * The containing segment is required as the EXT-X-PROGRAM-DATE-TIME serves as an \"anchor\n * point\" (a point where we have a mapping from program time to player time, with player\n * time being the post transmux start of the segment).\n *\n * For more details, see [this doc](../../docs/program-time-from-player-time.md).\n *\n * @param {number} playerTime the player time\n * @param {Object} segment the segment which contains the player time\n * @return {Date} program time\n */\n\nvar playerTimeToProgramTime = function playerTimeToProgramTime(playerTime, segment) {\n  if (!segment.dateTimeObject) {\n    // Can't convert without an \"anchor point\" for the program time (i.e., a time that can\n    // be used to map the start of a segment with a real world time).\n    return null;\n  }\n\n  var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;\n  var transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart; // get the start of the content from before old content is prepended\n\n  var startOfSegment = transmuxedStart + transmuxerPrependedSeconds;\n  var offsetFromSegmentStart = playerTime - startOfSegment;\n  return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1000);\n};\n\nvar originalSegmentVideoDuration = function originalSegmentVideoDuration(videoTimingInfo) {\n  return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;\n};\n/**\n * Finds a segment that contains the time requested given as an ISO-8601 string. The\n * returned segment might be an estimate or an accurate match.\n *\n * @param {string} programTime The ISO-8601 programTime to find a match for\n * @param {Object} playlist A playlist object to search within\n */\n\n\nvar findSegmentForProgramTime = function findSegmentForProgramTime(programTime, playlist) {\n  // Assumptions:\n  //  - verifyProgramDateTimeTags has already been run\n  //  - live streams have been started\n  var dateTimeObject;\n\n  try {\n    dateTimeObject = new Date(programTime);\n  } catch (e) {\n    return null;\n  }\n\n  if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n    return null;\n  }\n\n  var segment = playlist.segments[0];\n\n  if (dateTimeObject < segment.dateTimeObject) {\n    // Requested time is before stream start.\n    return null;\n  }\n\n  for (var i = 0; i < playlist.segments.length - 1; i++) {\n    segment = playlist.segments[i];\n    var nextSegmentStart = playlist.segments[i + 1].dateTimeObject;\n\n    if (dateTimeObject < nextSegmentStart) {\n      break;\n    }\n  }\n\n  var lastSegment = playlist.segments[playlist.segments.length - 1];\n  var lastSegmentStart = lastSegment.dateTimeObject;\n  var lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;\n  var lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1000);\n\n  if (dateTimeObject > lastSegmentEnd) {\n    // Beyond the end of the stream, or our best guess of the end of the stream.\n    return null;\n  }\n\n  if (dateTimeObject > lastSegmentStart) {\n    segment = lastSegment;\n  }\n\n  return {\n    segment: segment,\n    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),\n    // Although, given that all segments have accurate date time objects, the segment\n    // selected should be accurate, unless the video has been transmuxed at some point\n    // (determined by the presence of the videoTimingInfo object), the segment's \"player\n    // time\" (the start time in the player) can't be considered accurate.\n    type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n  };\n};\n/**\n * Finds a segment that contains the given player time(in seconds).\n *\n * @param {number} time The player time to find a match for\n * @param {Object} playlist A playlist object to search within\n */\n\n\nvar findSegmentForPlayerTime = function findSegmentForPlayerTime(time, playlist) {\n  // Assumptions:\n  // - there will always be a segment.duration\n  // - we can start from zero\n  // - segments are in time order\n  if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n    return null;\n  }\n\n  var segmentEnd = 0;\n  var segment;\n\n  for (var i = 0; i < playlist.segments.length; i++) {\n    segment = playlist.segments[i]; // videoTimingInfo is set after the segment is downloaded and transmuxed, and\n    // should contain the most accurate values we have for the segment's player times.\n    //\n    // Use the accurate transmuxedPresentationEnd value if it is available, otherwise fall\n    // back to an estimate based on the manifest derived (inaccurate) segment.duration, to\n    // calculate an end value.\n\n    segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;\n\n    if (time <= segmentEnd) {\n      break;\n    }\n  }\n\n  var lastSegment = playlist.segments[playlist.segments.length - 1];\n\n  if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {\n    // The time requested is beyond the stream end.\n    return null;\n  }\n\n  if (time > segmentEnd) {\n    // The time is within or beyond the last segment.\n    //\n    // Check to see if the time is beyond a reasonable guess of the end of the stream.\n    if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {\n      // Technically, because the duration value is only an estimate, the time may still\n      // exist in the last segment, however, there isn't enough information to make even\n      // a reasonable estimate.\n      return null;\n    }\n\n    segment = lastSegment;\n  }\n\n  return {\n    segment: segment,\n    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,\n    // Because videoTimingInfo is only set after transmux, it is the only way to get\n    // accurate timing values.\n    type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n  };\n};\n/**\n * Gives the offset of the comparisonTimestamp from the programTime timestamp in seconds.\n * If the offset returned is positive, the programTime occurs after the\n * comparisonTimestamp.\n * If the offset is negative, the programTime occurs before the comparisonTimestamp.\n *\n * @param {string} comparisonTimeStamp An ISO-8601 timestamp to compare against\n * @param {string} programTime The programTime as an ISO-8601 string\n * @return {number} offset\n */\n\n\nvar getOffsetFromTimestamp = function getOffsetFromTimestamp(comparisonTimeStamp, programTime) {\n  var segmentDateTime;\n  var programDateTime;\n\n  try {\n    segmentDateTime = new Date(comparisonTimeStamp);\n    programDateTime = new Date(programTime);\n  } catch (e) {// TODO handle error\n  }\n\n  var segmentTimeEpoch = segmentDateTime.getTime();\n  var programTimeEpoch = programDateTime.getTime();\n  return (programTimeEpoch - segmentTimeEpoch) / 1000;\n};\n/**\n * Checks that all segments in this playlist have programDateTime tags.\n *\n * @param {Object} playlist A playlist object\n */\n\n\nvar verifyProgramDateTimeTags = function verifyProgramDateTimeTags(playlist) {\n  if (!playlist.segments || playlist.segments.length === 0) {\n    return false;\n  }\n\n  for (var i = 0; i < playlist.segments.length; i++) {\n    var segment = playlist.segments[i];\n\n    if (!segment.dateTimeObject) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns the programTime of the media given a playlist and a playerTime.\n * The playlist must have programDateTime tags for a programDateTime tag to be returned.\n * If the segments containing the time requested have not been buffered yet, an estimate\n * may be returned to the callback.\n *\n * @param {Object} args\n * @param {Object} args.playlist A playlist object to search within\n * @param {number} time A playerTime in seconds\n * @param {Function} callback(err, programTime)\n * @return {string} err.message A detailed error message\n * @return {Object} programTime\n * @return {number} programTime.mediaSeconds The streamTime in seconds\n * @return {string} programTime.programDateTime The programTime as an ISO-8601 String\n */\n\n\nvar getProgramTime = function getProgramTime(_ref) {\n  var playlist = _ref.playlist,\n      _ref$time = _ref.time,\n      time = _ref$time === void 0 ? undefined : _ref$time,\n      callback = _ref.callback;\n\n  if (!callback) {\n    throw new Error('getProgramTime: callback must be provided');\n  }\n\n  if (!playlist || time === undefined) {\n    return callback({\n      message: 'getProgramTime: playlist and time must be provided'\n    });\n  }\n\n  var matchedSegment = findSegmentForPlayerTime(time, playlist);\n\n  if (!matchedSegment) {\n    return callback({\n      message: 'valid programTime was not found'\n    });\n  }\n\n  if (matchedSegment.type === 'estimate') {\n    return callback({\n      message: 'Accurate programTime could not be determined.' + ' Please seek to e.seekTime and try again',\n      seekTime: matchedSegment.estimatedStart\n    });\n  }\n\n  var programTimeObject = {\n    mediaSeconds: time\n  };\n  var programTime = playerTimeToProgramTime(time, matchedSegment.segment);\n\n  if (programTime) {\n    programTimeObject.programDateTime = programTime.toISOString();\n  }\n\n  return callback(null, programTimeObject);\n};\n/**\n * Seeks in the player to a time that matches the given programTime ISO-8601 string.\n *\n * @param {Object} args\n * @param {string} args.programTime A programTime to seek to as an ISO-8601 String\n * @param {Object} args.playlist A playlist to look within\n * @param {number} args.retryCount The number of times to try for an accurate seek. Default is 2.\n * @param {Function} args.seekTo A method to perform a seek\n * @param {boolean} args.pauseAfterSeek Whether to end in a paused state after seeking. Default is true.\n * @param {Object} args.tech The tech to seek on\n * @param {Function} args.callback(err, newTime) A callback to return the new time to\n * @return {string} err.message A detailed error message\n * @return {number} newTime The exact time that was seeked to in seconds\n */\n\n\nvar seekToProgramTime = function seekToProgramTime(_ref2) {\n  var programTime = _ref2.programTime,\n      playlist = _ref2.playlist,\n      _ref2$retryCount = _ref2.retryCount,\n      retryCount = _ref2$retryCount === void 0 ? 2 : _ref2$retryCount,\n      seekTo = _ref2.seekTo,\n      _ref2$pauseAfterSeek = _ref2.pauseAfterSeek,\n      pauseAfterSeek = _ref2$pauseAfterSeek === void 0 ? true : _ref2$pauseAfterSeek,\n      tech = _ref2.tech,\n      callback = _ref2.callback;\n\n  if (!callback) {\n    throw new Error('seekToProgramTime: callback must be provided');\n  }\n\n  if (typeof programTime === 'undefined' || !playlist || !seekTo) {\n    return callback({\n      message: 'seekToProgramTime: programTime, seekTo and playlist must be provided'\n    });\n  }\n\n  if (!playlist.endList && !tech.hasStarted_) {\n    return callback({\n      message: 'player must be playing a live stream to start buffering'\n    });\n  }\n\n  if (!verifyProgramDateTimeTags(playlist)) {\n    return callback({\n      message: 'programDateTime tags must be provided in the manifest ' + playlist.resolvedUri\n    });\n  }\n\n  var matchedSegment = findSegmentForProgramTime(programTime, playlist); // no match\n\n  if (!matchedSegment) {\n    return callback({\n      message: programTime + \" was not found in the stream\"\n    });\n  }\n\n  var segment = matchedSegment.segment;\n  var mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);\n\n  if (matchedSegment.type === 'estimate') {\n    // we've run out of retries\n    if (retryCount === 0) {\n      return callback({\n        message: programTime + \" is not buffered yet. Try again\"\n      });\n    }\n\n    seekTo(matchedSegment.estimatedStart + mediaOffset);\n    tech.one('seeked', function () {\n      seekToProgramTime({\n        programTime: programTime,\n        playlist: playlist,\n        retryCount: retryCount - 1,\n        seekTo: seekTo,\n        pauseAfterSeek: pauseAfterSeek,\n        tech: tech,\n        callback: callback\n      });\n    });\n    return;\n  } // Since the segment.start value is determined from the buffered end or ending time\n  // of the prior segment, the seekToTime doesn't need to account for any transmuxer\n  // modifications.\n\n\n  var seekToTime = segment.start + mediaOffset;\n\n  var seekedCallback = function seekedCallback() {\n    return callback(null, tech.currentTime());\n  }; // listen for seeked event\n\n\n  tech.one('seeked', seekedCallback); // pause before seeking as video.js will restore this state\n\n  if (pauseAfterSeek) {\n    tech.pause();\n  }\n\n  seekTo(seekToTime);\n}; // which will only happen if the request is complete.\n\n\nvar callbackOnCompleted = function callbackOnCompleted(request, cb) {\n  if (request.readyState === 4) {\n    return cb();\n  }\n\n  return;\n};\n\nvar containerRequest = function containerRequest(uri, xhr, cb) {\n  var bytes = [];\n  var id3Offset;\n  var finished = false;\n\n  var endRequestAndCallback = function endRequestAndCallback(err, req, type, _bytes) {\n    req.abort();\n    finished = true;\n    return cb(err, req, type, _bytes);\n  };\n\n  var progressListener = function progressListener(error, request) {\n    if (finished) {\n      return;\n    }\n\n    if (error) {\n      return endRequestAndCallback(error, request, '', bytes);\n    } // grap the new part of content that was just downloaded\n\n\n    var newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length); // add that onto bytes\n\n    bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));\n    id3Offset = id3Offset || getId3Offset(bytes); // we need at least 10 bytes to determine a type\n    // or we need at least two bytes after an id3Offset\n\n    if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {\n      return callbackOnCompleted(request, function () {\n        return endRequestAndCallback(error, request, '', bytes);\n      });\n    }\n\n    var type = detectContainerForBytes(bytes); // if this looks like a ts segment but we don't have enough data\n    // to see the second sync byte, wait until we have enough data\n    // before declaring it ts\n\n    if (type === 'ts' && bytes.length < 188) {\n      return callbackOnCompleted(request, function () {\n        return endRequestAndCallback(error, request, '', bytes);\n      });\n    } // this may be an unsynced ts segment\n    // wait for 376 bytes before detecting no container\n\n\n    if (!type && bytes.length < 376) {\n      return callbackOnCompleted(request, function () {\n        return endRequestAndCallback(error, request, '', bytes);\n      });\n    }\n\n    return endRequestAndCallback(null, request, type, bytes);\n  };\n\n  var options = {\n    uri: uri,\n    beforeSend: function beforeSend(request) {\n      // this forces the browser to pass the bytes to us unprocessed\n      request.overrideMimeType('text/plain; charset=x-user-defined');\n      request.addEventListener('progress', function (_ref) {\n        var total = _ref.total,\n            loaded = _ref.loaded;\n        return callbackWrapper(request, null, {\n          statusCode: request.status\n        }, progressListener);\n      });\n    }\n  };\n  var request = xhr(options, function (error, response) {\n    return callbackWrapper(request, error, response, progressListener);\n  });\n  return request;\n};\n\nvar EventTarget$1$1 = videojs$1.EventTarget,\n    mergeOptions$2 = videojs$1.mergeOptions;\n/**\n * Parses the master XML string and updates playlist URI references.\n *\n * @param {Object} config\n *        Object of arguments\n * @param {string} config.masterXml\n *        The mpd XML\n * @param {string} config.srcUrl\n *        The mpd URL\n * @param {Date} config.clientOffset\n *         A time difference between server and client\n * @param {Object} config.sidxMapping\n *        SIDX mappings for moof/mdat URIs and byte ranges\n * @return {Object}\n *         The parsed mpd manifest object\n */\n\nvar parseMasterXml = function parseMasterXml(_ref) {\n  var masterXml = _ref.masterXml,\n      srcUrl = _ref.srcUrl,\n      clientOffset = _ref.clientOffset,\n      sidxMapping = _ref.sidxMapping;\n  var master = parse(masterXml, {\n    manifestUri: srcUrl,\n    clientOffset: clientOffset,\n    sidxMapping: sidxMapping\n  });\n  addPropertiesToMaster(master, srcUrl);\n  return master;\n};\n/**\n * Returns a new master manifest that is the result of merging an updated master manifest\n * into the original version.\n *\n * @param {Object} oldMaster\n *        The old parsed mpd object\n * @param {Object} newMaster\n *        The updated parsed mpd object\n * @return {Object}\n *         A new object representing the original master manifest with the updated media\n *         playlists merged in\n */\n\n\nvar updateMaster$1 = function updateMaster$1(oldMaster, newMaster) {\n  var noChanges = true;\n  var update = mergeOptions$2(oldMaster, {\n    // These are top level properties that can be updated\n    duration: newMaster.duration,\n    minimumUpdatePeriod: newMaster.minimumUpdatePeriod\n  }); // First update the playlists in playlist list\n\n  for (var i = 0; i < newMaster.playlists.length; i++) {\n    var playlistUpdate = updateMaster(update, newMaster.playlists[i]);\n\n    if (playlistUpdate) {\n      update = playlistUpdate;\n      noChanges = false;\n    }\n  } // Then update media group playlists\n\n\n  forEachMediaGroup(newMaster, function (properties, type, group, label) {\n    if (properties.playlists && properties.playlists.length) {\n      var id = properties.playlists[0].id;\n\n      var _playlistUpdate = updateMaster(update, properties.playlists[0]);\n\n      if (_playlistUpdate) {\n        update = _playlistUpdate; // update the playlist reference within media groups\n\n        update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];\n        noChanges = false;\n      }\n    }\n  });\n\n  if (newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {\n    noChanges = false;\n  }\n\n  if (noChanges) {\n    return null;\n  }\n\n  return update;\n};\n\nvar generateSidxKey = function generateSidxKey(sidxInfo) {\n  // should be non-inclusive\n  var sidxByteRangeEnd = sidxInfo.byterange.offset + sidxInfo.byterange.length - 1;\n  return sidxInfo.uri + '-' + sidxInfo.byterange.offset + '-' + sidxByteRangeEnd;\n}; // SIDX should be equivalent if the URI and byteranges of the SIDX match.\n// If the SIDXs have maps, the two maps should match,\n// both `a` and `b` missing SIDXs is considered matching.\n// If `a` or `b` but not both have a map, they aren't matching.\n\n\nvar equivalentSidx = function equivalentSidx(a, b) {\n  var neitherMap = Boolean(!a.map && !b.map);\n  var equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);\n  return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;\n}; // exported for testing\n\n\nvar compareSidxEntry = function compareSidxEntry(playlists, oldSidxMapping) {\n  var newSidxMapping = {};\n\n  for (var id in playlists) {\n    var playlist = playlists[id];\n    var currentSidxInfo = playlist.sidx;\n\n    if (currentSidxInfo) {\n      var key = generateSidxKey(currentSidxInfo);\n\n      if (!oldSidxMapping[key]) {\n        break;\n      }\n\n      var savedSidxInfo = oldSidxMapping[key].sidxInfo;\n\n      if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {\n        newSidxMapping[key] = oldSidxMapping[key];\n      }\n    }\n  }\n\n  return newSidxMapping;\n};\n/**\n *  A function that filters out changed items as they need to be requested separately.\n *\n *  The method is exported for testing\n *\n *  @param {Object} masterXml the mpd XML\n *  @param {string} srcUrl the mpd url\n *  @param {Date} clientOffset a time difference between server and client (passed through and not used)\n *  @param {Object} oldSidxMapping the SIDX to compare against\n */\n\n\nvar filterChangedSidxMappings = function filterChangedSidxMappings(masterXml, srcUrl, clientOffset, oldSidxMapping) {\n  // Don't pass current sidx mapping\n  var master = parse(masterXml, {\n    manifestUri: srcUrl,\n    clientOffset: clientOffset\n  });\n  var videoSidx = compareSidxEntry(master.playlists, oldSidxMapping);\n  var mediaGroupSidx = videoSidx;\n  forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {\n    if (properties.playlists && properties.playlists.length) {\n      var playlists = properties.playlists;\n      mediaGroupSidx = mergeOptions$2(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));\n    }\n  });\n  return mediaGroupSidx;\n}; // exported for testing\n\n\nvar requestSidx_ = function requestSidx_(loader, sidxRange, playlist, xhr, options, finishProcessingFn) {\n  var sidxInfo = {\n    // resolve the segment URL relative to the playlist\n    uri: resolveManifestRedirect(options.handleManifestRedirects, sidxRange.resolvedUri),\n    // resolvedUri: sidxRange.resolvedUri,\n    byterange: sidxRange.byterange,\n    // the segment's playlist\n    playlist: playlist\n  };\n  var sidxRequestOptions = videojs$1.mergeOptions(sidxInfo, {\n    responseType: 'arraybuffer',\n    headers: segmentXhrHeaders(sidxInfo)\n  });\n  return containerRequest(sidxInfo.uri, xhr, function (err, request, container, bytes) {\n    if (err) {\n      return finishProcessingFn(err, request);\n    }\n\n    if (!container || container !== 'mp4') {\n      return finishProcessingFn({\n        status: request.status,\n        message: \"Unsupported \" + (container || 'unknown') + \" container type for sidx segment at URL: \" + sidxInfo.uri,\n        // response is just bytes in this case\n        // but we really don't want to return that.\n        response: '',\n        playlist: playlist,\n        internal: true,\n        blacklistDuration: Infinity,\n        // MEDIA_ERR_NETWORK\n        code: 2\n      }, request);\n    } // if we already downloaded the sidx bytes in the container request, use them\n\n\n    var _sidxInfo$byterange = sidxInfo.byterange,\n        offset = _sidxInfo$byterange.offset,\n        length = _sidxInfo$byterange.length;\n\n    if (bytes.length >= length + offset) {\n      return finishProcessingFn(err, {\n        response: bytes.subarray(offset, offset + length),\n        status: request.status,\n        uri: request.uri\n      });\n    } // otherwise request sidx bytes\n\n\n    loader.request = xhr(sidxRequestOptions, finishProcessingFn);\n  });\n};\n\nvar DashPlaylistLoader = /*#__PURE__*/function (_EventTarget) {\n  _inheritsLoose(DashPlaylistLoader, _EventTarget); // DashPlaylistLoader must accept either a src url or a playlist because subsequent\n  // playlist loader setups from media groups will expect to be able to pass a playlist\n  // (since there aren't external URLs to media playlists with DASH)\n\n\n  function DashPlaylistLoader(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _EventTarget.call(this) || this;\n    var _options = options,\n        _options$withCredenti = _options.withCredentials,\n        withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti,\n        _options$handleManife = _options.handleManifestRedirects,\n        handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;\n    _this.vhs_ = vhs;\n    _this.withCredentials = withCredentials;\n    _this.handleManifestRedirects = handleManifestRedirects;\n\n    if (!srcUrlOrPlaylist) {\n      throw new Error('A non-empty playlist URL or object is required');\n    } // event naming?\n\n\n    _this.on('minimumUpdatePeriod', function () {\n      _this.refreshXml_();\n    }); // live playlist staleness timeout\n\n\n    _this.on('mediaupdatetimeout', function () {\n      _this.refreshMedia_(_this.media().id);\n    });\n\n    _this.state = 'HAVE_NOTHING';\n    _this.loadedPlaylists_ = {}; // initialize the loader state\n    // The masterPlaylistLoader will be created with a string\n\n    if (typeof srcUrlOrPlaylist === 'string') {\n      _this.srcUrl = srcUrlOrPlaylist; // TODO: reset sidxMapping between period changes\n      // once multi-period is refactored\n\n      _this.sidxMapping_ = {};\n      return _assertThisInitialized(_this);\n    }\n\n    _this.setupChildLoader(masterPlaylistLoader, srcUrlOrPlaylist);\n\n    return _this;\n  }\n\n  var _proto = DashPlaylistLoader.prototype;\n\n  _proto.setupChildLoader = function setupChildLoader(masterPlaylistLoader, playlist) {\n    this.masterPlaylistLoader_ = masterPlaylistLoader;\n    this.childPlaylist_ = playlist;\n  };\n\n  _proto.dispose = function dispose() {\n    this.trigger('dispose');\n    this.stopRequest();\n    this.loadedPlaylists_ = {};\n    window$1.clearTimeout(this.minimumUpdatePeriodTimeout_);\n    window$1.clearTimeout(this.mediaRequest_);\n    window$1.clearTimeout(this.mediaUpdateTimeout);\n    this.off();\n  };\n\n  _proto.hasPendingRequest = function hasPendingRequest() {\n    return this.request || this.mediaRequest_;\n  };\n\n  _proto.stopRequest = function stopRequest() {\n    if (this.request) {\n      var oldRequest = this.request;\n      this.request = null;\n      oldRequest.onreadystatechange = null;\n      oldRequest.abort();\n    }\n  };\n\n  _proto.sidxRequestFinished_ = function sidxRequestFinished_(playlist, master, startingState, doneFn) {\n    var _this2 = this;\n\n    return function (err, request) {\n      // disposed\n      if (!_this2.request) {\n        return;\n      } // pending request is cleared\n\n\n      _this2.request = null;\n\n      if (err) {\n        // use the provided error or create one\n        // see requestSidx_ for the container request\n        // that can cause this.\n        _this2.error = typeof err === 'object' ? err : {\n          status: request.status,\n          message: 'DASH playlist request error at URL: ' + playlist.uri,\n          response: request.response,\n          // MEDIA_ERR_NETWORK\n          code: 2\n        };\n\n        if (startingState) {\n          _this2.state = startingState;\n        }\n\n        _this2.trigger('error');\n\n        return;\n      }\n\n      var bytes = toUint8(request.response);\n      var sidx = parseSidx(bytes.subarray(8));\n      return doneFn(master, sidx);\n    };\n  };\n\n  _proto.media = function media(playlist) {\n    var _this3 = this; // getter\n\n\n    if (!playlist) {\n      return this.media_;\n    } // setter\n\n\n    if (this.state === 'HAVE_NOTHING') {\n      throw new Error('Cannot switch media playlist from ' + this.state);\n    }\n\n    var startingState = this.state; // find the playlist object if the target playlist has been specified by URI\n\n    if (typeof playlist === 'string') {\n      if (!this.master.playlists[playlist]) {\n        throw new Error('Unknown playlist URI: ' + playlist);\n      }\n\n      playlist = this.master.playlists[playlist];\n    }\n\n    var mediaChange = !this.media_ || playlist.id !== this.media_.id; // switch to previously loaded playlists immediately\n\n    if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {\n      this.state = 'HAVE_METADATA';\n      this.media_ = playlist; // trigger media change if the active media has been updated\n\n      if (mediaChange) {\n        this.trigger('mediachanging');\n        this.trigger('mediachange');\n      }\n\n      return;\n    } // switching to the active playlist is a no-op\n\n\n    if (!mediaChange) {\n      return;\n    } // switching from an already loaded playlist\n\n\n    if (this.media_) {\n      this.trigger('mediachanging');\n    }\n\n    if (!playlist.sidx) {\n      // Continue asynchronously if there is no sidx\n      // wait one tick to allow haveMaster to run first on a child loader\n      this.mediaRequest_ = window$1.setTimeout(this.haveMetadata.bind(this, {\n        startingState: startingState,\n        playlist: playlist\n      }), 0); // exit early and don't do sidx work\n\n      return;\n    } // we have sidx mappings\n\n\n    var oldMaster;\n    var sidxMapping; // sidxMapping is used when parsing the masterXml, so store\n    // it on the masterPlaylistLoader\n\n    if (this.masterPlaylistLoader_) {\n      oldMaster = this.masterPlaylistLoader_.master;\n      sidxMapping = this.masterPlaylistLoader_.sidxMapping_;\n    } else {\n      oldMaster = this.master;\n      sidxMapping = this.sidxMapping_;\n    }\n\n    var sidxKey = generateSidxKey(playlist.sidx);\n    sidxMapping[sidxKey] = {\n      sidxInfo: playlist.sidx\n    };\n    this.request = requestSidx_(this, playlist.sidx, playlist, this.vhs_.xhr, {\n      handleManifestRedirects: this.handleManifestRedirects\n    }, this.sidxRequestFinished_(playlist, oldMaster, startingState, function (newMaster, sidx) {\n      if (!newMaster || !sidx) {\n        throw new Error('failed to request sidx');\n      } // update loader's sidxMapping with parsed sidx box\n\n\n      sidxMapping[sidxKey].sidx = sidx; // everything is ready just continue to haveMetadata\n\n      _this3.haveMetadata({\n        startingState: startingState,\n        playlist: newMaster.playlists[playlist.id]\n      });\n    }));\n  };\n\n  _proto.haveMetadata = function haveMetadata(_ref2) {\n    var startingState = _ref2.startingState,\n        playlist = _ref2.playlist;\n    this.state = 'HAVE_METADATA';\n    this.loadedPlaylists_[playlist.id] = playlist;\n    this.mediaRequest_ = null; // This will trigger loadedplaylist\n\n    this.refreshMedia_(playlist.id); // fire loadedmetadata the first time a media playlist is loaded\n    // to resolve setup of media groups\n\n    if (startingState === 'HAVE_MASTER') {\n      this.trigger('loadedmetadata');\n    } else {\n      // trigger media change if the active media has been updated\n      this.trigger('mediachange');\n    }\n  };\n\n  _proto.pause = function pause() {\n    this.stopRequest();\n    window$1.clearTimeout(this.mediaUpdateTimeout);\n    window$1.clearTimeout(this.minimumUpdatePeriodTimeout_);\n\n    if (this.state === 'HAVE_NOTHING') {\n      // If we pause the loader before any data has been retrieved, its as if we never\n      // started, so reset to an unstarted state.\n      this.started = false;\n    }\n  };\n\n  _proto.load = function load(isFinalRendition) {\n    var _this4 = this;\n\n    window$1.clearTimeout(this.mediaUpdateTimeout);\n    window$1.clearTimeout(this.minimumUpdatePeriodTimeout_);\n    var media = this.media();\n\n    if (isFinalRendition) {\n      var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n      this.mediaUpdateTimeout = window$1.setTimeout(function () {\n        return _this4.load();\n      }, delay);\n      return;\n    } // because the playlists are internal to the manifest, load should either load the\n    // main manifest, or do nothing but trigger an event\n\n\n    if (!this.started) {\n      this.start();\n      return;\n    }\n\n    if (media && !media.endList) {\n      this.trigger('mediaupdatetimeout');\n    } else {\n      this.trigger('loadedplaylist');\n    }\n  };\n\n  _proto.start = function start() {\n    var _this5 = this;\n\n    this.started = true; // We don't need to request the master manifest again\n    // Call this asynchronously to match the xhr request behavior below\n\n    if (this.masterPlaylistLoader_) {\n      this.mediaRequest_ = window$1.setTimeout(this.haveMaster_.bind(this), 0);\n      return;\n    } // request the specified URL\n\n\n    this.request = this.vhs_.xhr({\n      uri: this.srcUrl,\n      withCredentials: this.withCredentials\n    }, function (error, req) {\n      // disposed\n      if (!_this5.request) {\n        return;\n      } // clear the loader's request reference\n\n\n      _this5.request = null;\n\n      if (error) {\n        _this5.error = {\n          status: req.status,\n          message: 'DASH playlist request error at URL: ' + _this5.srcUrl,\n          responseText: req.responseText,\n          // MEDIA_ERR_NETWORK\n          code: 2\n        };\n\n        if (_this5.state === 'HAVE_NOTHING') {\n          _this5.started = false;\n        }\n\n        return _this5.trigger('error');\n      }\n\n      _this5.masterXml_ = req.responseText;\n\n      if (req.responseHeaders && req.responseHeaders.date) {\n        _this5.masterLoaded_ = Date.parse(req.responseHeaders.date);\n      } else {\n        _this5.masterLoaded_ = Date.now();\n      }\n\n      _this5.srcUrl = resolveManifestRedirect(_this5.handleManifestRedirects, _this5.srcUrl, req);\n\n      _this5.syncClientServerClock_(_this5.onClientServerClockSync_.bind(_this5));\n    });\n  }\n  /**\n   * Parses the master xml for UTCTiming node to sync the client clock to the server\n   * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.\n   *\n   * @param {Function} done\n   *        Function to call when clock sync has completed\n   */\n  ;\n\n  _proto.syncClientServerClock_ = function syncClientServerClock_(done) {\n    var _this6 = this;\n\n    var utcTiming = parseUTCTiming(this.masterXml_); // No UTCTiming element found in the mpd. Use Date header from mpd request as the\n    // server clock\n\n    if (utcTiming === null) {\n      this.clientOffset_ = this.masterLoaded_ - Date.now();\n      return done();\n    }\n\n    if (utcTiming.method === 'DIRECT') {\n      this.clientOffset_ = utcTiming.value - Date.now();\n      return done();\n    }\n\n    this.request = this.vhs_.xhr({\n      uri: resolveUrl(this.srcUrl, utcTiming.value),\n      method: utcTiming.method,\n      withCredentials: this.withCredentials\n    }, function (error, req) {\n      // disposed\n      if (!_this6.request) {\n        return;\n      }\n\n      if (error) {\n        // sync request failed, fall back to using date header from mpd\n        // TODO: log warning\n        _this6.clientOffset_ = _this6.masterLoaded_ - Date.now();\n        return done();\n      }\n\n      var serverTime;\n\n      if (utcTiming.method === 'HEAD') {\n        if (!req.responseHeaders || !req.responseHeaders.date) {\n          // expected date header not preset, fall back to using date header from mpd\n          // TODO: log warning\n          serverTime = _this6.masterLoaded_;\n        } else {\n          serverTime = Date.parse(req.responseHeaders.date);\n        }\n      } else {\n        serverTime = Date.parse(req.responseText);\n      }\n\n      _this6.clientOffset_ = serverTime - Date.now();\n      done();\n    });\n  };\n\n  _proto.haveMaster_ = function haveMaster_() {\n    this.state = 'HAVE_MASTER'; // clear media request\n\n    this.mediaRequest_ = null;\n\n    if (!this.masterPlaylistLoader_) {\n      this.updateMainManifest_(parseMasterXml({\n        masterXml: this.masterXml_,\n        srcUrl: this.srcUrl,\n        clientOffset: this.clientOffset_,\n        sidxMapping: this.sidxMapping_\n      })); // We have the master playlist at this point, so\n      // trigger this to allow MasterPlaylistController\n      // to make an initial playlist selection\n\n      this.trigger('loadedplaylist');\n    } else if (!this.media_) {\n      // no media playlist was specifically selected so select\n      // the one the child playlist loader was created with\n      this.media(this.childPlaylist_);\n    }\n  };\n\n  _proto.updateMinimumUpdatePeriodTimeout_ = function updateMinimumUpdatePeriodTimeout_() {\n    var _this7 = this; // Clear existing timeout\n\n\n    window$1.clearTimeout(this.minimumUpdatePeriodTimeout_);\n\n    var createMUPTimeout = function createMUPTimeout(mup) {\n      _this7.minimumUpdatePeriodTimeout_ = window$1.setTimeout(function () {\n        _this7.trigger('minimumUpdatePeriod');\n      }, mup);\n    };\n\n    var minimumUpdatePeriod = this.master && this.master.minimumUpdatePeriod;\n\n    if (minimumUpdatePeriod > 0) {\n      createMUPTimeout(minimumUpdatePeriod); // If the minimumUpdatePeriod has a value of 0, that indicates that the current\n      // MPD has no future validity, so a new one will need to be acquired when new\n      // media segments are to be made available. Thus, we use the target duration\n      // in this case\n    } else if (minimumUpdatePeriod === 0) {\n      // If we haven't yet selected a playlist, wait until then so we know the\n      // target duration\n      if (!this.media()) {\n        this.one('loadedplaylist', function () {\n          createMUPTimeout(_this7.media().targetDuration * 1000);\n        });\n      } else {\n        createMUPTimeout(this.media().targetDuration * 1000);\n      }\n    }\n  }\n  /**\n   * Handler for after client/server clock synchronization has happened. Sets up\n   * xml refresh timer if specificed by the manifest.\n   */\n  ;\n\n  _proto.onClientServerClockSync_ = function onClientServerClockSync_() {\n    this.haveMaster_();\n\n    if (!this.hasPendingRequest() && !this.media_) {\n      this.media(this.master.playlists[0]);\n    }\n\n    this.updateMinimumUpdatePeriodTimeout_();\n  }\n  /**\n   * Given a new manifest, update our pointer to it and update the srcUrl based on the location elements of the manifest, if they exist.\n   *\n   * @param {Object} updatedManifest the manifest to update to\n   */\n  ;\n\n  _proto.updateMainManifest_ = function updateMainManifest_(updatedManifest) {\n    this.master = updatedManifest; // if locations isn't set or is an empty array, exit early\n\n    if (!this.master.locations || !this.master.locations.length) {\n      return;\n    }\n\n    var location = this.master.locations[0];\n\n    if (location !== this.srcUrl) {\n      this.srcUrl = location;\n    }\n  }\n  /**\n   * Sends request to refresh the master xml and updates the parsed master manifest\n   * TODO: Does the client offset need to be recalculated when the xml is refreshed?\n   */\n  ;\n\n  _proto.refreshXml_ = function refreshXml_() {\n    var _this8 = this; // The srcUrl here *may* need to pass through handleManifestsRedirects when\n    // sidx is implemented\n\n\n    this.request = this.vhs_.xhr({\n      uri: this.srcUrl,\n      withCredentials: this.withCredentials\n    }, function (error, req) {\n      // disposed\n      if (!_this8.request) {\n        return;\n      } // clear the loader's request reference\n\n\n      _this8.request = null;\n\n      if (error) {\n        _this8.error = {\n          status: req.status,\n          message: 'DASH playlist request error at URL: ' + _this8.srcUrl,\n          responseText: req.responseText,\n          // MEDIA_ERR_NETWORK\n          code: 2\n        };\n\n        if (_this8.state === 'HAVE_NOTHING') {\n          _this8.started = false;\n        }\n\n        return _this8.trigger('error');\n      }\n\n      _this8.masterXml_ = req.responseText; // This will filter out updated sidx info from the mapping\n\n      _this8.sidxMapping_ = filterChangedSidxMappings(_this8.masterXml_, _this8.srcUrl, _this8.clientOffset_, _this8.sidxMapping_);\n      var master = parseMasterXml({\n        masterXml: _this8.masterXml_,\n        srcUrl: _this8.srcUrl,\n        clientOffset: _this8.clientOffset_,\n        sidxMapping: _this8.sidxMapping_\n      });\n      var updatedMaster = updateMaster$1(_this8.master, master);\n\n      var currentSidxInfo = _this8.media().sidx;\n\n      if (updatedMaster) {\n        if (currentSidxInfo) {\n          var sidxKey = generateSidxKey(currentSidxInfo); // the sidx was updated, so the previous mapping was removed\n\n          if (!_this8.sidxMapping_[sidxKey]) {\n            var playlist = _this8.media();\n\n            _this8.request = requestSidx_(_this8, playlist.sidx, playlist, _this8.vhs_.xhr, {\n              handleManifestRedirects: _this8.handleManifestRedirects\n            }, _this8.sidxRequestFinished_(playlist, master, _this8.state, function (newMaster, sidx) {\n              if (!newMaster || !sidx) {\n                throw new Error('failed to request sidx on minimumUpdatePeriod');\n              } // update loader's sidxMapping with parsed sidx box\n\n\n              _this8.sidxMapping_[sidxKey].sidx = sidx;\n\n              _this8.updateMinimumUpdatePeriodTimeout_(); // TODO: do we need to reload the current playlist?\n\n\n              _this8.refreshMedia_(_this8.media().id);\n\n              return;\n            }));\n          }\n        } else {\n          _this8.updateMainManifest_(updatedMaster);\n\n          if (_this8.media_) {\n            _this8.media_ = _this8.master.playlists[_this8.media_.id];\n          }\n        }\n      }\n\n      _this8.updateMinimumUpdatePeriodTimeout_();\n    });\n  }\n  /**\n   * Refreshes the media playlist by re-parsing the master xml and updating playlist\n   * references. If this is an alternate loader, the updated parsed manifest is retrieved\n   * from the master loader.\n   */\n  ;\n\n  _proto.refreshMedia_ = function refreshMedia_(mediaID) {\n    var _this9 = this;\n\n    if (!mediaID) {\n      throw new Error('refreshMedia_ must take a media id');\n    }\n\n    var oldMaster;\n    var newMaster;\n\n    if (this.masterPlaylistLoader_) {\n      oldMaster = this.masterPlaylistLoader_.master;\n      newMaster = parseMasterXml({\n        masterXml: this.masterPlaylistLoader_.masterXml_,\n        srcUrl: this.masterPlaylistLoader_.srcUrl,\n        clientOffset: this.masterPlaylistLoader_.clientOffset_,\n        sidxMapping: this.masterPlaylistLoader_.sidxMapping_\n      });\n    } else {\n      oldMaster = this.master;\n      newMaster = parseMasterXml({\n        masterXml: this.masterXml_,\n        srcUrl: this.srcUrl,\n        clientOffset: this.clientOffset_,\n        sidxMapping: this.sidxMapping_\n      });\n    }\n\n    var updatedMaster = updateMaster$1(oldMaster, newMaster);\n\n    if (updatedMaster) {\n      if (this.masterPlaylistLoader_) {\n        this.masterPlaylistLoader_.master = updatedMaster;\n      } else {\n        this.master = updatedMaster;\n      }\n\n      this.media_ = updatedMaster.playlists[mediaID];\n    } else {\n      this.media_ = oldMaster.playlists[mediaID];\n      this.trigger('playlistunchanged');\n    }\n\n    if (!this.media().endList) {\n      this.mediaUpdateTimeout = window$1.setTimeout(function () {\n        _this9.trigger('mediaupdatetimeout');\n      }, refreshDelay(this.media(), !!updatedMaster));\n    }\n\n    this.trigger('loadedplaylist');\n  };\n\n  return DashPlaylistLoader;\n}(EventTarget$1$1);\n\nvar Config = {\n  GOAL_BUFFER_LENGTH: 30,\n  MAX_GOAL_BUFFER_LENGTH: 60,\n  BACK_BUFFER_LENGTH: 30,\n  GOAL_BUFFER_LENGTH_RATE: 1,\n  // 0.5 MB/s\n  INITIAL_BANDWIDTH: 4194304,\n  // A fudge factor to apply to advertised playlist bitrates to account for\n  // temporary flucations in client bandwidth\n  BANDWIDTH_VARIANCE: 1.2,\n  // How much of the buffer must be filled before we consider upswitching\n  BUFFER_LOW_WATER_LINE: 0,\n  MAX_BUFFER_LOW_WATER_LINE: 30,\n  BUFFER_LOW_WATER_LINE_RATE: 1\n};\n\nvar stringToArrayBuffer = function stringToArrayBuffer(string) {\n  var view = new Uint8Array(new ArrayBuffer(string.length));\n\n  for (var i = 0; i < string.length; i++) {\n    view[i] = string.charCodeAt(i);\n  }\n\n  return view.buffer;\n};\n\nvar transmuxQueue = [];\nvar currentTransmux;\n\nvar handleData_ = function handleData_(event, transmuxedData, callback) {\n  var _event$data$segment = event.data.segment,\n      type = _event$data$segment.type,\n      initSegment = _event$data$segment.initSegment,\n      captions = _event$data$segment.captions,\n      captionStreams = _event$data$segment.captionStreams,\n      metadata = _event$data$segment.metadata,\n      videoFrameDtsTime = _event$data$segment.videoFrameDtsTime,\n      videoFramePtsTime = _event$data$segment.videoFramePtsTime;\n  transmuxedData.buffer.push({\n    captions: captions,\n    captionStreams: captionStreams,\n    metadata: metadata\n  }); // right now, boxes will come back from partial transmuxer, data from full\n\n  var boxes = event.data.segment.boxes || {\n    data: event.data.segment.data\n  };\n  var result = {\n    type: type,\n    // cast ArrayBuffer to TypedArray\n    data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),\n    initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)\n  };\n\n  if (typeof videoFrameDtsTime !== 'undefined') {\n    result.videoFrameDtsTime = videoFrameDtsTime;\n  }\n\n  if (typeof videoFramePtsTime !== 'undefined') {\n    result.videoFramePtsTime = videoFramePtsTime;\n  }\n\n  callback(result);\n};\n\nvar handleDone_ = function handleDone_(_ref) {\n  var transmuxedData = _ref.transmuxedData,\n      callback = _ref.callback; // Previously we only returned data on data events,\n  // not on done events. Clear out the buffer to keep that consistent.\n\n  transmuxedData.buffer = []; // all buffers should have been flushed from the muxer, so start processing anything we\n  // have received\n\n  callback(transmuxedData);\n};\n\nvar handleGopInfo_ = function handleGopInfo_(event, transmuxedData) {\n  transmuxedData.gopInfo = event.data.gopInfo;\n};\n\nvar processTransmux = function processTransmux(_ref2) {\n  var transmuxer = _ref2.transmuxer,\n      bytes = _ref2.bytes,\n      audioAppendStart = _ref2.audioAppendStart,\n      gopsToAlignWith = _ref2.gopsToAlignWith,\n      isPartial = _ref2.isPartial,\n      remux = _ref2.remux,\n      onData = _ref2.onData,\n      onTrackInfo = _ref2.onTrackInfo,\n      onAudioTimingInfo = _ref2.onAudioTimingInfo,\n      onVideoTimingInfo = _ref2.onVideoTimingInfo,\n      onVideoSegmentTimingInfo = _ref2.onVideoSegmentTimingInfo,\n      onId3 = _ref2.onId3,\n      onCaptions = _ref2.onCaptions,\n      onDone = _ref2.onDone;\n  var transmuxedData = {\n    isPartial: isPartial,\n    buffer: []\n  };\n\n  var handleMessage = function handleMessage(event) {\n    if (!currentTransmux) {\n      // disposed\n      return;\n    }\n\n    if (event.data.action === 'data') {\n      handleData_(event, transmuxedData, onData);\n    }\n\n    if (event.data.action === 'trackinfo') {\n      onTrackInfo(event.data.trackInfo);\n    }\n\n    if (event.data.action === 'gopInfo') {\n      handleGopInfo_(event, transmuxedData);\n    }\n\n    if (event.data.action === 'audioTimingInfo') {\n      onAudioTimingInfo(event.data.audioTimingInfo);\n    }\n\n    if (event.data.action === 'videoTimingInfo') {\n      onVideoTimingInfo(event.data.videoTimingInfo);\n    }\n\n    if (event.data.action === 'videoSegmentTimingInfo') {\n      onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);\n    }\n\n    if (event.data.action === 'id3Frame') {\n      onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);\n    }\n\n    if (event.data.action === 'caption') {\n      onCaptions(event.data.caption);\n    } // wait for the transmuxed event since we may have audio and video\n\n\n    if (event.data.type !== 'transmuxed') {\n      return;\n    }\n\n    transmuxer.onmessage = null;\n    handleDone_({\n      transmuxedData: transmuxedData,\n      callback: onDone\n    });\n    /* eslint-disable no-use-before-define */\n\n    dequeue();\n    /* eslint-enable */\n  };\n\n  transmuxer.onmessage = handleMessage;\n\n  if (audioAppendStart) {\n    transmuxer.postMessage({\n      action: 'setAudioAppendStart',\n      appendStart: audioAppendStart\n    });\n  } // allow empty arrays to be passed to clear out GOPs\n\n\n  if (Array.isArray(gopsToAlignWith)) {\n    transmuxer.postMessage({\n      action: 'alignGopsWith',\n      gopsToAlignWith: gopsToAlignWith\n    });\n  }\n\n  if (typeof remux !== 'undefined') {\n    transmuxer.postMessage({\n      action: 'setRemux',\n      remux: remux\n    });\n  }\n\n  if (bytes.byteLength) {\n    var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;\n    var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;\n    transmuxer.postMessage({\n      action: 'push',\n      // Send the typed-array of data as an ArrayBuffer so that\n      // it can be sent as a \"Transferable\" and avoid the costly\n      // memory copy\n      data: buffer,\n      // To recreate the original typed-array, we need information\n      // about what portion of the ArrayBuffer it was a view into\n      byteOffset: byteOffset,\n      byteLength: bytes.byteLength\n    }, [buffer]);\n  } // even if we didn't push any bytes, we have to make sure we flush in case we reached\n  // the end of the segment\n\n\n  transmuxer.postMessage({\n    action: isPartial ? 'partialFlush' : 'flush'\n  });\n};\n\nvar dequeue = function dequeue() {\n  currentTransmux = null;\n\n  if (transmuxQueue.length) {\n    currentTransmux = transmuxQueue.shift();\n\n    if (typeof currentTransmux === 'function') {\n      currentTransmux();\n    } else {\n      processTransmux(currentTransmux);\n    }\n  }\n};\n\nvar processAction = function processAction(transmuxer, action) {\n  transmuxer.postMessage({\n    action: action\n  });\n  dequeue();\n};\n\nvar enqueueAction = function enqueueAction(action, transmuxer) {\n  if (!currentTransmux) {\n    currentTransmux = action;\n    processAction(transmuxer, action);\n    return;\n  }\n\n  transmuxQueue.push(processAction.bind(null, transmuxer, action));\n};\n\nvar reset = function reset(transmuxer) {\n  enqueueAction('reset', transmuxer);\n};\n\nvar endTimeline = function endTimeline(transmuxer) {\n  enqueueAction('endTimeline', transmuxer);\n};\n\nvar transmux = function transmux(options) {\n  if (!currentTransmux) {\n    currentTransmux = options;\n    processTransmux(options);\n    return;\n  }\n\n  transmuxQueue.push(options);\n};\n\nvar dispose = function dispose() {\n  // clear out module-level references\n  currentTransmux = null;\n  transmuxQueue.length = 0;\n};\n\nvar segmentTransmuxer = {\n  reset: reset,\n  dispose: dispose,\n  endTimeline: endTimeline,\n  transmux: transmux\n};\n/**\n * Probe an mpeg2-ts segment to determine the start time of the segment in it's\n * internal \"media time,\" as well as whether it contains video and/or audio.\n *\n * @private\n * @param {Uint8Array} bytes - segment bytes\n * @return {Object} The start time of the current segment in \"media time\" as well as\n *                  whether it contains video and/or audio\n */\n\nvar probeTsSegment = function probeTsSegment(bytes, baseStartTime) {\n  var timeInfo = tsInspector.inspect(bytes, baseStartTime * ONE_SECOND_IN_TS);\n\n  if (!timeInfo) {\n    return null;\n  }\n\n  var result = {\n    // each type's time info comes back as an array of 2 times, start and end\n    hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,\n    hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false\n  };\n\n  if (result.hasVideo) {\n    result.videoStart = timeInfo.video[0].ptsTime;\n  }\n\n  if (result.hasAudio) {\n    result.audioStart = timeInfo.audio[0].ptsTime;\n  }\n\n  return result;\n};\n/**\n * Combine all segments into a single Uint8Array\n *\n * @param {Object} segmentObj\n * @return {Uint8Array} concatenated bytes\n * @private\n */\n\n\nvar concatSegments = function concatSegments(segmentObj) {\n  var offset = 0;\n  var tempBuffer;\n\n  if (segmentObj.bytes) {\n    tempBuffer = new Uint8Array(segmentObj.bytes); // combine the individual segments into one large typed-array\n\n    segmentObj.segments.forEach(function (segment) {\n      tempBuffer.set(segment, offset);\n      offset += segment.byteLength;\n    });\n  }\n\n  return tempBuffer;\n};\n\nvar REQUEST_ERRORS = {\n  FAILURE: 2,\n  TIMEOUT: -101,\n  ABORTED: -102\n};\n/**\n * Abort all requests\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n */\n\nvar abortAll = function abortAll(activeXhrs) {\n  activeXhrs.forEach(function (xhr) {\n    xhr.abort();\n  });\n};\n/**\n * Gather important bandwidth stats once a request has completed\n *\n * @param {Object} request - the XHR request from which to gather stats\n */\n\n\nvar getRequestStats = function getRequestStats(request) {\n  return {\n    bandwidth: request.bandwidth,\n    bytesReceived: request.bytesReceived || 0,\n    roundTripTime: request.roundTripTime || 0\n  };\n};\n/**\n * If possible gather bandwidth stats as a request is in\n * progress\n *\n * @param {Event} progressEvent - an event object from an XHR's progress event\n */\n\n\nvar getProgressStats = function getProgressStats(progressEvent) {\n  var request = progressEvent.target;\n  var roundTripTime = Date.now() - request.requestTime;\n  var stats = {\n    bandwidth: Infinity,\n    bytesReceived: 0,\n    roundTripTime: roundTripTime || 0\n  };\n  stats.bytesReceived = progressEvent.loaded; // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n  // because we should only use bandwidth stats on progress to determine when\n  // abort a request early due to insufficient bandwidth\n\n  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n  return stats;\n};\n/**\n * Handle all error conditions in one place and return an object\n * with all the information\n *\n * @param {Error|null} error - if non-null signals an error occured with the XHR\n * @param {Object} request -  the XHR request that possibly generated the error\n */\n\n\nvar handleErrors = function handleErrors(error, request) {\n  if (request.timedout) {\n    return {\n      status: request.status,\n      message: 'HLS request timed-out at URL: ' + request.uri,\n      code: REQUEST_ERRORS.TIMEOUT,\n      xhr: request\n    };\n  }\n\n  if (request.aborted) {\n    return {\n      status: request.status,\n      message: 'HLS request aborted at URL: ' + request.uri,\n      code: REQUEST_ERRORS.ABORTED,\n      xhr: request\n    };\n  }\n\n  if (error) {\n    return {\n      status: request.status,\n      message: 'HLS request errored at URL: ' + request.uri,\n      code: REQUEST_ERRORS.FAILURE,\n      xhr: request\n    };\n  }\n\n  return null;\n};\n/**\n * Handle responses for key data and convert the key data to the correct format\n * for the decryption step later\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\n\n\nvar handleKeyResponse = function handleKeyResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    if (response.byteLength !== 16) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Invalid HLS key at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    var view = new DataView(response);\n    segment.key.bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n    return finishProcessingFn(null, segment);\n  };\n};\n/**\n * Handle init-segment responses\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\n\n\nvar handleInitSegmentResponse = function handleInitSegmentResponse(_ref) {\n  var segment = _ref.segment,\n      finishProcessingFn = _ref.finishProcessingFn;\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    } // stop processing if received empty content\n\n\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.map.bytes = new Uint8Array(request.response);\n    var type = detectContainerForBytes(segment.map.bytes); // TODO: We should also handle ts init segments here, but we\n    // only know how to parse mp4 init segments at the moment\n\n    if (type !== 'mp4') {\n      return finishProcessingFn({\n        status: request.status,\n        message: \"Found unsupported \" + (type || 'unknown') + \" container for initialization segment at URL: \" + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        internal: true,\n        xhr: request\n      }, segment);\n    }\n\n    var tracks = mp4probe.tracks(segment.map.bytes);\n    tracks.forEach(function (track) {\n      segment.map.tracks = segment.map.tracks || {}; // only support one track of each type for now\n\n      if (segment.map.tracks[track.type]) {\n        return;\n      }\n\n      segment.map.tracks[track.type] = track;\n\n      if (track.id && track.timescale) {\n        segment.map.timescales = segment.map.timescales || {};\n        segment.map.timescales[track.id] = track.timescale;\n      }\n    });\n    return finishProcessingFn(null, segment);\n  };\n};\n/**\n * Response handler for segment-requests being sure to set the correct\n * property depending on whether the segment is encryped or not\n * Also records and keeps track of stats that are used for ABR purposes\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\n\n\nvar handleSegmentResponse = function handleSegmentResponse(_ref2) {\n  var segment = _ref2.segment,\n      finishProcessingFn = _ref2.finishProcessingFn,\n      responseType = _ref2.responseType;\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    var newBytes = // although responseText \"should\" exist, this guard serves to prevent an error being\n    // thrown for two primary cases:\n    // 1. the mime type override stops working, or is not implemented for a specific\n    //    browser\n    // 2. when using mock XHR libraries like sinon that do not allow the override behavior\n    responseType === 'arraybuffer' || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0)); // stop processing if received empty content\n\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.stats = getRequestStats(request);\n\n    if (segment.key) {\n      segment.encryptedBytes = new Uint8Array(newBytes);\n    } else {\n      segment.bytes = new Uint8Array(newBytes);\n    }\n\n    return finishProcessingFn(null, segment);\n  };\n};\n\nvar transmuxAndNotify = function transmuxAndNotify(_ref3) {\n  var segment = _ref3.segment,\n      bytes = _ref3.bytes,\n      isPartial = _ref3.isPartial,\n      trackInfoFn = _ref3.trackInfoFn,\n      timingInfoFn = _ref3.timingInfoFn,\n      videoSegmentTimingInfoFn = _ref3.videoSegmentTimingInfoFn,\n      id3Fn = _ref3.id3Fn,\n      captionsFn = _ref3.captionsFn,\n      dataFn = _ref3.dataFn,\n      doneFn = _ref3.doneFn;\n  var fmp4Tracks = segment.map && segment.map.tracks || {};\n  var isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video); // Keep references to each function so we can null them out after we're done with them.\n  // One reason for this is that in the case of full segments, we want to trust start\n  // times from the probe, rather than the transmuxer.\n\n  var audioStartFn = timingInfoFn.bind(null, segment, 'audio', 'start');\n  var audioEndFn = timingInfoFn.bind(null, segment, 'audio', 'end');\n  var videoStartFn = timingInfoFn.bind(null, segment, 'video', 'start');\n  var videoEndFn = timingInfoFn.bind(null, segment, 'video', 'end'); // Check to see if we are appending a full segment.\n\n  if (!isPartial && !segment.lastReachedChar) {\n    // In the full segment transmuxer, we don't yet have the ability to extract a \"proper\"\n    // start time. Meaning cached frame data may corrupt our notion of where this segment\n    // really starts. To get around this, full segment appends should probe for the info\n    // needed.\n    var probeResult = probeTsSegment(bytes, segment.baseStartTime);\n\n    if (probeResult) {\n      trackInfoFn(segment, {\n        hasAudio: probeResult.hasAudio,\n        hasVideo: probeResult.hasVideo,\n        isMuxed: isMuxed\n      });\n      trackInfoFn = null;\n\n      if (probeResult.hasAudio && !isMuxed) {\n        audioStartFn(probeResult.audioStart);\n      }\n\n      if (probeResult.hasVideo) {\n        videoStartFn(probeResult.videoStart);\n      }\n\n      audioStartFn = null;\n      videoStartFn = null;\n    }\n  }\n\n  transmux({\n    bytes: bytes,\n    transmuxer: segment.transmuxer,\n    audioAppendStart: segment.audioAppendStart,\n    gopsToAlignWith: segment.gopsToAlignWith,\n    isPartial: isPartial,\n    remux: isMuxed,\n    onData: function onData(result) {\n      result.type = result.type === 'combined' ? 'video' : result.type;\n      dataFn(segment, result);\n    },\n    onTrackInfo: function onTrackInfo(trackInfo) {\n      if (trackInfoFn) {\n        if (isMuxed) {\n          trackInfo.isMuxed = true;\n        }\n\n        trackInfoFn(segment, trackInfo);\n      }\n    },\n    onAudioTimingInfo: function onAudioTimingInfo(audioTimingInfo) {\n      // we only want the first start value we encounter\n      if (audioStartFn && typeof audioTimingInfo.start !== 'undefined') {\n        audioStartFn(audioTimingInfo.start);\n        audioStartFn = null;\n      } // we want to continually update the end time\n\n\n      if (audioEndFn && typeof audioTimingInfo.end !== 'undefined') {\n        audioEndFn(audioTimingInfo.end);\n      }\n    },\n    onVideoTimingInfo: function onVideoTimingInfo(videoTimingInfo) {\n      // we only want the first start value we encounter\n      if (videoStartFn && typeof videoTimingInfo.start !== 'undefined') {\n        videoStartFn(videoTimingInfo.start);\n        videoStartFn = null;\n      } // we want to continually update the end time\n\n\n      if (videoEndFn && typeof videoTimingInfo.end !== 'undefined') {\n        videoEndFn(videoTimingInfo.end);\n      }\n    },\n    onVideoSegmentTimingInfo: function onVideoSegmentTimingInfo(videoSegmentTimingInfo) {\n      videoSegmentTimingInfoFn(videoSegmentTimingInfo);\n    },\n    onId3: function onId3(id3Frames, dispatchType) {\n      id3Fn(segment, id3Frames, dispatchType);\n    },\n    onCaptions: function onCaptions(captions) {\n      captionsFn(segment, [captions]);\n    },\n    onDone: function onDone(result) {\n      // To handle partial appends, there won't be a done function passed in (since\n      // there's still, potentially, more segment to process), so there's nothing to do.\n      if (!doneFn || isPartial) {\n        return;\n      }\n\n      result.type = result.type === 'combined' ? 'video' : result.type;\n      doneFn(null, segment, result);\n    }\n  });\n};\n\nvar handleSegmentBytes = function handleSegmentBytes(_ref4) {\n  var segment = _ref4.segment,\n      bytes = _ref4.bytes,\n      isPartial = _ref4.isPartial,\n      trackInfoFn = _ref4.trackInfoFn,\n      timingInfoFn = _ref4.timingInfoFn,\n      videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn,\n      id3Fn = _ref4.id3Fn,\n      captionsFn = _ref4.captionsFn,\n      dataFn = _ref4.dataFn,\n      doneFn = _ref4.doneFn;\n  var bytesAsUint8Array = new Uint8Array(bytes); // TODO:\n  // We should have a handler that fetches the number of bytes required\n  // to check if something is fmp4. This will allow us to save bandwidth\n  // because we can only blacklist a playlist and abort requests\n  // by codec after trackinfo triggers.\n\n  if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {\n    segment.isFmp4 = true;\n    var tracks = segment.map.tracks;\n    var trackInfo = {\n      isFmp4: true,\n      hasVideo: !!tracks.video,\n      hasAudio: !!tracks.audio\n    }; // if we have a audio track, with a codec that is not set to\n    // encrypted audio\n\n    if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== 'enca') {\n      trackInfo.audioCodec = tracks.audio.codec;\n    } // if we have a video track, with a codec that is not set to\n    // encrypted video\n\n\n    if (tracks.video && tracks.video.codec && tracks.video.codec !== 'encv') {\n      trackInfo.videoCodec = tracks.video.codec;\n    }\n\n    if (tracks.video && tracks.audio) {\n      trackInfo.isMuxed = true;\n    } // since we don't support appending fmp4 data on progress, we know we have the full\n    // segment here\n\n\n    trackInfoFn(segment, trackInfo); // The probe doesn't provide the segment end time, so only callback with the start\n    // time. The end time can be roughly calculated by the receiver using the duration.\n    //\n    // Note that the start time returned by the probe reflects the baseMediaDecodeTime, as\n    // that is the true start of the segment (where the playback engine should begin\n    // decoding).\n\n    var timingInfo = mp4probe.startTime(segment.map.timescales, bytesAsUint8Array);\n\n    if (trackInfo.hasAudio && !trackInfo.isMuxed) {\n      timingInfoFn(segment, 'audio', 'start', timingInfo);\n    }\n\n    if (trackInfo.hasVideo) {\n      timingInfoFn(segment, 'video', 'start', timingInfo);\n    }\n\n    var finishLoading = function finishLoading(captions) {\n      // if the track still has audio at this point it is only possible\n      // for it to be audio only. See `tracks.video && tracks.audio` if statement\n      // above.\n      // we make sure to use segment.bytes here as that\n      dataFn(segment, {\n        data: bytes,\n        type: trackInfo.hasAudio && !trackInfo.isMuxed ? 'audio' : 'video'\n      });\n\n      if (captions && captions.length) {\n        captionsFn(segment, captions);\n      }\n\n      doneFn(null, segment, {});\n    }; // Run through the CaptionParser in case there are captions.\n    // Initialize CaptionParser if it hasn't been yet\n\n\n    if (!tracks.video || !bytes.byteLength || !segment.transmuxer) {\n      finishLoading();\n      return;\n    }\n\n    var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;\n    var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;\n\n    var listenForCaptions = function listenForCaptions(event) {\n      if (event.data.action !== 'mp4Captions') {\n        return;\n      }\n\n      segment.transmuxer.removeEventListener('message', listenForCaptions);\n      var data = event.data.data; // transfer ownership of bytes back to us.\n\n      segment.bytes = bytes = new Uint8Array(data, data.byteOffset || 0, data.byteLength);\n      finishLoading(event.data.captions);\n    };\n\n    segment.transmuxer.addEventListener('message', listenForCaptions); // transfer ownership of bytes to worker.\n\n    segment.transmuxer.postMessage({\n      action: 'pushMp4Captions',\n      timescales: segment.map.timescales,\n      trackIds: [tracks.video.id],\n      data: buffer,\n      byteOffset: byteOffset,\n      byteLength: bytes.byteLength\n    }, [buffer]);\n    return;\n  } // VTT or other segments that don't need processing\n\n\n  if (!segment.transmuxer) {\n    doneFn(null, segment, {});\n    return;\n  }\n\n  if (typeof segment.container === 'undefined') {\n    segment.container = detectContainerForBytes(bytesAsUint8Array);\n  }\n\n  if (segment.container !== 'ts' && segment.container !== 'aac') {\n    trackInfoFn(segment, {\n      hasAudio: false,\n      hasVideo: false\n    });\n    doneFn(null, segment, {});\n    return;\n  } // ts or aac\n\n\n  transmuxAndNotify({\n    segment: segment,\n    bytes: bytes,\n    isPartial: isPartial,\n    trackInfoFn: trackInfoFn,\n    timingInfoFn: timingInfoFn,\n    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\n    id3Fn: id3Fn,\n    captionsFn: captionsFn,\n    dataFn: dataFn,\n    doneFn: doneFn\n  });\n};\n/**\n * Decrypt the segment via the decryption web worker\n *\n * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n *                                       routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} trackInfoFn - a callback that receives track info\n * @param {Function} dataFn - a callback that is executed when segment bytes are available\n *                            and ready to use\n * @param {Function} doneFn - a callback that is executed after decryption has completed\n */\n\n\nvar decryptSegment = function decryptSegment(_ref5) {\n  var decryptionWorker = _ref5.decryptionWorker,\n      segment = _ref5.segment,\n      trackInfoFn = _ref5.trackInfoFn,\n      timingInfoFn = _ref5.timingInfoFn,\n      videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn,\n      id3Fn = _ref5.id3Fn,\n      captionsFn = _ref5.captionsFn,\n      dataFn = _ref5.dataFn,\n      doneFn = _ref5.doneFn;\n\n  var decryptionHandler = function decryptionHandler(event) {\n    if (event.data.source === segment.requestId) {\n      decryptionWorker.removeEventListener('message', decryptionHandler);\n      var decrypted = event.data.decrypted;\n      segment.bytes = new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength);\n      handleSegmentBytes({\n        segment: segment,\n        bytes: segment.bytes,\n        isPartial: false,\n        trackInfoFn: trackInfoFn,\n        timingInfoFn: timingInfoFn,\n        videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\n        id3Fn: id3Fn,\n        captionsFn: captionsFn,\n        dataFn: dataFn,\n        doneFn: doneFn\n      });\n    }\n  };\n\n  decryptionWorker.addEventListener('message', decryptionHandler);\n  var keyBytes;\n\n  if (segment.key.bytes.slice) {\n    keyBytes = segment.key.bytes.slice();\n  } else {\n    keyBytes = new Uint32Array(Array.prototype.slice.call(segment.key.bytes));\n  } // this is an encrypted segment\n  // incrementally decrypt the segment\n\n\n  decryptionWorker.postMessage(createTransferableMessage({\n    source: segment.requestId,\n    encrypted: segment.encryptedBytes,\n    key: keyBytes,\n    iv: segment.key.iv\n  }), [segment.encryptedBytes.buffer, keyBytes.buffer]);\n};\n/**\n * This function waits for all XHRs to finish (with either success or failure)\n * before continueing processing via it's callback. The function gathers errors\n * from each request into a single errors array so that the error status for\n * each request can be examined later.\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n *                                       routines\n * @param {Function} trackInfoFn - a callback that receives track info\n * @param {Function} timingInfoFn - a callback that receives timing info\n * @param {Function} id3Fn - a callback that receives ID3 metadata\n * @param {Function} captionsFn - a callback that receives captions\n * @param {Function} dataFn - a callback that is executed when segment bytes are available\n *                            and ready to use\n * @param {Function} doneFn - a callback that is executed after all resources have been\n *                            downloaded and any decryption completed\n */\n\n\nvar waitForCompletion = function waitForCompletion(_ref6) {\n  var activeXhrs = _ref6.activeXhrs,\n      decryptionWorker = _ref6.decryptionWorker,\n      trackInfoFn = _ref6.trackInfoFn,\n      timingInfoFn = _ref6.timingInfoFn,\n      videoSegmentTimingInfoFn = _ref6.videoSegmentTimingInfoFn,\n      id3Fn = _ref6.id3Fn,\n      captionsFn = _ref6.captionsFn,\n      dataFn = _ref6.dataFn,\n      doneFn = _ref6.doneFn;\n  var count = 0;\n  var didError = false;\n  return function (error, segment) {\n    if (didError) {\n      return;\n    }\n\n    if (error) {\n      didError = true; // If there are errors, we have to abort any outstanding requests\n\n      abortAll(activeXhrs); // Even though the requests above are aborted, and in theory we could wait until we\n      // handle the aborted events from those requests, there are some cases where we may\n      // never get an aborted event. For instance, if the network connection is lost and\n      // there were two requests, the first may have triggered an error immediately, while\n      // the second request remains unsent. In that case, the aborted algorithm will not\n      // trigger an abort: see https://xhr.spec.whatwg.org/#the-abort()-method\n      //\n      // We also can't rely on the ready state of the XHR, since the request that\n      // triggered the connection error may also show as a ready state of 0 (unsent).\n      // Therefore, we have to finish this group of requests immediately after the first\n      // seen error.\n\n      return doneFn(error, segment);\n    }\n\n    count += 1;\n\n    if (count === activeXhrs.length) {\n      // Keep track of when *all* of the requests have completed\n      segment.endOfAllRequests = Date.now();\n\n      if (segment.encryptedBytes) {\n        return decryptSegment({\n          decryptionWorker: decryptionWorker,\n          segment: segment,\n          trackInfoFn: trackInfoFn,\n          timingInfoFn: timingInfoFn,\n          videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\n          id3Fn: id3Fn,\n          captionsFn: captionsFn,\n          dataFn: dataFn,\n          doneFn: doneFn\n        });\n      } // Otherwise, everything is ready just continue\n\n\n      handleSegmentBytes({\n        segment: segment,\n        bytes: segment.bytes,\n        isPartial: false,\n        trackInfoFn: trackInfoFn,\n        timingInfoFn: timingInfoFn,\n        videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\n        id3Fn: id3Fn,\n        captionsFn: captionsFn,\n        dataFn: dataFn,\n        doneFn: doneFn\n      });\n    }\n  };\n};\n/**\n * Calls the abort callback if any request within the batch was aborted. Will only call\n * the callback once per batch of requests, even if multiple were aborted.\n *\n * @param {Object} loadendState - state to check to see if the abort function was called\n * @param {Function} abortFn - callback to call for abort\n */\n\n\nvar handleLoadEnd = function handleLoadEnd(_ref7) {\n  var loadendState = _ref7.loadendState,\n      abortFn = _ref7.abortFn;\n  return function (event) {\n    var request = event.target;\n\n    if (request.aborted && abortFn && !loadendState.calledAbortFn) {\n      abortFn();\n      loadendState.calledAbortFn = true;\n    }\n  };\n};\n/**\n * Simple progress event callback handler that gathers some stats before\n * executing a provided callback with the `segment` object\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that is executed each time a progress event\n *                                is received\n * @param {Function} trackInfoFn - a callback that receives track info\n * @param {Function} dataFn - a callback that is executed when segment bytes are available\n *                            and ready to use\n * @param {Event} event - the progress event object from XMLHttpRequest\n */\n\n\nvar handleProgress = function handleProgress(_ref8) {\n  var segment = _ref8.segment,\n      progressFn = _ref8.progressFn,\n      trackInfoFn = _ref8.trackInfoFn,\n      timingInfoFn = _ref8.timingInfoFn,\n      videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn,\n      id3Fn = _ref8.id3Fn,\n      captionsFn = _ref8.captionsFn,\n      dataFn = _ref8.dataFn,\n      handlePartialData = _ref8.handlePartialData;\n  return function (event) {\n    var request = event.target;\n\n    if (request.aborted) {\n      return;\n    } // don't support encrypted segments or fmp4 for now\n\n\n    if (handlePartialData && !segment.key && // although responseText \"should\" exist, this guard serves to prevent an error being\n    // thrown on the next check for two primary cases:\n    // 1. the mime type override stops working, or is not implemented for a specific\n    //    browser\n    // 2. when using mock XHR libraries like sinon that do not allow the override behavior\n    request.responseText && // in order to determine if it's an fmp4 we need at least 8 bytes\n    request.responseText.length >= 8) {\n      var newBytes = stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));\n\n      if (segment.lastReachedChar || !isLikelyFmp4MediaSegment(new Uint8Array(newBytes))) {\n        segment.lastReachedChar = request.responseText.length;\n        handleSegmentBytes({\n          segment: segment,\n          bytes: newBytes,\n          isPartial: true,\n          trackInfoFn: trackInfoFn,\n          timingInfoFn: timingInfoFn,\n          videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\n          id3Fn: id3Fn,\n          captionsFn: captionsFn,\n          dataFn: dataFn\n        });\n      }\n    }\n\n    segment.stats = videojs$1.mergeOptions(segment.stats, getProgressStats(event)); // record the time that we receive the first byte of data\n\n    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n      segment.stats.firstBytesReceivedAt = Date.now();\n    }\n\n    return progressFn(event, segment);\n  };\n};\n/**\n * Load all resources and does any processing necessary for a media-segment\n *\n * Features:\n *   decrypts the media-segment if it has a key uri and an iv\n *   aborts *all* requests if *any* one request fails\n *\n * The segment object, at minimum, has the following format:\n * {\n *   resolvedUri: String,\n *   [transmuxer]: Object,\n *   [byterange]: {\n *     offset: Number,\n *     length: Number\n *   },\n *   [key]: {\n *     resolvedUri: String\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     iv: {\n *       bytes: Uint32Array\n *     }\n *   },\n *   [map]: {\n *     resolvedUri: String,\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     [bytes]: Uint8Array\n *   }\n * }\n * ...where [name] denotes optional properties\n *\n * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n * @param {Object} xhrOptions - the base options to provide to all xhr requests\n * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n *                                       decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} abortFn - a callback called (only once) if any piece of a request was\n *                             aborted\n * @param {Function} progressFn - a callback that receives progress events from the main\n *                                segment's xhr request\n * @param {Function} trackInfoFn - a callback that receives track info\n * @param {Function} id3Fn - a callback that receives ID3 metadata\n * @param {Function} captionsFn - a callback that receives captions\n * @param {Function} dataFn - a callback that receives data from the main segment's xhr\n *                            request, transmuxed if needed\n * @param {Function} doneFn - a callback that is executed only once all requests have\n *                            succeeded or failed\n * @return {Function} a function that, when invoked, immediately aborts all\n *                     outstanding requests\n */\n\n\nvar mediaSegmentRequest = function mediaSegmentRequest(_ref9) {\n  var xhr = _ref9.xhr,\n      xhrOptions = _ref9.xhrOptions,\n      decryptionWorker = _ref9.decryptionWorker,\n      segment = _ref9.segment,\n      abortFn = _ref9.abortFn,\n      progressFn = _ref9.progressFn,\n      trackInfoFn = _ref9.trackInfoFn,\n      timingInfoFn = _ref9.timingInfoFn,\n      videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn,\n      id3Fn = _ref9.id3Fn,\n      captionsFn = _ref9.captionsFn,\n      dataFn = _ref9.dataFn,\n      doneFn = _ref9.doneFn,\n      handlePartialData = _ref9.handlePartialData;\n  var activeXhrs = [];\n  var finishProcessingFn = waitForCompletion({\n    activeXhrs: activeXhrs,\n    decryptionWorker: decryptionWorker,\n    trackInfoFn: trackInfoFn,\n    timingInfoFn: timingInfoFn,\n    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\n    id3Fn: id3Fn,\n    captionsFn: captionsFn,\n    dataFn: dataFn,\n    doneFn: doneFn\n  }); // optionally, request the decryption key\n\n  if (segment.key && !segment.key.bytes) {\n    var keyRequestOptions = videojs$1.mergeOptions(xhrOptions, {\n      uri: segment.key.resolvedUri,\n      responseType: 'arraybuffer'\n    });\n    var keyRequestCallback = handleKeyResponse(segment, finishProcessingFn);\n    var keyXhr = xhr(keyRequestOptions, keyRequestCallback);\n    activeXhrs.push(keyXhr);\n  } // optionally, request the associated media init segment\n\n\n  if (segment.map && !segment.map.bytes) {\n    var initSegmentOptions = videojs$1.mergeOptions(xhrOptions, {\n      uri: segment.map.resolvedUri,\n      responseType: 'arraybuffer',\n      headers: segmentXhrHeaders(segment.map)\n    });\n    var initSegmentRequestCallback = handleInitSegmentResponse({\n      segment: segment,\n      finishProcessingFn: finishProcessingFn\n    });\n    var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\n    activeXhrs.push(initSegmentXhr);\n  }\n\n  var segmentRequestOptions = videojs$1.mergeOptions(xhrOptions, {\n    uri: segment.resolvedUri,\n    responseType: 'arraybuffer',\n    headers: segmentXhrHeaders(segment)\n  });\n\n  if (handlePartialData) {\n    // setting to text is required for partial responses\n    // conversion to ArrayBuffer happens later\n    segmentRequestOptions.responseType = 'text';\n\n    segmentRequestOptions.beforeSend = function (xhrObject) {\n      // XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]\n      // makes the browser pass through the \"text\" unparsed\n      xhrObject.overrideMimeType('text/plain; charset=x-user-defined');\n    };\n  }\n\n  var segmentRequestCallback = handleSegmentResponse({\n    segment: segment,\n    finishProcessingFn: finishProcessingFn,\n    responseType: segmentRequestOptions.responseType\n  });\n  var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\n  segmentXhr.addEventListener('progress', handleProgress({\n    segment: segment,\n    progressFn: progressFn,\n    trackInfoFn: trackInfoFn,\n    timingInfoFn: timingInfoFn,\n    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\n    id3Fn: id3Fn,\n    captionsFn: captionsFn,\n    dataFn: dataFn,\n    handlePartialData: handlePartialData\n  }));\n  activeXhrs.push(segmentXhr); // since all parts of the request must be considered, but should not make callbacks\n  // multiple times, provide a shared state object\n\n  var loadendState = {};\n  activeXhrs.forEach(function (activeXhr) {\n    activeXhr.addEventListener('loadend', handleLoadEnd({\n      loadendState: loadendState,\n      abortFn: abortFn\n    }));\n  });\n  return function () {\n    return abortAll(activeXhrs);\n  };\n};\n\nvar win = typeof window !== 'undefined' ? window : {},\n    TARGET = typeof Symbol === 'undefined' ? '__target' : Symbol(),\n    SCRIPT_TYPE = 'application/javascript',\n    BlobBuilder = win.BlobBuilder || win.WebKitBlobBuilder || win.MozBlobBuilder || win.MSBlobBuilder,\n    URL = win.URL || win.webkitURL || URL && URL.msURL,\n    Worker = win.Worker;\n/**\n * Returns a wrapper around Web Worker code that is constructible.\n *\n * @function shimWorker\n *\n * @param { String }    filename    The name of the file\n * @param { Function }  fn          Function wrapping the code of the worker\n */\n\nfunction shimWorker(filename, fn) {\n  return function ShimWorker(forceFallback) {\n    var o = this;\n\n    if (!fn) {\n      return new Worker(filename);\n    } else if (Worker && !forceFallback) {\n      // Convert the function's inner code to a string to construct the worker\n      var source = fn.toString().replace(/^function.+?{/, '').slice(0, -1),\n          objURL = createSourceObject(source);\n      this[TARGET] = new Worker(objURL);\n      wrapTerminate(this[TARGET], objURL);\n      return this[TARGET];\n    } else {\n      var selfShim = {\n        postMessage: function postMessage(m) {\n          if (o.onmessage) {\n            setTimeout(function () {\n              o.onmessage({\n                data: m,\n                target: selfShim\n              });\n            });\n          }\n        }\n      };\n      fn.call(selfShim);\n\n      this.postMessage = function (m) {\n        setTimeout(function () {\n          selfShim.onmessage({\n            data: m,\n            target: o\n          });\n        });\n      };\n\n      this.isThisThread = true;\n    }\n  };\n} // Test Worker capabilities\n\n\nif (Worker) {\n  var testWorker,\n      objURL = createSourceObject('self.onmessage = function () {}'),\n      testArray = new Uint8Array(1);\n\n  try {\n    testWorker = new Worker(objURL); // Native browser on some Samsung devices throws for transferables, let's detect it\n\n    testWorker.postMessage(testArray, [testArray.buffer]);\n  } catch (e) {\n    Worker = null;\n  } finally {\n    URL.revokeObjectURL(objURL);\n\n    if (testWorker) {\n      testWorker.terminate();\n    }\n  }\n}\n\nfunction createSourceObject(str) {\n  try {\n    return URL.createObjectURL(new Blob([str], {\n      type: SCRIPT_TYPE\n    }));\n  } catch (e) {\n    var blob = new BlobBuilder();\n    blob.append(str);\n    return URL.createObjectURL(blob.getBlob(type));\n  }\n}\n\nfunction wrapTerminate(worker, objURL) {\n  if (!worker || !objURL) return;\n  var term = worker.terminate;\n  worker.objURL = objURL;\n\n  worker.terminate = function () {\n    if (worker.objURL) URL.revokeObjectURL(worker.objURL);\n    term.call(worker);\n  };\n}\n\nvar TransmuxWorker = new shimWorker(\"./transmuxer-worker.worker.js\", function (window, document) {\n  var self = this;\n  /*! @name @videojs/http-streaming @version 2.2.4 @license Apache-2.0 */\n\n  var transmuxerWorker = function () {\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * A lightweight readable stream implemention that handles event dispatching.\n     * Objects that inherit from streams should call init in their constructors.\n     */\n    var Stream = function Stream() {\n      this.init = function () {\n        var listeners = {};\n        /**\n         * Add a listener for a specified event type.\n         * @param type {string} the event name\n         * @param listener {function} the callback to be invoked when an event of\n         * the specified type occurs\n         */\n\n        this.on = function (type, listener) {\n          if (!listeners[type]) {\n            listeners[type] = [];\n          }\n\n          listeners[type] = listeners[type].concat(listener);\n        };\n        /**\n         * Remove a listener for a specified event type.\n         * @param type {string} the event name\n         * @param listener {function} a function previously registered for this\n         * type of event through `on`\n         */\n\n\n        this.off = function (type, listener) {\n          var index;\n\n          if (!listeners[type]) {\n            return false;\n          }\n\n          index = listeners[type].indexOf(listener);\n          listeners[type] = listeners[type].slice();\n          listeners[type].splice(index, 1);\n          return index > -1;\n        };\n        /**\n         * Trigger an event of the specified type on this stream. Any additional\n         * arguments to this function are passed as parameters to event listeners.\n         * @param type {string} the event name\n         */\n\n\n        this.trigger = function (type) {\n          var callbacks, i, length, args;\n          callbacks = listeners[type];\n\n          if (!callbacks) {\n            return;\n          } // Slicing the arguments on every invocation of this method\n          // can add a significant amount of overhead. Avoid the\n          // intermediate object creation for the common case of a\n          // single callback argument\n\n\n          if (arguments.length === 2) {\n            length = callbacks.length;\n\n            for (i = 0; i < length; ++i) {\n              callbacks[i].call(this, arguments[1]);\n            }\n          } else {\n            args = [];\n            i = arguments.length;\n\n            for (i = 1; i < arguments.length; ++i) {\n              args.push(arguments[i]);\n            }\n\n            length = callbacks.length;\n\n            for (i = 0; i < length; ++i) {\n              callbacks[i].apply(this, args);\n            }\n          }\n        };\n        /**\n         * Destroys the stream and cleans up.\n         */\n\n\n        this.dispose = function () {\n          listeners = {};\n        };\n      };\n    };\n    /**\n     * Forwards all `data` events on this stream to the destination stream. The\n     * destination stream should provide a method `push` to receive the data\n     * events as they arrive.\n     * @param destination {stream} the stream that will receive all `data` events\n     * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n     *                            when the current stream emits a 'done' event\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n     */\n\n\n    Stream.prototype.pipe = function (destination) {\n      this.on('data', function (data) {\n        destination.push(data);\n      });\n      this.on('done', function (flushSource) {\n        destination.flush(flushSource);\n      });\n      this.on('partialdone', function (flushSource) {\n        destination.partialFlush(flushSource);\n      });\n      this.on('endedtimeline', function (flushSource) {\n        destination.endTimeline(flushSource);\n      });\n      this.on('reset', function (flushSource) {\n        destination.reset(flushSource);\n      });\n      return destination;\n    }; // Default stream functions that are expected to be overridden to perform\n    // actual work. These are provided by the prototype as a sort of no-op\n    // implementation so that we don't have to check for their existence in the\n    // `pipe` function above.\n\n\n    Stream.prototype.push = function (data) {\n      this.trigger('data', data);\n    };\n\n    Stream.prototype.flush = function (flushSource) {\n      this.trigger('done', flushSource);\n    };\n\n    Stream.prototype.partialFlush = function (flushSource) {\n      this.trigger('partialdone', flushSource);\n    };\n\n    Stream.prototype.endTimeline = function (flushSource) {\n      this.trigger('endedtimeline', flushSource);\n    };\n\n    Stream.prototype.reset = function (flushSource) {\n      this.trigger('reset', flushSource);\n    };\n\n    var stream = Stream;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Functions that generate fragmented MP4s suitable for use with Media\n     * Source Extensions.\n     */\n\n    var UINT32_MAX = Math.pow(2, 32) - 1;\n    var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n    (function () {\n      var i;\n      types = {\n        avc1: [],\n        // codingname\n        avcC: [],\n        btrt: [],\n        dinf: [],\n        dref: [],\n        esds: [],\n        ftyp: [],\n        hdlr: [],\n        mdat: [],\n        mdhd: [],\n        mdia: [],\n        mfhd: [],\n        minf: [],\n        moof: [],\n        moov: [],\n        mp4a: [],\n        // codingname\n        mvex: [],\n        mvhd: [],\n        pasp: [],\n        sdtp: [],\n        smhd: [],\n        stbl: [],\n        stco: [],\n        stsc: [],\n        stsd: [],\n        stsz: [],\n        stts: [],\n        styp: [],\n        tfdt: [],\n        tfhd: [],\n        traf: [],\n        trak: [],\n        trun: [],\n        trex: [],\n        tkhd: [],\n        vmhd: []\n      }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n      // don't throw an error\n\n      if (typeof Uint8Array === 'undefined') {\n        return;\n      }\n\n      for (i in types) {\n        if (types.hasOwnProperty(i)) {\n          types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n        }\n      }\n\n      MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n      AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n      MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n      VIDEO_HDLR = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ]);\n      AUDIO_HDLR = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n      ]);\n      HDLR_TYPES = {\n        video: VIDEO_HDLR,\n        audio: AUDIO_HDLR\n      };\n      DREF = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // entry_count\n      0x00, 0x00, 0x00, 0x0c, // entry_size\n      0x75, 0x72, 0x6c, 0x20, // 'url' type\n      0x00, // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ]);\n      SMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, // balance, 0 means centered\n      0x00, 0x00 // reserved\n      ]);\n      STCO = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n      STSC = STCO;\n      STSZ = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // sample_size\n      0x00, 0x00, 0x00, 0x00 // sample_count\n      ]);\n      STTS = STCO;\n      VMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x01, // flags\n      0x00, 0x00, // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]);\n    })();\n\n    box = function box(type) {\n      var payload = [],\n          size = 0,\n          i,\n          result,\n          view;\n\n      for (i = 1; i < arguments.length; i++) {\n        payload.push(arguments[i]);\n      }\n\n      i = payload.length; // calculate the total size we need to allocate\n\n      while (i--) {\n        size += payload[i].byteLength;\n      }\n\n      result = new Uint8Array(size + 8);\n      view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n      view.setUint32(0, result.byteLength);\n      result.set(type, 4); // copy the payload into the result\n\n      for (i = 0, size = 8; i < payload.length; i++) {\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n      }\n\n      return result;\n    };\n\n    dinf = function dinf() {\n      return box(types.dinf, box(types.dref, DREF));\n    };\n\n    esds = function esds(track) {\n      return box(types.esds, new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      // ES_Descriptor\n      0x03, // tag, ES_DescrTag\n      0x19, // length\n      0x00, 0x00, // ES_ID\n      0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n      // DecoderConfigDescriptor\n      0x04, // tag, DecoderConfigDescrTag\n      0x11, // length\n      0x40, // object type\n      0x15, // streamType\n      0x00, 0x06, 0x00, // bufferSizeDB\n      0x00, 0x00, 0xda, 0xc0, // maxBitrate\n      0x00, 0x00, 0xda, 0xc0, // avgBitrate\n      // DecoderSpecificInfo\n      0x05, // tag, DecoderSpecificInfoTag\n      0x02, // length\n      // ISO/IEC 14496-3, AudioSpecificConfig\n      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n      ]));\n    };\n\n    ftyp = function ftyp() {\n      return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n    };\n\n    hdlr = function hdlr(type) {\n      return box(types.hdlr, HDLR_TYPES[type]);\n    };\n\n    mdat = function mdat(data) {\n      return box(types.mdat, data);\n    };\n\n    mdhd = function mdhd(track) {\n      var result = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x02, // creation_time\n      0x00, 0x00, 0x00, 0x03, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF, // duration\n      0x55, 0xc4, // 'und' language (undetermined)\n      0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n      // defined. The sample rate can be parsed out of an ADTS header, for\n      // instance.\n\n      if (track.samplerate) {\n        result[12] = track.samplerate >>> 24 & 0xFF;\n        result[13] = track.samplerate >>> 16 & 0xFF;\n        result[14] = track.samplerate >>> 8 & 0xFF;\n        result[15] = track.samplerate & 0xFF;\n      }\n\n      return box(types.mdhd, result);\n    };\n\n    mdia = function mdia(track) {\n      return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n    };\n\n    mfhd = function mfhd(sequenceNumber) {\n      return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n      (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n      ]));\n    };\n\n    minf = function minf(track) {\n      return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n    };\n\n    moof = function moof(sequenceNumber, tracks) {\n      var trackFragments = [],\n          i = tracks.length; // build traf boxes for each track fragment\n\n      while (i--) {\n        trackFragments[i] = traf(tracks[i]);\n      }\n\n      return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n    };\n    /**\n     * Returns a movie box.\n     * @param tracks {array} the tracks associated with this movie\n     * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n     */\n\n\n    moov = function moov(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = trak(tracks[i]);\n      }\n\n      return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n    };\n\n    mvex = function mvex(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = trex(tracks[i]);\n      }\n\n      return box.apply(null, [types.mvex].concat(boxes));\n    };\n\n    mvhd = function mvhd(duration) {\n      var bytes = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n      return box(types.mvhd, bytes);\n    };\n\n    sdtp = function sdtp(track) {\n      var samples = track.samples || [],\n          bytes = new Uint8Array(4 + samples.length),\n          flags,\n          i; // leave the full box header (4 bytes) all zero\n      // write the sample table\n\n      for (i = 0; i < samples.length; i++) {\n        flags = samples[i].flags;\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n      }\n\n      return box(types.sdtp, bytes);\n    };\n\n    stbl = function stbl(track) {\n      return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n    };\n\n    (function () {\n      var videoSample, audioSample;\n\n      stsd = function stsd(track) {\n        return box(types.stsd, new Uint8Array([0x00, // version 0\n        0x00, 0x00, 0x00, // flags\n        0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n      };\n\n      videoSample = function videoSample(track) {\n        var sps = track.sps || [],\n            pps = track.pps || [],\n            sequenceParameterSets = [],\n            pictureParameterSets = [],\n            i,\n            avc1Box; // assemble the SPSs\n\n        for (i = 0; i < sps.length; i++) {\n          sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n          sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n          sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n        } // assemble the PPSs\n\n\n        for (i = 0; i < pps.length; i++) {\n          pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n          pictureParameterSets.push(pps[i].byteLength & 0xFF);\n          pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n        }\n\n        avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n        (track.width & 0xff00) >> 8, track.width & 0xff, // width\n        (track.height & 0xff00) >> 8, track.height & 0xff, // height\n        0x00, 0x48, 0x00, 0x00, // horizresolution\n        0x00, 0x48, 0x00, 0x00, // vertresolution\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // frame_count\n        0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n        0x00, 0x18, // depth = 24\n        0x11, 0x11 // pre_defined = -1\n        ]), box(types.avcC, new Uint8Array([0x01, // configurationVersion\n        track.profileIdc, // AVCProfileIndication\n        track.profileCompatibility, // profile_compatibility\n        track.levelIdc, // AVCLevelIndication\n        0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n        ].concat([sps.length], // numOfSequenceParameterSets\n        sequenceParameterSets, // \"SPS\"\n        [pps.length], // numOfPictureParameterSets\n        pictureParameterSets // \"PPS\"\n        ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n        0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n        0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n        ]))];\n\n        if (track.sarRatio) {\n          var hSpacing = track.sarRatio[0],\n              vSpacing = track.sarRatio[1];\n          avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n        }\n\n        return box.apply(null, avc1Box);\n      };\n\n      audioSample = function audioSample(track) {\n        return box(types.mp4a, new Uint8Array([// SampleEntry, ISO/IEC 14496-12\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n        // AudioSampleEntry, ISO/IEC 14496-12\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, // reserved\n        (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff, // channelcount\n        (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff, // samplesize\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n        (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n        // MP4AudioSampleEntry, ISO/IEC 14496-14\n        ]), esds(track));\n      };\n    })();\n\n    tkhd = function tkhd(track) {\n      var result = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x07, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF, // duration\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // alternate_group\n      0x01, 0x00, // non-audio track volume\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00, // width\n      (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n      ]);\n      return box(types.tkhd, result);\n    };\n    /**\n     * Generate a track fragment (traf) box. A traf box collects metadata\n     * about tracks in a movie fragment (moof) box.\n     */\n\n\n    traf = function traf(track) {\n      var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n      trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x3a, // flags\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x01, // sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x00, 0x00, 0x00 // default_sample_flags\n      ]));\n      upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n      lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n      trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01, // version 1\n      0x00, 0x00, 0x00, // flags\n      // baseMediaDecodeTime\n      upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n      // the containing moof to the first payload byte of the associated\n      // mdat\n\n      dataOffset = 32 + // tfhd\n      20 + // tfdt\n      8 + // traf header\n      16 + // mfhd\n      8 + // moof header\n      8; // mdat header\n      // audio tracks require less metadata\n\n      if (track.type === 'audio') {\n        trackFragmentRun = trun(track, dataOffset);\n        return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n      } // video tracks should contain an independent and disposable samples\n      // box (sdtp)\n      // generate one and adjust offsets to match\n\n\n      sampleDependencyTable = sdtp(track);\n      trackFragmentRun = trun(track, sampleDependencyTable.length + dataOffset);\n      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n    };\n    /**\n     * Generate a track box.\n     * @param track {object} a track definition\n     * @return {Uint8Array} the track box\n     */\n\n\n    trak = function trak(track) {\n      track.duration = track.duration || 0xffffffff;\n      return box(types.trak, tkhd(track), mdia(track));\n    };\n\n    trex = function trex(track) {\n      var result = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]); // the last two bytes of default_sample_flags is the sample\n      // degradation priority, a hint about the importance of this sample\n      // relative to others. Lower the degradation priority for all sample\n      // types other than video.\n\n      if (track.type !== 'video') {\n        result[result.length - 1] = 0x00;\n      }\n\n      return box(types.trex, result);\n    };\n\n    (function () {\n      var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n      // duration is present for the first sample, it will be present for\n      // all subsequent samples.\n      // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n      trunHeader = function trunHeader(samples, offset) {\n        var durationPresent = 0,\n            sizePresent = 0,\n            flagsPresent = 0,\n            compositionTimeOffset = 0; // trun flag constants\n\n        if (samples.length) {\n          if (samples[0].duration !== undefined) {\n            durationPresent = 0x1;\n          }\n\n          if (samples[0].size !== undefined) {\n            sizePresent = 0x2;\n          }\n\n          if (samples[0].flags !== undefined) {\n            flagsPresent = 0x4;\n          }\n\n          if (samples[0].compositionTimeOffset !== undefined) {\n            compositionTimeOffset = 0x8;\n          }\n        }\n\n        return [0x00, // version 0\n        0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01, // flags\n        (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF, // sample_count\n        (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n        ];\n      };\n\n      videoTrun = function videoTrun(track, offset) {\n        var bytesOffest, bytes, header, samples, sample, i;\n        samples = track.samples || [];\n        offset += 8 + 12 + 16 * samples.length;\n        header = trunHeader(samples, offset);\n        bytes = new Uint8Array(header.length + samples.length * 16);\n        bytes.set(header);\n        bytesOffest = header.length;\n\n        for (i = 0; i < samples.length; i++) {\n          sample = samples[i];\n          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n          bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n          bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n          bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n          bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n        }\n\n        return box(types.trun, bytes);\n      };\n\n      audioTrun = function audioTrun(track, offset) {\n        var bytes, bytesOffest, header, samples, sample, i;\n        samples = track.samples || [];\n        offset += 8 + 12 + 8 * samples.length;\n        header = trunHeader(samples, offset);\n        bytes = new Uint8Array(header.length + samples.length * 8);\n        bytes.set(header);\n        bytesOffest = header.length;\n\n        for (i = 0; i < samples.length; i++) {\n          sample = samples[i];\n          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n        }\n\n        return box(types.trun, bytes);\n      };\n\n      trun = function trun(track, offset) {\n        if (track.type === 'audio') {\n          return audioTrun(track, offset);\n        }\n\n        return videoTrun(track, offset);\n      };\n    })();\n\n    var mp4Generator = {\n      ftyp: ftyp,\n      mdat: mdat,\n      moof: moof,\n      moov: moov,\n      initSegment: function initSegment(tracks) {\n        var fileType = ftyp(),\n            movie = moov(tracks),\n            result;\n        result = new Uint8Array(fileType.byteLength + movie.byteLength);\n        result.set(fileType);\n        result.set(movie, fileType.byteLength);\n        return result;\n      }\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n    // Convert an array of nal units into an array of frames with each frame being\n    // composed of the nal units that make up that frame\n    // Also keep track of cummulative data about the frame from the nal units such\n    // as the frame duration, starting pts, etc.\n\n    var groupNalsIntoFrames = function groupNalsIntoFrames(nalUnits) {\n      var i,\n          currentNal,\n          currentFrame = [],\n          frames = []; // TODO added for LHLS, make sure this is OK\n\n      frames.byteLength = 0;\n      frames.nalCount = 0;\n      frames.duration = 0;\n      currentFrame.byteLength = 0;\n\n      for (i = 0; i < nalUnits.length; i++) {\n        currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n        if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n          // Since the very first nal unit is expected to be an AUD\n          // only push to the frames array when currentFrame is not empty\n          if (currentFrame.length) {\n            currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n            frames.byteLength += currentFrame.byteLength;\n            frames.nalCount += currentFrame.length;\n            frames.duration += currentFrame.duration;\n            frames.push(currentFrame);\n          }\n\n          currentFrame = [currentNal];\n          currentFrame.byteLength = currentNal.data.byteLength;\n          currentFrame.pts = currentNal.pts;\n          currentFrame.dts = currentNal.dts;\n        } else {\n          // Specifically flag key frames for ease of use later\n          if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n            currentFrame.keyFrame = true;\n          }\n\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\n          currentFrame.byteLength += currentNal.data.byteLength;\n          currentFrame.push(currentNal);\n        }\n      } // For the last frame, use the duration of the previous frame if we\n      // have nothing better to go on\n\n\n      if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n        currentFrame.duration = frames[frames.length - 1].duration;\n      } // Push the final frame\n      // TODO added for LHLS, make sure this is OK\n\n\n      frames.byteLength += currentFrame.byteLength;\n      frames.nalCount += currentFrame.length;\n      frames.duration += currentFrame.duration;\n      frames.push(currentFrame);\n      return frames;\n    }; // Convert an array of frames into an array of Gop with each Gop being composed\n    // of the frames that make up that Gop\n    // Also keep track of cummulative data about the Gop from the frames such as the\n    // Gop duration, starting pts, etc.\n\n\n    var groupFramesIntoGops = function groupFramesIntoGops(frames) {\n      var i,\n          currentFrame,\n          currentGop = [],\n          gops = []; // We must pre-set some of the values on the Gop since we\n      // keep running totals of these values\n\n      currentGop.byteLength = 0;\n      currentGop.nalCount = 0;\n      currentGop.duration = 0;\n      currentGop.pts = frames[0].pts;\n      currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n      gops.byteLength = 0;\n      gops.nalCount = 0;\n      gops.duration = 0;\n      gops.pts = frames[0].pts;\n      gops.dts = frames[0].dts;\n\n      for (i = 0; i < frames.length; i++) {\n        currentFrame = frames[i];\n\n        if (currentFrame.keyFrame) {\n          // Since the very first frame is expected to be an keyframe\n          // only push to the gops array when currentGop is not empty\n          if (currentGop.length) {\n            gops.push(currentGop);\n            gops.byteLength += currentGop.byteLength;\n            gops.nalCount += currentGop.nalCount;\n            gops.duration += currentGop.duration;\n          }\n\n          currentGop = [currentFrame];\n          currentGop.nalCount = currentFrame.length;\n          currentGop.byteLength = currentFrame.byteLength;\n          currentGop.pts = currentFrame.pts;\n          currentGop.dts = currentFrame.dts;\n          currentGop.duration = currentFrame.duration;\n        } else {\n          currentGop.duration += currentFrame.duration;\n          currentGop.nalCount += currentFrame.length;\n          currentGop.byteLength += currentFrame.byteLength;\n          currentGop.push(currentFrame);\n        }\n      }\n\n      if (gops.length && currentGop.duration <= 0) {\n        currentGop.duration = gops[gops.length - 1].duration;\n      }\n\n      gops.byteLength += currentGop.byteLength;\n      gops.nalCount += currentGop.nalCount;\n      gops.duration += currentGop.duration; // push the final Gop\n\n      gops.push(currentGop);\n      return gops;\n    };\n    /*\n     * Search for the first keyframe in the GOPs and throw away all frames\n     * until that keyframe. Then extend the duration of the pulled keyframe\n     * and pull the PTS and DTS of the keyframe so that it covers the time\n     * range of the frames that were disposed.\n     *\n     * @param {Array} gops video GOPs\n     * @returns {Array} modified video GOPs\n     */\n\n\n    var extendFirstKeyFrame = function extendFirstKeyFrame(gops) {\n      var currentGop;\n\n      if (!gops[0][0].keyFrame && gops.length > 1) {\n        // Remove the first GOP\n        currentGop = gops.shift();\n        gops.byteLength -= currentGop.byteLength;\n        gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n        // first gop to cover the time period of the\n        // frames we just removed\n\n        gops[0][0].dts = currentGop.dts;\n        gops[0][0].pts = currentGop.pts;\n        gops[0][0].duration += currentGop.duration;\n      }\n\n      return gops;\n    };\n    /**\n     * Default sample object\n     * see ISO/IEC 14496-12:2012, section 8.6.4.3\n     */\n\n\n    var createDefaultSample = function createDefaultSample() {\n      return {\n        size: 0,\n        flags: {\n          isLeading: 0,\n          dependsOn: 1,\n          isDependedOn: 0,\n          hasRedundancy: 0,\n          degradationPriority: 0,\n          isNonSyncSample: 1\n        }\n      };\n    };\n    /*\n     * Collates information from a video frame into an object for eventual\n     * entry into an MP4 sample table.\n     *\n     * @param {Object} frame the video frame\n     * @param {Number} dataOffset the byte offset to position the sample\n     * @return {Object} object containing sample table info for a frame\n     */\n\n\n    var sampleForFrame = function sampleForFrame(frame, dataOffset) {\n      var sample = createDefaultSample();\n      sample.dataOffset = dataOffset;\n      sample.compositionTimeOffset = frame.pts - frame.dts;\n      sample.duration = frame.duration;\n      sample.size = 4 * frame.length; // Space for nal unit size\n\n      sample.size += frame.byteLength;\n\n      if (frame.keyFrame) {\n        sample.flags.dependsOn = 2;\n        sample.flags.isNonSyncSample = 0;\n      }\n\n      return sample;\n    }; // generate the track's sample table from an array of gops\n\n\n    var generateSampleTable = function generateSampleTable(gops, baseDataOffset) {\n      var h,\n          i,\n          sample,\n          currentGop,\n          currentFrame,\n          dataOffset = baseDataOffset || 0,\n          samples = [];\n\n      for (h = 0; h < gops.length; h++) {\n        currentGop = gops[h];\n\n        for (i = 0; i < currentGop.length; i++) {\n          currentFrame = currentGop[i];\n          sample = sampleForFrame(currentFrame, dataOffset);\n          dataOffset += sample.size;\n          samples.push(sample);\n        }\n      }\n\n      return samples;\n    }; // generate the track's raw mdat data from an array of gops\n\n\n    var concatenateNalData = function concatenateNalData(gops) {\n      var h,\n          i,\n          j,\n          currentGop,\n          currentFrame,\n          currentNal,\n          dataOffset = 0,\n          nalsByteLength = gops.byteLength,\n          numberOfNals = gops.nalCount,\n          totalByteLength = nalsByteLength + 4 * numberOfNals,\n          data = new Uint8Array(totalByteLength),\n          view = new DataView(data.buffer); // For each Gop..\n\n      for (h = 0; h < gops.length; h++) {\n        currentGop = gops[h]; // For each Frame..\n\n        for (i = 0; i < currentGop.length; i++) {\n          currentFrame = currentGop[i]; // For each NAL..\n\n          for (j = 0; j < currentFrame.length; j++) {\n            currentNal = currentFrame[j];\n            view.setUint32(dataOffset, currentNal.data.byteLength);\n            dataOffset += 4;\n            data.set(currentNal.data, dataOffset);\n            dataOffset += currentNal.data.byteLength;\n          }\n        }\n      }\n\n      return data;\n    }; // generate the track's sample table from a frame\n\n\n    var generateSampleTableForFrame = function generateSampleTableForFrame(frame, baseDataOffset) {\n      var sample,\n          dataOffset = baseDataOffset || 0,\n          samples = [];\n      sample = sampleForFrame(frame, dataOffset);\n      samples.push(sample);\n      return samples;\n    }; // generate the track's raw mdat data from a frame\n\n\n    var concatenateNalDataForFrame = function concatenateNalDataForFrame(frame) {\n      var i,\n          currentNal,\n          dataOffset = 0,\n          nalsByteLength = frame.byteLength,\n          numberOfNals = frame.length,\n          totalByteLength = nalsByteLength + 4 * numberOfNals,\n          data = new Uint8Array(totalByteLength),\n          view = new DataView(data.buffer); // For each NAL..\n\n      for (i = 0; i < frame.length; i++) {\n        currentNal = frame[i];\n        view.setUint32(dataOffset, currentNal.data.byteLength);\n        dataOffset += 4;\n        data.set(currentNal.data, dataOffset);\n        dataOffset += currentNal.data.byteLength;\n      }\n\n      return data;\n    };\n\n    var frameUtils = {\n      groupNalsIntoFrames: groupNalsIntoFrames,\n      groupFramesIntoGops: groupFramesIntoGops,\n      extendFirstKeyFrame: extendFirstKeyFrame,\n      generateSampleTable: generateSampleTable,\n      concatenateNalData: concatenateNalData,\n      generateSampleTableForFrame: generateSampleTableForFrame,\n      concatenateNalDataForFrame: concatenateNalDataForFrame\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var highPrefix = [33, 16, 5, 32, 164, 27];\n    var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n\n    var zeroFill = function zeroFill(count) {\n      var a = [];\n\n      while (count--) {\n        a.push(0);\n      }\n\n      return a;\n    };\n\n    var makeTable = function makeTable(metaTable) {\n      return Object.keys(metaTable).reduce(function (obj, key) {\n        obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n          return arr.concat(part);\n        }, []));\n        return obj;\n      }, {});\n    };\n\n    var silence;\n\n    var silence_1 = function silence_1() {\n      if (!silence) {\n        // Frames-of-silence to use for filling in missing AAC frames\n        var coneOfSilence = {\n          96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n          88200: [highPrefix, [231], zeroFill(170), [56]],\n          64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n          48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n          44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n          32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n          24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n          16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n          12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n          11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n          8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n        };\n        silence = makeTable(coneOfSilence);\n      }\n\n      return silence;\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n\n    var ONE_SECOND_IN_TS = 90000,\n        // 90kHz clock\n    secondsToVideoTs,\n        secondsToAudioTs,\n        videoTsToSeconds,\n        audioTsToSeconds,\n        audioTsToVideoTs,\n        videoTsToAudioTs,\n        metadataTsToSeconds;\n\n    secondsToVideoTs = function secondsToVideoTs(seconds) {\n      return seconds * ONE_SECOND_IN_TS;\n    };\n\n    secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\n      return seconds * sampleRate;\n    };\n\n    videoTsToSeconds = function videoTsToSeconds(timestamp) {\n      return timestamp / ONE_SECOND_IN_TS;\n    };\n\n    audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\n      return timestamp / sampleRate;\n    };\n\n    audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\n      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n    };\n\n    videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\n      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n    };\n    /**\n     * Adjust ID3 tag or caption timing information by the timeline pts values\n     * (if keepOriginalTimestamps is false) and convert to seconds\n     */\n\n\n    metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {\n      return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n    };\n\n    var clock = {\n      ONE_SECOND_IN_TS: ONE_SECOND_IN_TS,\n      secondsToVideoTs: secondsToVideoTs,\n      secondsToAudioTs: secondsToAudioTs,\n      videoTsToSeconds: videoTsToSeconds,\n      audioTsToSeconds: audioTsToSeconds,\n      audioTsToVideoTs: audioTsToVideoTs,\n      videoTsToAudioTs: videoTsToAudioTs,\n      metadataTsToSeconds: metadataTsToSeconds\n    };\n    var clock_2 = clock.secondsToVideoTs;\n    var clock_4 = clock.videoTsToSeconds;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    /**\n     * Sum the `byteLength` properties of the data in each AAC frame\n     */\n\n    var sumFrameByteLengths = function sumFrameByteLengths(array) {\n      var i,\n          currentObj,\n          sum = 0; // sum the byteLength's all each nal unit in the frame\n\n      for (i = 0; i < array.length; i++) {\n        currentObj = array[i];\n        sum += currentObj.data.byteLength;\n      }\n\n      return sum;\n    }; // Possibly pad (prefix) the audio track with silence if appending this track\n    // would lead to the introduction of a gap in the audio buffer\n\n\n    var prefixWithSilence = function prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n      var baseMediaDecodeTimeTs,\n          frameDuration = 0,\n          audioGapDuration = 0,\n          audioFillFrameCount = 0,\n          audioFillDuration = 0,\n          silentFrame,\n          i,\n          firstFrame;\n\n      if (!frames.length) {\n        return;\n      }\n\n      baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n      frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n      if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n        // insert the shortest possible amount (audio gap or audio to video gap)\n        audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n        audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n        audioFillDuration = audioFillFrameCount * frameDuration;\n      } // don't attempt to fill gaps smaller than a single frame or larger\n      // than a half second\n\n\n      if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {\n        return;\n      }\n\n      silentFrame = silence_1()[track.samplerate];\n\n      if (!silentFrame) {\n        // we don't have a silent frame pregenerated for the sample rate, so use a frame\n        // from the content instead\n        silentFrame = frames[0].data;\n      }\n\n      for (i = 0; i < audioFillFrameCount; i++) {\n        firstFrame = frames[0];\n        frames.splice(0, 0, {\n          data: silentFrame,\n          dts: firstFrame.dts - frameDuration,\n          pts: firstFrame.pts - frameDuration\n        });\n      }\n\n      track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n    }; // If the audio segment extends before the earliest allowed dts\n    // value, remove AAC frames until starts at or after the earliest\n    // allowed DTS so that we don't end up with a negative baseMedia-\n    // DecodeTime for the audio track\n\n\n    var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts) {\n      if (track.minSegmentDts >= earliestAllowedDts) {\n        return adtsFrames;\n      } // We will need to recalculate the earliest segment Dts\n\n\n      track.minSegmentDts = Infinity;\n      return adtsFrames.filter(function (currentFrame) {\n        // If this is an allowed frame, keep it and record it's Dts\n        if (currentFrame.dts >= earliestAllowedDts) {\n          track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n          track.minSegmentPts = track.minSegmentDts;\n          return true;\n        } // Otherwise, discard it\n\n\n        return false;\n      });\n    }; // generate the track's raw mdat data from an array of frames\n\n\n    var generateSampleTable$1 = function generateSampleTable$1(frames) {\n      var i,\n          currentFrame,\n          samples = [];\n\n      for (i = 0; i < frames.length; i++) {\n        currentFrame = frames[i];\n        samples.push({\n          size: currentFrame.data.byteLength,\n          duration: 1024 // For AAC audio, all samples contain 1024 samples\n\n        });\n      }\n\n      return samples;\n    }; // generate the track's sample table from an array of frames\n\n\n    var concatenateFrameData = function concatenateFrameData(frames) {\n      var i,\n          currentFrame,\n          dataOffset = 0,\n          data = new Uint8Array(sumFrameByteLengths(frames));\n\n      for (i = 0; i < frames.length; i++) {\n        currentFrame = frames[i];\n        data.set(currentFrame.data, dataOffset);\n        dataOffset += currentFrame.data.byteLength;\n      }\n\n      return data;\n    };\n\n    var audioFrameUtils = {\n      prefixWithSilence: prefixWithSilence,\n      trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n      generateSampleTable: generateSampleTable$1,\n      concatenateFrameData: concatenateFrameData\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS;\n    /**\n     * Store information about the start and end of the track and the\n     * duration for each frame/sample we process in order to calculate\n     * the baseMediaDecodeTime\n     */\n\n    var collectDtsInfo = function collectDtsInfo(track, data) {\n      if (typeof data.pts === 'number') {\n        if (track.timelineStartInfo.pts === undefined) {\n          track.timelineStartInfo.pts = data.pts;\n        }\n\n        if (track.minSegmentPts === undefined) {\n          track.minSegmentPts = data.pts;\n        } else {\n          track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n        }\n\n        if (track.maxSegmentPts === undefined) {\n          track.maxSegmentPts = data.pts;\n        } else {\n          track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n        }\n      }\n\n      if (typeof data.dts === 'number') {\n        if (track.timelineStartInfo.dts === undefined) {\n          track.timelineStartInfo.dts = data.dts;\n        }\n\n        if (track.minSegmentDts === undefined) {\n          track.minSegmentDts = data.dts;\n        } else {\n          track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n        }\n\n        if (track.maxSegmentDts === undefined) {\n          track.maxSegmentDts = data.dts;\n        } else {\n          track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n        }\n      }\n    };\n    /**\n     * Clear values used to calculate the baseMediaDecodeTime between\n     * tracks\n     */\n\n\n    var clearDtsInfo = function clearDtsInfo(track) {\n      delete track.minSegmentDts;\n      delete track.maxSegmentDts;\n      delete track.minSegmentPts;\n      delete track.maxSegmentPts;\n    };\n    /**\n     * Calculate the track's baseMediaDecodeTime based on the earliest\n     * DTS the transmuxer has ever seen and the minimum DTS for the\n     * current track\n     * @param track {object} track metadata configuration\n     * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n\n\n    var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {\n      var baseMediaDecodeTime,\n          scale,\n          minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n      if (!keepOriginalTimestamps) {\n        minSegmentDts -= track.timelineStartInfo.dts;\n      } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n      // we want the start of the first segment to be placed\n\n\n      baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n      baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n      baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n      if (track.type === 'audio') {\n        // Audio has a different clock equal to the sampling_rate so we need to\n        // scale the PTS values into the clock rate of the track\n        scale = track.samplerate / ONE_SECOND_IN_TS$1;\n        baseMediaDecodeTime *= scale;\n        baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n      }\n\n      return baseMediaDecodeTime;\n    };\n\n    var trackDecodeInfo = {\n      clearDtsInfo: clearDtsInfo,\n      calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n      collectDtsInfo: collectDtsInfo\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Reads in-band caption information from a video elementary\n     * stream. Captions must follow the CEA-708 standard for injection\n     * into an MPEG-2 transport streams.\n     * @see https://en.wikipedia.org/wiki/CEA-708\n     * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n     */\n    // Supplemental enhancement information (SEI) NAL units have a\n    // payload type field to indicate how they are to be\n    // interpreted. CEAS-708 caption content is always transmitted with\n    // payload type 0x04.\n\n    var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n        RBSP_TRAILING_BITS = 128;\n    /**\n      * Parse a supplemental enhancement information (SEI) NAL unit.\n      * Stops parsing once a message of type ITU T T35 has been found.\n      *\n      * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n      * @return {object} the parsed SEI payload\n      * @see Rec. ITU-T H.264, 7.3.2.3.1\n      */\n\n    var parseSei = function parseSei(bytes) {\n      var i = 0,\n          result = {\n        payloadType: -1,\n        payloadSize: 0\n      },\n          payloadType = 0,\n          payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n      while (i < bytes.byteLength) {\n        // stop once we have hit the end of the sei_rbsp\n        if (bytes[i] === RBSP_TRAILING_BITS) {\n          break;\n        } // Parse payload type\n\n\n        while (bytes[i] === 0xFF) {\n          payloadType += 255;\n          i++;\n        }\n\n        payloadType += bytes[i++]; // Parse payload size\n\n        while (bytes[i] === 0xFF) {\n          payloadSize += 255;\n          i++;\n        }\n\n        payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n        // there can only ever be one caption message in a frame's sei\n\n        if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n          var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n\n          if (userIdentifier === 'GA94') {\n            result.payloadType = payloadType;\n            result.payloadSize = payloadSize;\n            result.payload = bytes.subarray(i, i + payloadSize);\n            break;\n          } else {\n            result.payload = void 0;\n          }\n        } // skip the payload and parse the next message\n\n\n        i += payloadSize;\n        payloadType = 0;\n        payloadSize = 0;\n      }\n\n      return result;\n    }; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n\n    var parseUserData = function parseUserData(sei) {\n      // itu_t_t35_contry_code must be 181 (United States) for\n      // captions\n      if (sei.payload[0] !== 181) {\n        return null;\n      } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n\n      if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n        return null;\n      } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n\n      if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n        return null;\n      } // finally, user_data_type_code should be 0x03 for caption data\n\n\n      if (sei.payload[7] !== 0x03) {\n        return null;\n      } // return the user_data_type_structure and strip the trailing\n      // marker bits\n\n\n      return sei.payload.subarray(8, sei.payload.length - 1);\n    }; // see CEA-708-D, section 4.4\n\n\n    var parseCaptionPackets = function parseCaptionPackets(pts, userData) {\n      var results = [],\n          i,\n          count,\n          offset,\n          data; // if this is just filler, return immediately\n\n      if (!(userData[0] & 0x40)) {\n        return results;\n      } // parse out the cc_data_1 and cc_data_2 fields\n\n\n      count = userData[0] & 0x1f;\n\n      for (i = 0; i < count; i++) {\n        offset = i * 3;\n        data = {\n          type: userData[offset + 2] & 0x03,\n          pts: pts\n        }; // capture cc data when cc_valid is 1\n\n        if (userData[offset + 2] & 0x04) {\n          data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n          results.push(data);\n        }\n      }\n\n      return results;\n    };\n\n    var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n      var length = data.byteLength,\n          emulationPreventionBytesPositions = [],\n          i = 1,\n          newLength,\n          newData; // Find all `Emulation Prevention Bytes`\n\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          emulationPreventionBytesPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      } // If no Emulation Prevention Bytes were found just return the original\n      // array\n\n\n      if (emulationPreventionBytesPositions.length === 0) {\n        return data;\n      } // Create a new array to hold the NAL unit data\n\n\n      newLength = length - emulationPreventionBytesPositions.length;\n      newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === emulationPreventionBytesPositions[0]) {\n          // Skip this byte\n          sourceIndex++; // Remove this position index\n\n          emulationPreventionBytesPositions.shift();\n        }\n\n        newData[i] = data[sourceIndex];\n      }\n\n      return newData;\n    }; // exports\n\n\n    var captionPacketParser = {\n      parseSei: parseSei,\n      parseUserData: parseUserData,\n      parseCaptionPackets: parseCaptionPackets,\n      discardEmulationPreventionBytes: discardEmulationPreventionBytes,\n      USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n    }; // -----------------\n    // Link To Transport\n    // -----------------\n\n    var CaptionStream = function CaptionStream() {\n      CaptionStream.prototype.init.call(this);\n      this.captionPackets_ = [];\n      this.ccStreams_ = [new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n      new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n      new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n      new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n      ];\n      this.reset(); // forward data and done events from CCs to this CaptionStream\n\n      this.ccStreams_.forEach(function (cc) {\n        cc.on('data', this.trigger.bind(this, 'data'));\n        cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n        cc.on('done', this.trigger.bind(this, 'done'));\n      }, this);\n    };\n\n    CaptionStream.prototype = new stream();\n\n    CaptionStream.prototype.push = function (event) {\n      var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n      if (event.nalUnitType !== 'sei_rbsp') {\n        return;\n      } // parse the sei\n\n\n      sei = captionPacketParser.parseSei(event.escapedRBSP); // ignore everything but user_data_registered_itu_t_t35\n\n      if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {\n        return;\n      } // parse out the user data payload\n\n\n      userData = captionPacketParser.parseUserData(sei); // ignore unrecognized userData\n\n      if (!userData) {\n        return;\n      } // Sometimes, the same segment # will be downloaded twice. To stop the\n      // caption data from being processed twice, we track the latest dts we've\n      // received and ignore everything with a dts before that. However, since\n      // data for a specific dts can be split across packets on either side of\n      // a segment boundary, we need to make sure we *don't* ignore the packets\n      // from the *next* segment that have dts === this.latestDts_. By constantly\n      // tracking the number of packets received with dts === this.latestDts_, we\n      // know how many should be ignored once we start receiving duplicates.\n\n\n      if (event.dts < this.latestDts_) {\n        // We've started getting older data, so set the flag.\n        this.ignoreNextEqualDts_ = true;\n        return;\n      } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n        this.numSameDts_--;\n\n        if (!this.numSameDts_) {\n          // We've received the last duplicate packet, time to start processing again\n          this.ignoreNextEqualDts_ = false;\n        }\n\n        return;\n      } // parse out CC data packets and save them for later\n\n\n      newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);\n      this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n\n      if (this.latestDts_ !== event.dts) {\n        this.numSameDts_ = 0;\n      }\n\n      this.numSameDts_++;\n      this.latestDts_ = event.dts;\n    };\n\n    CaptionStream.prototype.flushCCStreams = function (flushType) {\n      this.ccStreams_.forEach(function (cc) {\n        return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n      }, this);\n    };\n\n    CaptionStream.prototype.flushStream = function (flushType) {\n      // make sure we actually parsed captions before proceeding\n      if (!this.captionPackets_.length) {\n        this.flushCCStreams(flushType);\n        return;\n      } // In Chrome, the Array#sort function is not stable so add a\n      // presortIndex that we can use to ensure we get a stable-sort\n\n\n      this.captionPackets_.forEach(function (elem, idx) {\n        elem.presortIndex = idx;\n      }); // sort caption byte-pairs based on their PTS values\n\n      this.captionPackets_.sort(function (a, b) {\n        if (a.pts === b.pts) {\n          return a.presortIndex - b.presortIndex;\n        }\n\n        return a.pts - b.pts;\n      });\n      this.captionPackets_.forEach(function (packet) {\n        if (packet.type < 2) {\n          // Dispatch packet to the right Cea608Stream\n          this.dispatchCea608Packet(packet);\n        } // this is where an 'else' would go for a dispatching packets\n        // to a theoretical Cea708Stream that handles SERVICEn data\n\n      }, this);\n      this.captionPackets_.length = 0;\n      this.flushCCStreams(flushType);\n    };\n\n    CaptionStream.prototype.flush = function () {\n      return this.flushStream('flush');\n    }; // Only called if handling partial data\n\n\n    CaptionStream.prototype.partialFlush = function () {\n      return this.flushStream('partialFlush');\n    };\n\n    CaptionStream.prototype.reset = function () {\n      this.latestDts_ = null;\n      this.ignoreNextEqualDts_ = false;\n      this.numSameDts_ = 0;\n      this.activeCea608Channel_ = [null, null];\n      this.ccStreams_.forEach(function (ccStream) {\n        ccStream.reset();\n      });\n    }; // From the CEA-608 spec:\n\n    /*\n     * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n     * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n     * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n     * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n     * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n     * to switch to captioning or Text.\n    */\n    // With that in mind, we ignore any data between an XDS control code and a\n    // subsequent closed-captioning control code.\n\n\n    CaptionStream.prototype.dispatchCea608Packet = function (packet) {\n      // NOTE: packet.type is the CEA608 field\n      if (this.setsTextOrXDSActive(packet)) {\n        this.activeCea608Channel_[packet.type] = null;\n      } else if (this.setsChannel1Active(packet)) {\n        this.activeCea608Channel_[packet.type] = 0;\n      } else if (this.setsChannel2Active(packet)) {\n        this.activeCea608Channel_[packet.type] = 1;\n      }\n\n      if (this.activeCea608Channel_[packet.type] === null) {\n        // If we haven't received anything to set the active channel, or the\n        // packets are Text/XDS data, discard the data; we don't want jumbled\n        // captions\n        return;\n      }\n\n      this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n    };\n\n    CaptionStream.prototype.setsChannel1Active = function (packet) {\n      return (packet.ccData & 0x7800) === 0x1000;\n    };\n\n    CaptionStream.prototype.setsChannel2Active = function (packet) {\n      return (packet.ccData & 0x7800) === 0x1800;\n    };\n\n    CaptionStream.prototype.setsTextOrXDSActive = function (packet) {\n      return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n    }; // ----------------------\n    // Session to Application\n    // ----------------------\n    // This hash maps non-ASCII, special, and extended character codes to their\n    // proper Unicode equivalent. The first keys that are only a single byte\n    // are the non-standard ASCII characters, which simply map the CEA608 byte\n    // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n    // character codes, but have their MSB bitmasked with 0x03 so that a lookup\n    // can be performed regardless of the field and data channel on which the\n    // character code was received.\n\n\n    var CHARACTER_TRANSLATION = {\n      0x2a: 0xe1,\n      // á\n      0x5c: 0xe9,\n      // é\n      0x5e: 0xed,\n      // í\n      0x5f: 0xf3,\n      // ó\n      0x60: 0xfa,\n      // ú\n      0x7b: 0xe7,\n      // ç\n      0x7c: 0xf7,\n      // ÷\n      0x7d: 0xd1,\n      // Ñ\n      0x7e: 0xf1,\n      // ñ\n      0x7f: 0x2588,\n      // █\n      0x0130: 0xae,\n      // ®\n      0x0131: 0xb0,\n      // °\n      0x0132: 0xbd,\n      // ½\n      0x0133: 0xbf,\n      // ¿\n      0x0134: 0x2122,\n      // ™\n      0x0135: 0xa2,\n      // ¢\n      0x0136: 0xa3,\n      // £\n      0x0137: 0x266a,\n      // ♪\n      0x0138: 0xe0,\n      // à\n      0x0139: 0xa0,\n      //\n      0x013a: 0xe8,\n      // è\n      0x013b: 0xe2,\n      // â\n      0x013c: 0xea,\n      // ê\n      0x013d: 0xee,\n      // î\n      0x013e: 0xf4,\n      // ô\n      0x013f: 0xfb,\n      // û\n      0x0220: 0xc1,\n      // Á\n      0x0221: 0xc9,\n      // É\n      0x0222: 0xd3,\n      // Ó\n      0x0223: 0xda,\n      // Ú\n      0x0224: 0xdc,\n      // Ü\n      0x0225: 0xfc,\n      // ü\n      0x0226: 0x2018,\n      // ‘\n      0x0227: 0xa1,\n      // ¡\n      0x0228: 0x2a,\n      // *\n      0x0229: 0x27,\n      // '\n      0x022a: 0x2014,\n      // —\n      0x022b: 0xa9,\n      // ©\n      0x022c: 0x2120,\n      // ℠\n      0x022d: 0x2022,\n      // •\n      0x022e: 0x201c,\n      // “\n      0x022f: 0x201d,\n      // ”\n      0x0230: 0xc0,\n      // À\n      0x0231: 0xc2,\n      // Â\n      0x0232: 0xc7,\n      // Ç\n      0x0233: 0xc8,\n      // È\n      0x0234: 0xca,\n      // Ê\n      0x0235: 0xcb,\n      // Ë\n      0x0236: 0xeb,\n      // ë\n      0x0237: 0xce,\n      // Î\n      0x0238: 0xcf,\n      // Ï\n      0x0239: 0xef,\n      // ï\n      0x023a: 0xd4,\n      // Ô\n      0x023b: 0xd9,\n      // Ù\n      0x023c: 0xf9,\n      // ù\n      0x023d: 0xdb,\n      // Û\n      0x023e: 0xab,\n      // «\n      0x023f: 0xbb,\n      // »\n      0x0320: 0xc3,\n      // Ã\n      0x0321: 0xe3,\n      // ã\n      0x0322: 0xcd,\n      // Í\n      0x0323: 0xcc,\n      // Ì\n      0x0324: 0xec,\n      // ì\n      0x0325: 0xd2,\n      // Ò\n      0x0326: 0xf2,\n      // ò\n      0x0327: 0xd5,\n      // Õ\n      0x0328: 0xf5,\n      // õ\n      0x0329: 0x7b,\n      // {\n      0x032a: 0x7d,\n      // }\n      0x032b: 0x5c,\n      // \\\n      0x032c: 0x5e,\n      // ^\n      0x032d: 0x5f,\n      // _\n      0x032e: 0x7c,\n      // |\n      0x032f: 0x7e,\n      // ~\n      0x0330: 0xc4,\n      // Ä\n      0x0331: 0xe4,\n      // ä\n      0x0332: 0xd6,\n      // Ö\n      0x0333: 0xf6,\n      // ö\n      0x0334: 0xdf,\n      // ß\n      0x0335: 0xa5,\n      // ¥\n      0x0336: 0xa4,\n      // ¤\n      0x0337: 0x2502,\n      // │\n      0x0338: 0xc5,\n      // Å\n      0x0339: 0xe5,\n      // å\n      0x033a: 0xd8,\n      // Ø\n      0x033b: 0xf8,\n      // ø\n      0x033c: 0x250c,\n      // ┌\n      0x033d: 0x2510,\n      // ┐\n      0x033e: 0x2514,\n      // └\n      0x033f: 0x2518 // ┘\n\n    };\n\n    var getCharFromCode = function getCharFromCode(code) {\n      if (code === null) {\n        return '';\n      }\n\n      code = CHARACTER_TRANSLATION[code] || code;\n      return String.fromCharCode(code);\n    }; // the index of the last row in a CEA-608 display buffer\n\n\n    var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n    // getting it through bit logic.\n\n    var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n    // cells. The \"bottom\" row is the last element in the outer array.\n\n    var createDisplayBuffer = function createDisplayBuffer() {\n      var result = [],\n          i = BOTTOM_ROW + 1;\n\n      while (i--) {\n        result.push('');\n      }\n\n      return result;\n    };\n\n    var Cea608Stream = function Cea608Stream(field, dataChannel) {\n      Cea608Stream.prototype.init.call(this);\n      this.field_ = field || 0;\n      this.dataChannel_ = dataChannel || 0;\n      this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n      this.setConstants();\n      this.reset();\n\n      this.push = function (packet) {\n        var data, swap, char0, char1, text; // remove the parity bits\n\n        data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n        if (data === this.lastControlCode_) {\n          this.lastControlCode_ = null;\n          return;\n        } // Store control codes\n\n\n        if ((data & 0xf000) === 0x1000) {\n          this.lastControlCode_ = data;\n        } else if (data !== this.PADDING_) {\n          this.lastControlCode_ = null;\n        }\n\n        char0 = data >>> 8;\n        char1 = data & 0xff;\n\n        if (data === this.PADDING_) {\n          return;\n        } else if (data === this.RESUME_CAPTION_LOADING_) {\n          this.mode_ = 'popOn';\n        } else if (data === this.END_OF_CAPTION_) {\n          // If an EOC is received while in paint-on mode, the displayed caption\n          // text should be swapped to non-displayed memory as if it was a pop-on\n          // caption. Because of that, we should explicitly switch back to pop-on\n          // mode\n          this.mode_ = 'popOn';\n          this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n          this.flushDisplayed(packet.pts); // flip memory\n\n          swap = this.displayed_;\n          this.displayed_ = this.nonDisplayed_;\n          this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n          this.startPts_ = packet.pts;\n        } else if (data === this.ROLL_UP_2_ROWS_) {\n          this.rollUpRows_ = 2;\n          this.setRollUp(packet.pts);\n        } else if (data === this.ROLL_UP_3_ROWS_) {\n          this.rollUpRows_ = 3;\n          this.setRollUp(packet.pts);\n        } else if (data === this.ROLL_UP_4_ROWS_) {\n          this.rollUpRows_ = 4;\n          this.setRollUp(packet.pts);\n        } else if (data === this.CARRIAGE_RETURN_) {\n          this.clearFormatting(packet.pts);\n          this.flushDisplayed(packet.pts);\n          this.shiftRowsUp_();\n          this.startPts_ = packet.pts;\n        } else if (data === this.BACKSPACE_) {\n          if (this.mode_ === 'popOn') {\n            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n          } else {\n            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n          }\n        } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n          this.flushDisplayed(packet.pts);\n          this.displayed_ = createDisplayBuffer();\n        } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n          this.nonDisplayed_ = createDisplayBuffer();\n        } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n          if (this.mode_ !== 'paintOn') {\n            // NOTE: This should be removed when proper caption positioning is\n            // implemented\n            this.flushDisplayed(packet.pts);\n            this.displayed_ = createDisplayBuffer();\n          }\n\n          this.mode_ = 'paintOn';\n          this.startPts_ = packet.pts; // Append special characters to caption text\n        } else if (this.isSpecialCharacter(char0, char1)) {\n          // Bitmask char0 so that we can apply character transformations\n          // regardless of field and data channel.\n          // Then byte-shift to the left and OR with char1 so we can pass the\n          // entire character code to `getCharFromCode`.\n          char0 = (char0 & 0x03) << 8;\n          text = getCharFromCode(char0 | char1);\n          this[this.mode_](packet.pts, text);\n          this.column_++; // Append extended characters to caption text\n        } else if (this.isExtCharacter(char0, char1)) {\n          // Extended characters always follow their \"non-extended\" equivalents.\n          // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n          // decoders are supposed to drop the \"è\", while compliant decoders\n          // backspace the \"e\" and insert \"è\".\n          // Delete the previous character\n          if (this.mode_ === 'popOn') {\n            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n          } else {\n            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n          } // Bitmask char0 so that we can apply character transformations\n          // regardless of field and data channel.\n          // Then byte-shift to the left and OR with char1 so we can pass the\n          // entire character code to `getCharFromCode`.\n\n\n          char0 = (char0 & 0x03) << 8;\n          text = getCharFromCode(char0 | char1);\n          this[this.mode_](packet.pts, text);\n          this.column_++; // Process mid-row codes\n        } else if (this.isMidRowCode(char0, char1)) {\n          // Attributes are not additive, so clear all formatting\n          this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n          // should be replaced with spaces, so add one now\n\n          this[this.mode_](packet.pts, ' ');\n          this.column_++;\n\n          if ((char1 & 0xe) === 0xe) {\n            this.addFormatting(packet.pts, ['i']);\n          }\n\n          if ((char1 & 0x1) === 0x1) {\n            this.addFormatting(packet.pts, ['u']);\n          } // Detect offset control codes and adjust cursor\n\n        } else if (this.isOffsetControlCode(char0, char1)) {\n          // Cursor position is set by indent PAC (see below) in 4-column\n          // increments, with an additional offset code of 1-3 to reach any\n          // of the 32 columns specified by CEA-608. So all we need to do\n          // here is increment the column cursor by the given offset.\n          this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\n        } else if (this.isPAC(char0, char1)) {\n          // There's no logic for PAC -> row mapping, so we have to just\n          // find the row code in an array and use its index :(\n          var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n          if (this.mode_ === 'rollUp') {\n            // This implies that the base row is incorrectly set.\n            // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n            // of roll-up rows set.\n            if (row - this.rollUpRows_ + 1 < 0) {\n              row = this.rollUpRows_ - 1;\n            }\n\n            this.setRollUp(packet.pts, row);\n          }\n\n          if (row !== this.row_) {\n            // formatting is only persistent for current row\n            this.clearFormatting(packet.pts);\n            this.row_ = row;\n          } // All PACs can apply underline, so detect and apply\n          // (All odd-numbered second bytes set underline)\n\n\n          if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n            this.addFormatting(packet.pts, ['u']);\n          }\n\n          if ((data & 0x10) === 0x10) {\n            // We've got an indent level code. Each successive even number\n            // increments the column cursor by 4, so we can get the desired\n            // column position by bit-shifting to the right (to get n/2)\n            // and multiplying by 4.\n            this.column_ = ((data & 0xe) >> 1) * 4;\n          }\n\n          if (this.isColorPAC(char1)) {\n            // it's a color code, though we only support white, which\n            // can be either normal or italicized. white italics can be\n            // either 0x4e or 0x6e depending on the row, so we just\n            // bitwise-and with 0xe to see if italics should be turned on\n            if ((char1 & 0xe) === 0xe) {\n              this.addFormatting(packet.pts, ['i']);\n            }\n          } // We have a normal character in char0, and possibly one in char1\n\n        } else if (this.isNormalChar(char0)) {\n          if (char1 === 0x00) {\n            char1 = null;\n          }\n\n          text = getCharFromCode(char0);\n          text += getCharFromCode(char1);\n          this[this.mode_](packet.pts, text);\n          this.column_ += text.length;\n        } // finish data processing\n\n      };\n    };\n\n    Cea608Stream.prototype = new stream(); // Trigger a cue point that captures the current state of the\n    // display buffer\n\n    Cea608Stream.prototype.flushDisplayed = function (pts) {\n      var content = this.displayed_ // remove spaces from the start and end of the string\n      .map(function (row) {\n        try {\n          return row.trim();\n        } catch (e) {\n          // Ordinarily, this shouldn't happen. However, caption\n          // parsing errors should not throw exceptions and\n          // break playback.\n          // eslint-disable-next-line no-console\n          console.error('Skipping malformed caption.');\n          return '';\n        }\n      }) // combine all text rows to display in one cue\n      .join('\\n') // and remove blank rows from the start and end, but not the middle\n      .replace(/^\\n+|\\n+$/g, '');\n\n      if (content.length) {\n        this.trigger('data', {\n          startPts: this.startPts_,\n          endPts: pts,\n          text: content,\n          stream: this.name_\n        });\n      }\n    };\n    /**\n     * Zero out the data, used for startup and on seek\n     */\n\n\n    Cea608Stream.prototype.reset = function () {\n      this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n      // actually display captions. If a caption is shifted to a row\n      // with a lower index than this, it is cleared from the display\n      // buffer\n\n      this.topRow_ = 0;\n      this.startPts_ = 0;\n      this.displayed_ = createDisplayBuffer();\n      this.nonDisplayed_ = createDisplayBuffer();\n      this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n      this.column_ = 0;\n      this.row_ = BOTTOM_ROW;\n      this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n      this.formatting_ = [];\n    };\n    /**\n     * Sets up control code and related constants for this instance\n     */\n\n\n    Cea608Stream.prototype.setConstants = function () {\n      // The following attributes have these uses:\n      // ext_ :    char0 for mid-row codes, and the base for extended\n      //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n      //           extended codes)\n      // control_: char0 for control codes, except byte-shifted to the\n      //           left so that we can do this.control_ | CONTROL_CODE\n      // offset_:  char0 for tab offset codes\n      //\n      // It's also worth noting that control codes, and _only_ control codes,\n      // differ between field 1 and field2. Field 2 control codes are always\n      // their field 1 value plus 1. That's why there's the \"| field\" on the\n      // control value.\n      if (this.dataChannel_ === 0) {\n        this.BASE_ = 0x10;\n        this.EXT_ = 0x11;\n        this.CONTROL_ = (0x14 | this.field_) << 8;\n        this.OFFSET_ = 0x17;\n      } else if (this.dataChannel_ === 1) {\n        this.BASE_ = 0x18;\n        this.EXT_ = 0x19;\n        this.CONTROL_ = (0x1c | this.field_) << 8;\n        this.OFFSET_ = 0x1f;\n      } // Constants for the LSByte command codes recognized by Cea608Stream. This\n      // list is not exhaustive. For a more comprehensive listing and semantics see\n      // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n      // Padding\n\n\n      this.PADDING_ = 0x0000; // Pop-on Mode\n\n      this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n      this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n      this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n      this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n      this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n      this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n      this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n      this.BACKSPACE_ = this.CONTROL_ | 0x21;\n      this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n      this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n    };\n    /**\n     * Detects if the 2-byte packet data is a special character\n     *\n     * Special characters have a second byte in the range 0x30 to 0x3f,\n     * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n     * data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an special character\n     */\n\n\n    Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n      return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n    };\n    /**\n     * Detects if the 2-byte packet data is an extended character\n     *\n     * Extended characters have a second byte in the range 0x20 to 0x3f,\n     * with the first byte being 0x12 or 0x13 (for data channel 1) or\n     * 0x1a or 0x1b (for data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an extended character\n     */\n\n\n    Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n      return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n    };\n    /**\n     * Detects if the 2-byte packet is a mid-row code\n     *\n     * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n     * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n     * channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are a mid-row code\n     */\n\n\n    Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n      return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n    };\n    /**\n     * Detects if the 2-byte packet is an offset control code\n     *\n     * Offset control codes have a second byte in the range 0x21 to 0x23,\n     * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n     * data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an offset control code\n     */\n\n\n    Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n      return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n    };\n    /**\n     * Detects if the 2-byte packet is a Preamble Address Code\n     *\n     * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n     * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n     * range 0x40 to 0x7f.\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are a PAC\n     */\n\n\n    Cea608Stream.prototype.isPAC = function (char0, char1) {\n      return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n    };\n    /**\n     * Detects if a packet's second byte is in the range of a PAC color code\n     *\n     * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n     * 0x60 to 0x6f.\n     *\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the byte is a color PAC\n     */\n\n\n    Cea608Stream.prototype.isColorPAC = function (char1) {\n      return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n    };\n    /**\n     * Detects if a single byte is in the range of a normal character\n     *\n     * Normal text bytes are in the range 0x20 to 0x7f.\n     *\n     * @param  {Integer} char  The byte\n     * @return {Boolean}       Whether the byte is a normal character\n     */\n\n\n    Cea608Stream.prototype.isNormalChar = function (_char) {\n      return _char >= 0x20 && _char <= 0x7f;\n    };\n    /**\n     * Configures roll-up\n     *\n     * @param  {Integer} pts         Current PTS\n     * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n     *                               a new position\n     */\n\n\n    Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n      // Reset the base row to the bottom row when switching modes\n      if (this.mode_ !== 'rollUp') {\n        this.row_ = BOTTOM_ROW;\n        this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n        this.flushDisplayed(pts);\n        this.nonDisplayed_ = createDisplayBuffer();\n        this.displayed_ = createDisplayBuffer();\n      }\n\n      if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n        // move currently displayed captions (up or down) to the new base row\n        for (var i = 0; i < this.rollUpRows_; i++) {\n          this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n          this.displayed_[this.row_ - i] = '';\n        }\n      }\n\n      if (newBaseRow === undefined) {\n        newBaseRow = this.row_;\n      }\n\n      this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n    }; // Adds the opening HTML tag for the passed character to the caption text,\n    // and keeps track of it for later closing\n\n\n    Cea608Stream.prototype.addFormatting = function (pts, format) {\n      this.formatting_ = this.formatting_.concat(format);\n      var text = format.reduce(function (text, format) {\n        return text + '<' + format + '>';\n      }, '');\n      this[this.mode_](pts, text);\n    }; // Adds HTML closing tags for current formatting to caption text and\n    // clears remembered formatting\n\n\n    Cea608Stream.prototype.clearFormatting = function (pts) {\n      if (!this.formatting_.length) {\n        return;\n      }\n\n      var text = this.formatting_.reverse().reduce(function (text, format) {\n        return text + '</' + format + '>';\n      }, '');\n      this.formatting_ = [];\n      this[this.mode_](pts, text);\n    }; // Mode Implementations\n\n\n    Cea608Stream.prototype.popOn = function (pts, text) {\n      var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\n\n      baseRow += text;\n      this.nonDisplayed_[this.row_] = baseRow;\n    };\n\n    Cea608Stream.prototype.rollUp = function (pts, text) {\n      var baseRow = this.displayed_[this.row_];\n      baseRow += text;\n      this.displayed_[this.row_] = baseRow;\n    };\n\n    Cea608Stream.prototype.shiftRowsUp_ = function () {\n      var i; // clear out inactive rows\n\n      for (i = 0; i < this.topRow_; i++) {\n        this.displayed_[i] = '';\n      }\n\n      for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n        this.displayed_[i] = '';\n      } // shift displayed rows up\n\n\n      for (i = this.topRow_; i < this.row_; i++) {\n        this.displayed_[i] = this.displayed_[i + 1];\n      } // clear out the bottom row\n\n\n      this.displayed_[this.row_] = '';\n    };\n\n    Cea608Stream.prototype.paintOn = function (pts, text) {\n      var baseRow = this.displayed_[this.row_];\n      baseRow += text;\n      this.displayed_[this.row_] = baseRow;\n    }; // exports\n\n\n    var captionStream = {\n      CaptionStream: CaptionStream,\n      Cea608Stream: Cea608Stream\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var streamTypes = {\n      H264_STREAM_TYPE: 0x1B,\n      ADTS_STREAM_TYPE: 0x0F,\n      METADATA_STREAM_TYPE: 0x15\n    };\n    var MAX_TS = 8589934592;\n    var RO_THRESH = 4294967296;\n    var TYPE_SHARED = 'shared';\n\n    var handleRollover = function handleRollover(value, reference) {\n      var direction = 1;\n\n      if (value > reference) {\n        // If the current timestamp value is greater than our reference timestamp and we detect a\n        // timestamp rollover, this means the roll over is happening in the opposite direction.\n        // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n        // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n        // rollover point. In loading this segment, the timestamp values will be very large,\n        // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n        // the time stamp to be `value - 2^33`.\n        direction = -1;\n      } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n      // cause an incorrect adjustment.\n\n\n      while (Math.abs(reference - value) > RO_THRESH) {\n        value += direction * MAX_TS;\n      }\n\n      return value;\n    };\n\n    var TimestampRolloverStream = function TimestampRolloverStream(type) {\n      var lastDTS, referenceDTS;\n      TimestampRolloverStream.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n      // video and audio. We could use `undefined` here, but having a string\n      // makes debugging a little clearer.\n\n      this.type_ = type || TYPE_SHARED;\n\n      this.push = function (data) {\n        // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n        // streams will only accept data that matches their type.\n        if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n          return;\n        }\n\n        if (referenceDTS === undefined) {\n          referenceDTS = data.dts;\n        }\n\n        data.dts = handleRollover(data.dts, referenceDTS);\n        data.pts = handleRollover(data.pts, referenceDTS);\n        lastDTS = data.dts;\n        this.trigger('data', data);\n      };\n\n      this.flush = function () {\n        referenceDTS = lastDTS;\n        this.trigger('done');\n      };\n\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline');\n      };\n\n      this.discontinuity = function () {\n        referenceDTS = void 0;\n        lastDTS = void 0;\n      };\n\n      this.reset = function () {\n        this.discontinuity();\n        this.trigger('reset');\n      };\n    };\n\n    TimestampRolloverStream.prototype = new stream();\n    var timestampRolloverStream = {\n      TimestampRolloverStream: TimestampRolloverStream,\n      handleRollover: handleRollover\n    };\n\n    var percentEncode = function percentEncode(bytes, start, end) {\n      var i,\n          result = '';\n\n      for (i = start; i < end; i++) {\n        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n      }\n\n      return result;\n    },\n        // return the string representation of the specified byte range,\n    // interpreted as UTf-8.\n    parseUtf8 = function parseUtf8(bytes, start, end) {\n      return decodeURIComponent(percentEncode(bytes, start, end));\n    },\n        // return the string representation of the specified byte range,\n    // interpreted as ISO-8859-1.\n    parseIso88591 = function parseIso88591(bytes, start, end) {\n      return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n    },\n        parseSyncSafeInteger = function parseSyncSafeInteger(data) {\n      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n    },\n        tagParsers = {\n      TXXX: function TXXX(tag) {\n        var i;\n\n        if (tag.data[0] !== 3) {\n          // ignore frames with unrecognized character encodings\n          return;\n        }\n\n        for (i = 1; i < tag.data.length; i++) {\n          if (tag.data[i] === 0) {\n            // parse the text fields\n            tag.description = parseUtf8(tag.data, 1, i); // do not include the null terminator in the tag value\n\n            tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n            break;\n          }\n        }\n\n        tag.data = tag.value;\n      },\n      WXXX: function WXXX(tag) {\n        var i;\n\n        if (tag.data[0] !== 3) {\n          // ignore frames with unrecognized character encodings\n          return;\n        }\n\n        for (i = 1; i < tag.data.length; i++) {\n          if (tag.data[i] === 0) {\n            // parse the description and URL fields\n            tag.description = parseUtf8(tag.data, 1, i);\n            tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n            break;\n          }\n        }\n      },\n      PRIV: function PRIV(tag) {\n        var i;\n\n        for (i = 0; i < tag.data.length; i++) {\n          if (tag.data[i] === 0) {\n            // parse the description and URL fields\n            tag.owner = parseIso88591(tag.data, 0, i);\n            break;\n          }\n        }\n\n        tag.privateData = tag.data.subarray(i + 1);\n        tag.data = tag.privateData;\n      }\n    },\n        _MetadataStream;\n\n    _MetadataStream = function MetadataStream(options) {\n      var settings = {\n        debug: !!(options && options.debug),\n        // the bytes of the program-level descriptor field in MP2T\n        // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n        // program element descriptors\"\n        descriptor: options && options.descriptor\n      },\n          // the total size in bytes of the ID3 tag being parsed\n      tagSize = 0,\n          // tag data that is not complete enough to be parsed\n      buffer = [],\n          // the total number of bytes currently in the buffer\n      bufferSize = 0,\n          i;\n\n      _MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n      // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n\n      this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);\n\n      if (settings.descriptor) {\n        for (i = 0; i < settings.descriptor.length; i++) {\n          this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n        }\n      }\n\n      this.push = function (chunk) {\n        var tag, frameStart, frameSize, frame, i, frameHeader;\n\n        if (chunk.type !== 'timed-metadata') {\n          return;\n        } // if data_alignment_indicator is set in the PES header,\n        // we must have the start of a new ID3 tag. Assume anything\n        // remaining in the buffer was malformed and throw it out\n\n\n        if (chunk.dataAlignmentIndicator) {\n          bufferSize = 0;\n          buffer.length = 0;\n        } // ignore events that don't look like ID3 data\n\n\n        if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n          if (settings.debug) {\n            // eslint-disable-next-line no-console\n            console.log('Skipping unrecognized metadata packet');\n          }\n\n          return;\n        } // add this chunk to the data we've collected so far\n\n\n        buffer.push(chunk);\n        bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n        if (buffer.length === 1) {\n          // the frame size is transmitted as a 28-bit integer in the\n          // last four bytes of the ID3 header.\n          // The most significant bit of each byte is dropped and the\n          // results concatenated to recover the actual value.\n          tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n          // convenient for our comparisons to include it\n\n          tagSize += 10;\n        } // if the entire frame has not arrived, wait for more data\n\n\n        if (bufferSize < tagSize) {\n          return;\n        } // collect the entire frame so it can be parsed\n\n\n        tag = {\n          data: new Uint8Array(tagSize),\n          frames: [],\n          pts: buffer[0].pts,\n          dts: buffer[0].dts\n        };\n\n        for (i = 0; i < tagSize;) {\n          tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n          i += buffer[0].data.byteLength;\n          bufferSize -= buffer[0].data.byteLength;\n          buffer.shift();\n        } // find the start of the first frame and the end of the tag\n\n\n        frameStart = 10;\n\n        if (tag.data[5] & 0x40) {\n          // advance the frame start past the extended header\n          frameStart += 4; // header size field\n\n          frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14)); // clip any padding off the end\n\n          tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n        } // parse one or more ID3 frames\n        // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n        do {\n          // determine the number of bytes in this frame\n          frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n\n          if (frameSize < 1) {\n            // eslint-disable-next-line no-console\n            return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n          }\n\n          frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n          frame = {\n            id: frameHeader,\n            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n          };\n          frame.key = frame.id;\n\n          if (tagParsers[frame.id]) {\n            tagParsers[frame.id](frame); // handle the special PRIV frame used to indicate the start\n            // time for raw AAC data\n\n            if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n              var d = frame.data,\n                  size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n              size *= 4;\n              size += d[7] & 0x03;\n              frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n              // on the value of this frame\n              // we couldn't have known the appropriate pts and dts before\n              // parsing this ID3 tag so set those values now\n\n              if (tag.pts === undefined && tag.dts === undefined) {\n                tag.pts = frame.timeStamp;\n                tag.dts = frame.timeStamp;\n              }\n\n              this.trigger('timestamp', frame);\n            }\n          }\n\n          tag.frames.push(frame);\n          frameStart += 10; // advance past the frame header\n\n          frameStart += frameSize; // advance past the frame body\n        } while (frameStart < tagSize);\n\n        this.trigger('data', tag);\n      };\n    };\n\n    _MetadataStream.prototype = new stream();\n    var metadataStream = _MetadataStream;\n    var TimestampRolloverStream$1 = timestampRolloverStream.TimestampRolloverStream; // object types\n\n    var _TransportPacketStream, _TransportParseStream, _ElementaryStream; // constants\n\n\n    var MP2T_PACKET_LENGTH = 188,\n        // bytes\n    SYNC_BYTE = 0x47;\n    /**\n     * Splits an incoming stream of binary data into MPEG-2 Transport\n     * Stream packets.\n     */\n\n    _TransportPacketStream = function TransportPacketStream() {\n      var buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n          bytesInBuffer = 0;\n\n      _TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n      /**\n       * Split a stream of data into M2TS packets\n      **/\n\n\n      this.push = function (bytes) {\n        var startIndex = 0,\n            endIndex = MP2T_PACKET_LENGTH,\n            everything; // If there are bytes remaining from the last segment, prepend them to the\n        // bytes that were pushed in\n\n        if (bytesInBuffer) {\n          everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n          everything.set(buffer.subarray(0, bytesInBuffer));\n          everything.set(bytes, bytesInBuffer);\n          bytesInBuffer = 0;\n        } else {\n          everything = bytes;\n        } // While we have enough data for a packet\n\n\n        while (endIndex < everything.byteLength) {\n          // Look for a pair of start and end sync bytes in the data..\n          if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n            // We found a packet so emit it and jump one whole packet forward in\n            // the stream\n            this.trigger('data', everything.subarray(startIndex, endIndex));\n            startIndex += MP2T_PACKET_LENGTH;\n            endIndex += MP2T_PACKET_LENGTH;\n            continue;\n          } // If we get here, we have somehow become de-synchronized and we need to step\n          // forward one byte at a time until we find a pair of sync bytes that denote\n          // a packet\n\n\n          startIndex++;\n          endIndex++;\n        } // If there was some data left over at the end of the segment that couldn't\n        // possibly be a whole packet, keep it because it might be the start of a packet\n        // that continues in the next segment\n\n\n        if (startIndex < everything.byteLength) {\n          buffer.set(everything.subarray(startIndex), 0);\n          bytesInBuffer = everything.byteLength - startIndex;\n        }\n      };\n      /**\n       * Passes identified M2TS packets to the TransportParseStream to be parsed\n      **/\n\n\n      this.flush = function () {\n        // If the buffer contains a whole packet when we are being flushed, emit it\n        // and empty the buffer. Otherwise hold onto the data because it may be\n        // important for decoding the next segment\n        if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n          this.trigger('data', buffer);\n          bytesInBuffer = 0;\n        }\n\n        this.trigger('done');\n      };\n\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline');\n      };\n\n      this.reset = function () {\n        bytesInBuffer = 0;\n        this.trigger('reset');\n      };\n    };\n\n    _TransportPacketStream.prototype = new stream();\n    /**\n     * Accepts an MP2T TransportPacketStream and emits data events with parsed\n     * forms of the individual transport stream packets.\n     */\n\n    _TransportParseStream = function TransportParseStream() {\n      var parsePsi, parsePat, parsePmt, self;\n\n      _TransportParseStream.prototype.init.call(this);\n\n      self = this;\n      this.packetsWaitingForPmt = [];\n      this.programMapTable = undefined;\n\n      parsePsi = function parsePsi(payload, psi) {\n        var offset = 0; // PSI packets may be split into multiple sections and those\n        // sections may be split into multiple packets. If a PSI\n        // section starts in this packet, the payload_unit_start_indicator\n        // will be true and the first byte of the payload will indicate\n        // the offset from the current position to the start of the\n        // section.\n\n        if (psi.payloadUnitStartIndicator) {\n          offset += payload[offset] + 1;\n        }\n\n        if (psi.type === 'pat') {\n          parsePat(payload.subarray(offset), psi);\n        } else {\n          parsePmt(payload.subarray(offset), psi);\n        }\n      };\n\n      parsePat = function parsePat(payload, pat) {\n        pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n        pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n        // skip the PSI header and parse the first PMT entry\n\n        self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n        pat.pmtPid = self.pmtPid;\n      };\n      /**\n       * Parse out the relevant fields of a Program Map Table (PMT).\n       * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n       * packet. The first byte in this array should be the table_id\n       * field.\n       * @param pmt {object} the object that should be decorated with\n       * fields parsed from the PMT.\n       */\n\n\n      parsePmt = function parsePmt(payload, pmt) {\n        var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n        // take effect. We don't believe this should ever be the case\n        // for HLS but we'll ignore \"forward\" PMT declarations if we see\n        // them. Future PMT declarations have the current_next_indicator\n        // set to zero.\n\n        if (!(payload[5] & 0x01)) {\n          return;\n        } // overwrite any existing program map table\n\n\n        self.programMapTable = {\n          video: null,\n          audio: null,\n          'timed-metadata': {}\n        }; // the mapping table ends at the end of the current section\n\n        sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n        tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n        // long the program info descriptors are\n\n        programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n        offset = 12 + programInfoLength;\n\n        while (offset < tableEnd) {\n          var streamType = payload[offset];\n          var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n          // TODO: should this be done for metadata too? for now maintain behavior of\n          //       multiple metadata streams\n\n          if (streamType === streamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {\n            self.programMapTable.video = pid;\n          } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n            self.programMapTable.audio = pid;\n          } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {\n            // map pid to stream type for metadata streams\n            self.programMapTable['timed-metadata'][pid] = streamType;\n          } // move to the next table entry\n          // skip past the elementary stream descriptors, if present\n\n\n          offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n        } // record the map on the packet as well\n\n\n        pmt.programMapTable = self.programMapTable;\n      };\n      /**\n       * Deliver a new MP2T packet to the next stream in the pipeline.\n       */\n\n\n      this.push = function (packet) {\n        var result = {},\n            offset = 4;\n        result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n        result.pid = packet[1] & 0x1f;\n        result.pid <<= 8;\n        result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n        // fifth byte of the TS packet header. The adaptation field is\n        // used to add stuffing to PES packets that don't fill a complete\n        // TS packet, and to specify some forms of timing and control data\n        // that we do not currently use.\n\n        if ((packet[3] & 0x30) >>> 4 > 0x01) {\n          offset += packet[offset] + 1;\n        } // parse the rest of the packet based on the type\n\n\n        if (result.pid === 0) {\n          result.type = 'pat';\n          parsePsi(packet.subarray(offset), result);\n          this.trigger('data', result);\n        } else if (result.pid === this.pmtPid) {\n          result.type = 'pmt';\n          parsePsi(packet.subarray(offset), result);\n          this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n          while (this.packetsWaitingForPmt.length) {\n            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n          }\n        } else if (this.programMapTable === undefined) {\n          // When we have not seen a PMT yet, defer further processing of\n          // PES packets until one has been parsed\n          this.packetsWaitingForPmt.push([packet, offset, result]);\n        } else {\n          this.processPes_(packet, offset, result);\n        }\n      };\n\n      this.processPes_ = function (packet, offset, result) {\n        // set the appropriate stream type\n        if (result.pid === this.programMapTable.video) {\n          result.streamType = streamTypes.H264_STREAM_TYPE;\n        } else if (result.pid === this.programMapTable.audio) {\n          result.streamType = streamTypes.ADTS_STREAM_TYPE;\n        } else {\n          // if not video or audio, it is timed-metadata or unknown\n          // if unknown, streamType will be undefined\n          result.streamType = this.programMapTable['timed-metadata'][result.pid];\n        }\n\n        result.type = 'pes';\n        result.data = packet.subarray(offset);\n        this.trigger('data', result);\n      };\n    };\n\n    _TransportParseStream.prototype = new stream();\n    _TransportParseStream.STREAM_TYPES = {\n      h264: 0x1b,\n      adts: 0x0f\n    };\n    /**\n     * Reconsistutes program elementary stream (PES) packets from parsed\n     * transport stream packets. That is, if you pipe an\n     * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n     * events will be events which capture the bytes for individual PES\n     * packets plus relevant metadata that has been extracted from the\n     * container.\n     */\n\n    _ElementaryStream = function ElementaryStream() {\n      var self = this,\n          // PES packet fragments\n      video = {\n        data: [],\n        size: 0\n      },\n          audio = {\n        data: [],\n        size: 0\n      },\n          timedMetadata = {\n        data: [],\n        size: 0\n      },\n          programMapTable,\n          parsePes = function parsePes(payload, pes) {\n        var ptsDtsFlags; // get the packet length, this will be 0 for video\n\n        pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n        pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n        // and a DTS value. Determine what combination of values is\n        // available to work with.\n\n        ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n        // performs all bitwise operations on 32-bit integers but javascript\n        // supports a much greater range (52-bits) of integer using standard\n        // mathematical operations.\n        // We construct a 31-bit value using bitwise operators over the 31\n        // most significant bits and then multiply by 4 (equal to a left-shift\n        // of 2) before we add the final 2 least significant bits of the\n        // timestamp (equal to an OR.)\n\n        if (ptsDtsFlags & 0xC0) {\n          // the PTS and DTS are not written out directly. For information\n          // on how they are encoded, see\n          // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n          pes.pts *= 4; // Left shift by 2\n\n          pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n          pes.dts = pes.pts;\n\n          if (ptsDtsFlags & 0x40) {\n            pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n            pes.dts *= 4; // Left shift by 2\n\n            pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n          }\n        } // the data section starts immediately after the PES header.\n        // pes_header_data_length specifies the number of header bytes\n        // that follow the last byte of the field.\n\n\n        pes.data = payload.subarray(9 + payload[8]);\n      },\n\n      /**\n        * Pass completely parsed PES packets to the next stream in the pipeline\n       **/\n      flushStream = function flushStream(stream, type, forceFlush) {\n        var packetData = new Uint8Array(stream.size),\n            event = {\n          type: type\n        },\n            i = 0,\n            offset = 0,\n            packetFlushable = false,\n            fragment; // do nothing if there is not enough buffered data for a complete\n        // PES header\n\n        if (!stream.data.length || stream.size < 9) {\n          return;\n        }\n\n        event.trackId = stream.data[0].pid; // reassemble the packet\n\n        for (i = 0; i < stream.data.length; i++) {\n          fragment = stream.data[i];\n          packetData.set(fragment.data, offset);\n          offset += fragment.data.byteLength;\n        } // parse assembled packet's PES header\n\n\n        parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n        // check that there is enough stream data to fill the packet\n\n        packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n        if (forceFlush || packetFlushable) {\n          stream.size = 0;\n          stream.data.length = 0;\n        } // only emit packets that are complete. this is to avoid assembling\n        // incomplete PES packets due to poor segmentation\n\n\n        if (packetFlushable) {\n          self.trigger('data', event);\n        }\n      };\n\n      _ElementaryStream.prototype.init.call(this);\n      /**\n       * Identifies M2TS packet types and parses PES packets using metadata\n       * parsed from the PMT\n       **/\n\n\n      this.push = function (data) {\n        ({\n          pat: function pat() {// we have to wait for the PMT to arrive as well before we\n            // have any meaningful metadata\n          },\n          pes: function pes() {\n            var stream, streamType;\n\n            switch (data.streamType) {\n              case streamTypes.H264_STREAM_TYPE:\n                stream = video;\n                streamType = 'video';\n                break;\n\n              case streamTypes.ADTS_STREAM_TYPE:\n                stream = audio;\n                streamType = 'audio';\n                break;\n\n              case streamTypes.METADATA_STREAM_TYPE:\n                stream = timedMetadata;\n                streamType = 'timed-metadata';\n                break;\n\n              default:\n                // ignore unknown stream types\n                return;\n            } // if a new packet is starting, we can flush the completed\n            // packet\n\n\n            if (data.payloadUnitStartIndicator) {\n              flushStream(stream, streamType, true);\n            } // buffer this fragment until we are sure we've received the\n            // complete payload\n\n\n            stream.data.push(data);\n            stream.size += data.data.byteLength;\n          },\n          pmt: function pmt() {\n            var event = {\n              type: 'metadata',\n              tracks: []\n            };\n            programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n            if (programMapTable.video !== null) {\n              event.tracks.push({\n                timelineStartInfo: {\n                  baseMediaDecodeTime: 0\n                },\n                id: +programMapTable.video,\n                codec: 'avc',\n                type: 'video'\n              });\n            }\n\n            if (programMapTable.audio !== null) {\n              event.tracks.push({\n                timelineStartInfo: {\n                  baseMediaDecodeTime: 0\n                },\n                id: +programMapTable.audio,\n                codec: 'adts',\n                type: 'audio'\n              });\n            }\n\n            self.trigger('data', event);\n          }\n        })[data.type]();\n      };\n\n      this.reset = function () {\n        video.size = 0;\n        video.data.length = 0;\n        audio.size = 0;\n        audio.data.length = 0;\n        this.trigger('reset');\n      };\n      /**\n       * Flush any remaining input. Video PES packets may be of variable\n       * length. Normally, the start of a new video packet can trigger the\n       * finalization of the previous packet. That is not possible if no\n       * more video is forthcoming, however. In that case, some other\n       * mechanism (like the end of the file) has to be employed. When it is\n       * clear that no additional data is forthcoming, calling this method\n       * will flush the buffered packets.\n       */\n\n\n      this.flushStreams_ = function () {\n        // !!THIS ORDER IS IMPORTANT!!\n        // video first then audio\n        flushStream(video, 'video');\n        flushStream(audio, 'audio');\n        flushStream(timedMetadata, 'timed-metadata');\n      };\n\n      this.flush = function () {\n        this.flushStreams_();\n        this.trigger('done');\n      };\n    };\n\n    _ElementaryStream.prototype = new stream();\n    var m2ts = {\n      PAT_PID: 0x0000,\n      MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n      TransportPacketStream: _TransportPacketStream,\n      TransportParseStream: _TransportParseStream,\n      ElementaryStream: _ElementaryStream,\n      TimestampRolloverStream: TimestampRolloverStream$1,\n      CaptionStream: captionStream.CaptionStream,\n      Cea608Stream: captionStream.Cea608Stream,\n      MetadataStream: metadataStream\n    };\n\n    for (var type in streamTypes) {\n      if (streamTypes.hasOwnProperty(type)) {\n        m2ts[type] = streamTypes[type];\n      }\n    }\n\n    var m2ts_1 = m2ts;\n    var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS;\n\n    var _AdtsStream;\n\n    var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    /*\n     * Accepts a ElementaryStream and emits data events with parsed\n     * AAC Audio Frames of the individual packets. Input audio in ADTS\n     * format is unpacked and re-emitted as AAC frames.\n     *\n     * @see http://wiki.multimedia.cx/index.php?title=ADTS\n     * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n     */\n\n    _AdtsStream = function AdtsStream(handlePartialSegments) {\n      var buffer,\n          frameNum = 0;\n\n      _AdtsStream.prototype.init.call(this);\n\n      this.push = function (packet) {\n        var i = 0,\n            frameLength,\n            protectionSkipBytes,\n            frameEnd,\n            oldBuffer,\n            sampleCount,\n            adtsFrameDuration;\n\n        if (!handlePartialSegments) {\n          frameNum = 0;\n        }\n\n        if (packet.type !== 'audio') {\n          // ignore non-audio data\n          return;\n        } // Prepend any data in the buffer to the input data so that we can parse\n        // aac frames the cross a PES packet boundary\n\n\n        if (buffer) {\n          oldBuffer = buffer;\n          buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n          buffer.set(oldBuffer);\n          buffer.set(packet.data, oldBuffer.byteLength);\n        } else {\n          buffer = packet.data;\n        } // unpack any ADTS frames which have been fully received\n        // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n\n        while (i + 5 < buffer.length) {\n          // Look for the start of an ADTS header..\n          if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n            // If a valid header was not found,  jump one forward and attempt to\n            // find a valid ADTS header starting at the next byte\n            i++;\n            continue;\n          } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n          // end of the ADTS header\n\n\n          protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n          // end of the sync sequence\n\n          frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n          sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n          adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\n          frameEnd = i + frameLength; // If we don't have enough data to actually finish this ADTS frame, return\n          // and wait for more data\n\n          if (buffer.byteLength < frameEnd) {\n            return;\n          } // Otherwise, deliver the complete AAC frame\n\n\n          this.trigger('data', {\n            pts: packet.pts + frameNum * adtsFrameDuration,\n            dts: packet.dts + frameNum * adtsFrameDuration,\n            sampleCount: sampleCount,\n            audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n            samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n            samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n            // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n            samplesize: 16,\n            data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\n          });\n          frameNum++; // If the buffer is empty, clear it and return\n\n          if (buffer.byteLength === frameEnd) {\n            buffer = undefined;\n            return;\n          } // Remove the finished frame from the buffer and start the process again\n\n\n          buffer = buffer.subarray(frameEnd);\n        }\n      };\n\n      this.flush = function () {\n        frameNum = 0;\n        this.trigger('done');\n      };\n\n      this.reset = function () {\n        buffer = void 0;\n        this.trigger('reset');\n      };\n\n      this.endTimeline = function () {\n        buffer = void 0;\n        this.trigger('endedtimeline');\n      };\n    };\n\n    _AdtsStream.prototype = new stream();\n    var adts = _AdtsStream;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var ExpGolomb;\n    /**\n     * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n     * scheme used by h264.\n     */\n\n    ExpGolomb = function ExpGolomb(workingData) {\n      var // the number of bytes left to examine in workingData\n      workingBytesAvailable = workingData.byteLength,\n          // the current word being examined\n      workingWord = 0,\n          // :uint\n      // the number of bits left to examine in the current word\n      workingBitsAvailable = 0; // :uint;\n      // ():uint\n\n      this.length = function () {\n        return 8 * workingBytesAvailable;\n      }; // ():uint\n\n\n      this.bitsAvailable = function () {\n        return 8 * workingBytesAvailable + workingBitsAvailable;\n      }; // ():void\n\n\n      this.loadWord = function () {\n        var position = workingData.byteLength - workingBytesAvailable,\n            workingBytes = new Uint8Array(4),\n            availableBytes = Math.min(4, workingBytesAvailable);\n\n        if (availableBytes === 0) {\n          throw new Error('no bytes available');\n        }\n\n        workingBytes.set(workingData.subarray(position, position + availableBytes));\n        workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n        workingBitsAvailable = availableBytes * 8;\n        workingBytesAvailable -= availableBytes;\n      }; // (count:int):void\n\n\n      this.skipBits = function (count) {\n        var skipBytes; // :int\n\n        if (workingBitsAvailable > count) {\n          workingWord <<= count;\n          workingBitsAvailable -= count;\n        } else {\n          count -= workingBitsAvailable;\n          skipBytes = Math.floor(count / 8);\n          count -= skipBytes * 8;\n          workingBytesAvailable -= skipBytes;\n          this.loadWord();\n          workingWord <<= count;\n          workingBitsAvailable -= count;\n        }\n      }; // (size:int):uint\n\n\n      this.readBits = function (size) {\n        var bits = Math.min(workingBitsAvailable, size),\n            // :uint\n        valu = workingWord >>> 32 - bits; // :uint\n        // if size > 31, handle error\n\n        workingBitsAvailable -= bits;\n\n        if (workingBitsAvailable > 0) {\n          workingWord <<= bits;\n        } else if (workingBytesAvailable > 0) {\n          this.loadWord();\n        }\n\n        bits = size - bits;\n\n        if (bits > 0) {\n          return valu << bits | this.readBits(bits);\n        }\n\n        return valu;\n      }; // ():uint\n\n\n      this.skipLeadingZeros = function () {\n        var leadingZeroCount; // :uint\n\n        for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n          if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n            // the first bit of working word is 1\n            workingWord <<= leadingZeroCount;\n            workingBitsAvailable -= leadingZeroCount;\n            return leadingZeroCount;\n          }\n        } // we exhausted workingWord and still have not found a 1\n\n\n        this.loadWord();\n        return leadingZeroCount + this.skipLeadingZeros();\n      }; // ():void\n\n\n      this.skipUnsignedExpGolomb = function () {\n        this.skipBits(1 + this.skipLeadingZeros());\n      }; // ():void\n\n\n      this.skipExpGolomb = function () {\n        this.skipBits(1 + this.skipLeadingZeros());\n      }; // ():uint\n\n\n      this.readUnsignedExpGolomb = function () {\n        var clz = this.skipLeadingZeros(); // :uint\n\n        return this.readBits(clz + 1) - 1;\n      }; // ():int\n\n\n      this.readExpGolomb = function () {\n        var valu = this.readUnsignedExpGolomb(); // :int\n\n        if (0x01 & valu) {\n          // the number is odd if the low order bit is set\n          return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n        }\n\n        return -1 * (valu >>> 1); // divide by two then make it negative\n      }; // Some convenience functions\n      // :Boolean\n\n\n      this.readBoolean = function () {\n        return this.readBits(1) === 1;\n      }; // ():int\n\n\n      this.readUnsignedByte = function () {\n        return this.readBits(8);\n      };\n\n      this.loadWord();\n    };\n\n    var expGolomb = ExpGolomb;\n\n    var _H264Stream, _NalByteStream;\n\n    var PROFILES_WITH_OPTIONAL_SPS_DATA;\n    /**\n     * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n     */\n\n    _NalByteStream = function NalByteStream() {\n      var syncPoint = 0,\n          i,\n          buffer;\n\n      _NalByteStream.prototype.init.call(this);\n      /*\n       * Scans a byte stream and triggers a data event with the NAL units found.\n       * @param {Object} data Event received from H264Stream\n       * @param {Uint8Array} data.data The h264 byte stream to be scanned\n       *\n       * @see H264Stream.push\n       */\n\n\n      this.push = function (data) {\n        var swapBuffer;\n\n        if (!buffer) {\n          buffer = data.data;\n        } else {\n          swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n          swapBuffer.set(buffer);\n          swapBuffer.set(data.data, buffer.byteLength);\n          buffer = swapBuffer;\n        }\n\n        var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n        // scan for NAL unit boundaries\n        // a match looks like this:\n        // 0 0 1 .. NAL .. 0 0 1\n        // ^ sync point        ^ i\n        // or this:\n        // 0 0 1 .. NAL .. 0 0 0\n        // ^ sync point        ^ i\n        // advance the sync point to a NAL start, if necessary\n\n        for (; syncPoint < len - 3; syncPoint++) {\n          if (buffer[syncPoint + 2] === 1) {\n            // the sync point is properly aligned\n            i = syncPoint + 5;\n            break;\n          }\n        }\n\n        while (i < len) {\n          // look at the current byte to determine if we've hit the end of\n          // a NAL unit boundary\n          switch (buffer[i]) {\n            case 0:\n              // skip past non-sync sequences\n              if (buffer[i - 1] !== 0) {\n                i += 2;\n                break;\n              } else if (buffer[i - 2] !== 0) {\n                i++;\n                break;\n              } // deliver the NAL unit if it isn't empty\n\n\n              if (syncPoint + 3 !== i - 2) {\n                this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n              } // drop trailing zeroes\n\n\n              do {\n                i++;\n              } while (buffer[i] !== 1 && i < len);\n\n              syncPoint = i - 2;\n              i += 3;\n              break;\n\n            case 1:\n              // skip past non-sync sequences\n              if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n                i += 3;\n                break;\n              } // deliver the NAL unit\n\n\n              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n              syncPoint = i - 2;\n              i += 3;\n              break;\n\n            default:\n              // the current byte isn't a one or zero, so it cannot be part\n              // of a sync sequence\n              i += 3;\n              break;\n          }\n        } // filter out the NAL units that were delivered\n\n\n        buffer = buffer.subarray(syncPoint);\n        i -= syncPoint;\n        syncPoint = 0;\n      };\n\n      this.reset = function () {\n        buffer = null;\n        syncPoint = 0;\n        this.trigger('reset');\n      };\n\n      this.flush = function () {\n        // deliver the last buffered NAL unit\n        if (buffer && buffer.byteLength > 3) {\n          this.trigger('data', buffer.subarray(syncPoint + 3));\n        } // reset the stream state\n\n\n        buffer = null;\n        syncPoint = 0;\n        this.trigger('done');\n      };\n\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline');\n      };\n    };\n\n    _NalByteStream.prototype = new stream(); // values of profile_idc that indicate additional fields are included in the SPS\n    // see Recommendation ITU-T H.264 (4/2013),\n    // 7.3.2.1.1 Sequence parameter set data syntax\n\n    PROFILES_WITH_OPTIONAL_SPS_DATA = {\n      100: true,\n      110: true,\n      122: true,\n      244: true,\n      44: true,\n      83: true,\n      86: true,\n      118: true,\n      128: true,\n      138: true,\n      139: true,\n      134: true\n    };\n    /**\n     * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n     * events.\n     */\n\n    _H264Stream = function H264Stream() {\n      var nalByteStream = new _NalByteStream(),\n          self,\n          trackId,\n          currentPts,\n          currentDts,\n          discardEmulationPreventionBytes,\n          readSequenceParameterSet,\n          skipScalingList;\n\n      _H264Stream.prototype.init.call(this);\n\n      self = this;\n      /*\n       * Pushes a packet from a stream onto the NalByteStream\n       *\n       * @param {Object} packet - A packet received from a stream\n       * @param {Uint8Array} packet.data - The raw bytes of the packet\n       * @param {Number} packet.dts - Decode timestamp of the packet\n       * @param {Number} packet.pts - Presentation timestamp of the packet\n       * @param {Number} packet.trackId - The id of the h264 track this packet came from\n       * @param {('video'|'audio')} packet.type - The type of packet\n       *\n       */\n\n      this.push = function (packet) {\n        if (packet.type !== 'video') {\n          return;\n        }\n\n        trackId = packet.trackId;\n        currentPts = packet.pts;\n        currentDts = packet.dts;\n        nalByteStream.push(packet);\n      };\n      /*\n       * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n       * for the NALUs to the next stream component.\n       * Also, preprocess caption and sequence parameter NALUs.\n       *\n       * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n       * @see NalByteStream.push\n       */\n\n\n      nalByteStream.on('data', function (data) {\n        var event = {\n          trackId: trackId,\n          pts: currentPts,\n          dts: currentDts,\n          data: data\n        };\n\n        switch (data[0] & 0x1f) {\n          case 0x05:\n            event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n            break;\n\n          case 0x06:\n            event.nalUnitType = 'sei_rbsp';\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n            break;\n\n          case 0x07:\n            event.nalUnitType = 'seq_parameter_set_rbsp';\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n            event.config = readSequenceParameterSet(event.escapedRBSP);\n            break;\n\n          case 0x08:\n            event.nalUnitType = 'pic_parameter_set_rbsp';\n            break;\n\n          case 0x09:\n            event.nalUnitType = 'access_unit_delimiter_rbsp';\n            break;\n        } // This triggers data on the H264Stream\n\n\n        self.trigger('data', event);\n      });\n      nalByteStream.on('done', function () {\n        self.trigger('done');\n      });\n      nalByteStream.on('partialdone', function () {\n        self.trigger('partialdone');\n      });\n      nalByteStream.on('reset', function () {\n        self.trigger('reset');\n      });\n      nalByteStream.on('endedtimeline', function () {\n        self.trigger('endedtimeline');\n      });\n\n      this.flush = function () {\n        nalByteStream.flush();\n      };\n\n      this.partialFlush = function () {\n        nalByteStream.partialFlush();\n      };\n\n      this.reset = function () {\n        nalByteStream.reset();\n      };\n\n      this.endTimeline = function () {\n        nalByteStream.endTimeline();\n      };\n      /**\n       * Advance the ExpGolomb decoder past a scaling list. The scaling\n       * list is optionally transmitted as part of a sequence parameter\n       * set and is not relevant to transmuxing.\n       * @param count {number} the number of entries in this scaling list\n       * @param expGolombDecoder {object} an ExpGolomb pointed to the\n       * start of a scaling list\n       * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n       */\n\n\n      skipScalingList = function skipScalingList(count, expGolombDecoder) {\n        var lastScale = 8,\n            nextScale = 8,\n            j,\n            deltaScale;\n\n        for (j = 0; j < count; j++) {\n          if (nextScale !== 0) {\n            deltaScale = expGolombDecoder.readExpGolomb();\n            nextScale = (lastScale + deltaScale + 256) % 256;\n          }\n\n          lastScale = nextScale === 0 ? lastScale : nextScale;\n        }\n      };\n      /**\n       * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n       * Sequence Payload\"\n       * @param data {Uint8Array} the bytes of a RBSP from a NAL\n       * unit\n       * @return {Uint8Array} the RBSP without any Emulation\n       * Prevention Bytes\n       */\n\n\n      discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n        var length = data.byteLength,\n            emulationPreventionBytesPositions = [],\n            i = 1,\n            newLength,\n            newData; // Find all `Emulation Prevention Bytes`\n\n        while (i < length - 2) {\n          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n            emulationPreventionBytesPositions.push(i + 2);\n            i += 2;\n          } else {\n            i++;\n          }\n        } // If no Emulation Prevention Bytes were found just return the original\n        // array\n\n\n        if (emulationPreventionBytesPositions.length === 0) {\n          return data;\n        } // Create a new array to hold the NAL unit data\n\n\n        newLength = length - emulationPreventionBytesPositions.length;\n        newData = new Uint8Array(newLength);\n        var sourceIndex = 0;\n\n        for (i = 0; i < newLength; sourceIndex++, i++) {\n          if (sourceIndex === emulationPreventionBytesPositions[0]) {\n            // Skip this byte\n            sourceIndex++; // Remove this position index\n\n            emulationPreventionBytesPositions.shift();\n          }\n\n          newData[i] = data[sourceIndex];\n        }\n\n        return newData;\n      };\n      /**\n       * Read a sequence parameter set and return some interesting video\n       * properties. A sequence parameter set is the H264 metadata that\n       * describes the properties of upcoming video frames.\n       * @param data {Uint8Array} the bytes of a sequence parameter set\n       * @return {object} an object with configuration parsed from the\n       * sequence parameter set, including the dimensions of the\n       * associated video frames.\n       */\n\n\n      readSequenceParameterSet = function readSequenceParameterSet(data) {\n        var frameCropLeftOffset = 0,\n            frameCropRightOffset = 0,\n            frameCropTopOffset = 0,\n            frameCropBottomOffset = 0,\n            sarScale = 1,\n            expGolombDecoder,\n            profileIdc,\n            levelIdc,\n            profileCompatibility,\n            chromaFormatIdc,\n            picOrderCntType,\n            numRefFramesInPicOrderCntCycle,\n            picWidthInMbsMinus1,\n            picHeightInMapUnitsMinus1,\n            frameMbsOnlyFlag,\n            scalingListCount,\n            sarRatio,\n            aspectRatioIdc,\n            i;\n        expGolombDecoder = new expGolomb(data);\n        profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n        profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n        levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n        // some profiles have more optional data we don't need\n\n        if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n          chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n\n          if (chromaFormatIdc === 3) {\n            expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n          }\n\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n          expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n          if (expGolombDecoder.readBoolean()) {\n            // seq_scaling_matrix_present_flag\n            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n\n            for (i = 0; i < scalingListCount; i++) {\n              if (expGolombDecoder.readBoolean()) {\n                // seq_scaling_list_present_flag[ i ]\n                if (i < 6) {\n                  skipScalingList(16, expGolombDecoder);\n                } else {\n                  skipScalingList(64, expGolombDecoder);\n                }\n              }\n            }\n          }\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n        picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n        if (picOrderCntType === 0) {\n          expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n        } else if (picOrderCntType === 1) {\n          expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n          expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n          expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n          numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n\n          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n            expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n          }\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n        expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n        picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n        picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n        frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n\n        if (frameMbsOnlyFlag === 0) {\n          expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n        }\n\n        expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n        if (expGolombDecoder.readBoolean()) {\n          // frame_cropping_flag\n          frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n        }\n\n        if (expGolombDecoder.readBoolean()) {\n          // vui_parameters_present_flag\n          if (expGolombDecoder.readBoolean()) {\n            // aspect_ratio_info_present_flag\n            aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n\n            switch (aspectRatioIdc) {\n              case 1:\n                sarRatio = [1, 1];\n                break;\n\n              case 2:\n                sarRatio = [12, 11];\n                break;\n\n              case 3:\n                sarRatio = [10, 11];\n                break;\n\n              case 4:\n                sarRatio = [16, 11];\n                break;\n\n              case 5:\n                sarRatio = [40, 33];\n                break;\n\n              case 6:\n                sarRatio = [24, 11];\n                break;\n\n              case 7:\n                sarRatio = [20, 11];\n                break;\n\n              case 8:\n                sarRatio = [32, 11];\n                break;\n\n              case 9:\n                sarRatio = [80, 33];\n                break;\n\n              case 10:\n                sarRatio = [18, 11];\n                break;\n\n              case 11:\n                sarRatio = [15, 11];\n                break;\n\n              case 12:\n                sarRatio = [64, 33];\n                break;\n\n              case 13:\n                sarRatio = [160, 99];\n                break;\n\n              case 14:\n                sarRatio = [4, 3];\n                break;\n\n              case 15:\n                sarRatio = [3, 2];\n                break;\n\n              case 16:\n                sarRatio = [2, 1];\n                break;\n\n              case 255:\n                {\n                  sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                  break;\n                }\n            }\n\n            if (sarRatio) {\n              sarScale = sarRatio[0] / sarRatio[1];\n            }\n          }\n        }\n\n        return {\n          profileIdc: profileIdc,\n          levelIdc: levelIdc,\n          profileCompatibility: profileCompatibility,\n          width: Math.ceil(((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\n          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n          sarRatio: sarRatio\n        };\n      };\n    };\n\n    _H264Stream.prototype = new stream();\n    var h264 = {\n      H264Stream: _H264Stream,\n      NalByteStream: _NalByteStream\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Utilities to detect basic properties and metadata about Aac data.\n     */\n\n    var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\n    var parseId3TagSize = function parseId3TagSize(header, byteIndex) {\n      var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n          flags = header[byteIndex + 5],\n          footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n      returnSize = returnSize >= 0 ? returnSize : 0;\n\n      if (footerPresent) {\n        return returnSize + 20;\n      }\n\n      return returnSize + 10;\n    };\n\n    var getId3Offset = function getId3Offset(data, offset) {\n      if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n        return offset;\n      }\n\n      offset += parseId3TagSize(data, offset);\n      return getId3Offset(data, offset);\n    }; // TODO: use vhs-utils\n\n\n    var isLikelyAacData = function isLikelyAacData(data) {\n      var offset = getId3Offset(data, 0);\n      return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 && // verify that the 2 layer bits are 0, aka this\n      // is not mp3 data but aac data.\n      (data[offset + 1] & 0x16) === 0x10;\n    };\n\n    var parseSyncSafeInteger$1 = function parseSyncSafeInteger$1(data) {\n      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n    }; // return a percent-encoded representation of the specified byte range\n    // @see http://en.wikipedia.org/wiki/Percent-encoding\n\n\n    var percentEncode$1 = function percentEncode$1(bytes, start, end) {\n      var i,\n          result = '';\n\n      for (i = start; i < end; i++) {\n        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n      }\n\n      return result;\n    }; // return the string representation of the specified byte range,\n    // interpreted as ISO-8859-1.\n\n\n    var parseIso88591$1 = function parseIso88591$1(bytes, start, end) {\n      return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\n    };\n\n    var parseAdtsSize = function parseAdtsSize(header, byteIndex) {\n      var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n          middle = header[byteIndex + 4] << 3,\n          highTwo = header[byteIndex + 3] & 0x3 << 11;\n      return highTwo | middle | lowThree;\n    };\n\n    var parseType = function parseType(header, byteIndex) {\n      if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n        return 'timed-metadata';\n      } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n        return 'audio';\n      }\n\n      return null;\n    };\n\n    var parseSampleRate = function parseSampleRate(packet) {\n      var i = 0;\n\n      while (i + 5 < packet.length) {\n        if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n          // If a valid header was not found,  jump one forward and attempt to\n          // find a valid ADTS header starting at the next byte\n          i++;\n          continue;\n        }\n\n        return ADTS_SAMPLING_FREQUENCIES$1[(packet[i + 2] & 0x3c) >>> 2];\n      }\n\n      return null;\n    };\n\n    var parseAacTimestamp = function parseAacTimestamp(packet) {\n      var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n      frameStart = 10;\n\n      if (packet[5] & 0x40) {\n        // advance the frame start past the extended header\n        frameStart += 4; // header size field\n\n        frameStart += parseSyncSafeInteger$1(packet.subarray(10, 14));\n      } // parse one or more ID3 frames\n      // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n      do {\n        // determine the number of bytes in this frame\n        frameSize = parseSyncSafeInteger$1(packet.subarray(frameStart + 4, frameStart + 8));\n\n        if (frameSize < 1) {\n          return null;\n        }\n\n        frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n\n        if (frameHeader === 'PRIV') {\n          frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n          for (var i = 0; i < frame.byteLength; i++) {\n            if (frame[i] === 0) {\n              var owner = parseIso88591$1(frame, 0, i);\n\n              if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n                var d = frame.subarray(i + 1);\n                var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n                size *= 4;\n                size += d[7] & 0x03;\n                return size;\n              }\n\n              break;\n            }\n          }\n        }\n\n        frameStart += 10; // advance past the frame header\n\n        frameStart += frameSize; // advance past the frame body\n      } while (frameStart < packet.byteLength);\n\n      return null;\n    };\n\n    var utils = {\n      isLikelyAacData: isLikelyAacData,\n      parseId3TagSize: parseId3TagSize,\n      parseAdtsSize: parseAdtsSize,\n      parseType: parseType,\n      parseSampleRate: parseSampleRate,\n      parseAacTimestamp: parseAacTimestamp\n    }; // Constants\n\n    var _AacStream;\n    /**\n     * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n     */\n\n\n    _AacStream = function AacStream() {\n      var everything = new Uint8Array(),\n          timeStamp = 0;\n\n      _AacStream.prototype.init.call(this);\n\n      this.setTimestamp = function (timestamp) {\n        timeStamp = timestamp;\n      };\n\n      this.push = function (bytes) {\n        var frameSize = 0,\n            byteIndex = 0,\n            bytesLeft,\n            chunk,\n            packet,\n            tempLength; // If there are bytes remaining from the last segment, prepend them to the\n        // bytes that were pushed in\n\n        if (everything.length) {\n          tempLength = everything.length;\n          everything = new Uint8Array(bytes.byteLength + tempLength);\n          everything.set(everything.subarray(0, tempLength));\n          everything.set(bytes, tempLength);\n        } else {\n          everything = bytes;\n        }\n\n        while (everything.length - byteIndex >= 3) {\n          if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n            // Exit early because we don't have enough to parse\n            // the ID3 tag header\n            if (everything.length - byteIndex < 10) {\n              break;\n            } // check framesize\n\n\n            frameSize = utils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n            // Add to byteIndex to support multiple ID3 tags in sequence\n\n            if (byteIndex + frameSize > everything.length) {\n              break;\n            }\n\n            chunk = {\n              type: 'timed-metadata',\n              data: everything.subarray(byteIndex, byteIndex + frameSize)\n            };\n            this.trigger('data', chunk);\n            byteIndex += frameSize;\n            continue;\n          } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n            // Exit early because we don't have enough to parse\n            // the ADTS frame header\n            if (everything.length - byteIndex < 7) {\n              break;\n            }\n\n            frameSize = utils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n\n            if (byteIndex + frameSize > everything.length) {\n              break;\n            }\n\n            packet = {\n              type: 'audio',\n              data: everything.subarray(byteIndex, byteIndex + frameSize),\n              pts: timeStamp,\n              dts: timeStamp\n            };\n            this.trigger('data', packet);\n            byteIndex += frameSize;\n            continue;\n          }\n\n          byteIndex++;\n        }\n\n        bytesLeft = everything.length - byteIndex;\n\n        if (bytesLeft > 0) {\n          everything = everything.subarray(byteIndex);\n        } else {\n          everything = new Uint8Array();\n        }\n      };\n\n      this.reset = function () {\n        everything = new Uint8Array();\n        this.trigger('reset');\n      };\n\n      this.endTimeline = function () {\n        everything = new Uint8Array();\n        this.trigger('endedtimeline');\n      };\n    };\n\n    _AacStream.prototype = new stream();\n    var aac = _AacStream; // constants\n\n    var AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n    var audioProperties = AUDIO_PROPERTIES;\n    var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\n    var videoProperties = VIDEO_PROPERTIES;\n    var H264Stream$1 = h264.H264Stream;\n    var isLikelyAacData$1 = utils.isLikelyAacData;\n    var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS; // object types\n\n    var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;\n    /**\n     * Compare two arrays (even typed) for same-ness\n     */\n\n\n    var arrayEquals = function arrayEquals(a, b) {\n      var i;\n\n      if (a.length !== b.length) {\n        return false;\n      } // compare the value of each element in the array\n\n\n      for (i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    var generateVideoSegmentTimingInfo = function generateVideoSegmentTimingInfo(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n      var ptsOffsetFromDts = startPts - startDts,\n          decodeDuration = endDts - startDts,\n          presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n      // however, the player time values will reflect a start from the baseMediaDecodeTime.\n      // In order to provide relevant values for the player times, base timing info on the\n      // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n      return {\n        start: {\n          dts: baseMediaDecodeTime,\n          pts: baseMediaDecodeTime + ptsOffsetFromDts\n        },\n        end: {\n          dts: baseMediaDecodeTime + decodeDuration,\n          pts: baseMediaDecodeTime + presentationDuration\n        },\n        prependedContentDuration: prependedContentDuration,\n        baseMediaDecodeTime: baseMediaDecodeTime\n      };\n    };\n    /**\n     * Constructs a single-track, ISO BMFF media segment from AAC data\n     * events. The output of this stream can be fed to a SourceBuffer\n     * configured with a suitable initialization segment.\n     * @param track {object} track metadata configuration\n     * @param options {object} transmuxer options object\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n\n\n    _AudioSegmentStream = function AudioSegmentStream(track, options) {\n      var adtsFrames = [],\n          sequenceNumber = 0,\n          earliestAllowedDts = 0,\n          audioAppendStartTs = 0,\n          videoBaseMediaDecodeTime = Infinity;\n      options = options || {};\n\n      _AudioSegmentStream.prototype.init.call(this);\n\n      this.push = function (data) {\n        trackDecodeInfo.collectDtsInfo(track, data);\n\n        if (track) {\n          audioProperties.forEach(function (prop) {\n            track[prop] = data[prop];\n          });\n        } // buffer audio data until end() is called\n\n\n        adtsFrames.push(data);\n      };\n\n      this.setEarliestDts = function (earliestDts) {\n        earliestAllowedDts = earliestDts;\n      };\n\n      this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        videoBaseMediaDecodeTime = baseMediaDecodeTime;\n      };\n\n      this.setAudioAppendStart = function (timestamp) {\n        audioAppendStartTs = timestamp;\n      };\n\n      this.flush = function () {\n        var frames, moof, mdat, boxes, frameDuration; // return early if no audio data has been observed\n\n        if (adtsFrames.length === 0) {\n          this.trigger('done', 'AudioSegmentStream');\n          return;\n        }\n\n        frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n        audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n        // samples (that is, adts frames) in the audio data\n\n        track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n        mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n        adtsFrames = [];\n        moof = mp4Generator.moof(sequenceNumber, [track]);\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n        sequenceNumber++;\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        trackDecodeInfo.clearDtsInfo(track);\n        frameDuration = Math.ceil(ONE_SECOND_IN_TS$3 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n        // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n        // valid use-case where an init segment/data should be triggered without associated\n        // frames. Leaving for now, but should be looked into.\n\n        if (frames.length) {\n          this.trigger('timingInfo', {\n            start: frames[0].pts,\n            end: frames[0].pts + frames.length * frameDuration\n          });\n        }\n\n        this.trigger('data', {\n          track: track,\n          boxes: boxes\n        });\n        this.trigger('done', 'AudioSegmentStream');\n      };\n\n      this.reset = function () {\n        trackDecodeInfo.clearDtsInfo(track);\n        adtsFrames = [];\n        this.trigger('reset');\n      };\n    };\n\n    _AudioSegmentStream.prototype = new stream();\n    /**\n     * Constructs a single-track, ISO BMFF media segment from H264 data\n     * events. The output of this stream can be fed to a SourceBuffer\n     * configured with a suitable initialization segment.\n     * @param track {object} track metadata configuration\n     * @param options {object} transmuxer options object\n     * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n     *        gopsToAlignWith list when attempting to align gop pts\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n\n    _VideoSegmentStream = function VideoSegmentStream(track, options) {\n      var sequenceNumber = 0,\n          nalUnits = [],\n          gopsToAlignWith = [],\n          config,\n          pps;\n      options = options || {};\n\n      _VideoSegmentStream.prototype.init.call(this);\n\n      delete track.minPTS;\n      this.gopCache_ = [];\n      /**\n        * Constructs a ISO BMFF segment given H264 nalUnits\n        * @param {Object} nalUnit A data event representing a nalUnit\n        * @param {String} nalUnit.nalUnitType\n        * @param {Object} nalUnit.config Properties for a mp4 track\n        * @param {Uint8Array} nalUnit.data The nalUnit bytes\n        * @see lib/codecs/h264.js\n       **/\n\n      this.push = function (nalUnit) {\n        trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n        if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n          config = nalUnit.config;\n          track.sps = [nalUnit.data];\n          videoProperties.forEach(function (prop) {\n            track[prop] = config[prop];\n          }, this);\n        }\n\n        if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n          pps = nalUnit.data;\n          track.pps = [nalUnit.data];\n        } // buffer video until flush() is called\n\n\n        nalUnits.push(nalUnit);\n      };\n      /**\n        * Pass constructed ISO BMFF track and boxes on to the\n        * next stream in the pipeline\n       **/\n\n\n      this.flush = function () {\n        var frames,\n            gopForFusion,\n            gops,\n            moof,\n            mdat,\n            boxes,\n            prependedContentDuration = 0,\n            firstGop,\n            lastGop; // Throw away nalUnits at the start of the byte stream until\n        // we find the first AUD\n\n        while (nalUnits.length) {\n          if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n            break;\n          }\n\n          nalUnits.shift();\n        } // Return early if no video data has been observed\n\n\n        if (nalUnits.length === 0) {\n          this.resetStream_();\n          this.trigger('done', 'VideoSegmentStream');\n          return;\n        } // Organize the raw nal-units into arrays that represent\n        // higher-level constructs such as frames and gops\n        // (group-of-pictures)\n\n\n        frames = frameUtils.groupNalsIntoFrames(nalUnits);\n        gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n        // a problem since MSE (on Chrome) requires a leading keyframe.\n        //\n        // We have two approaches to repairing this situation:\n        // 1) GOP-FUSION:\n        //    This is where we keep track of the GOPS (group-of-pictures)\n        //    from previous fragments and attempt to find one that we can\n        //    prepend to the current fragment in order to create a valid\n        //    fragment.\n        // 2) KEYFRAME-PULLING:\n        //    Here we search for the first keyframe in the fragment and\n        //    throw away all the frames between the start of the fragment\n        //    and that keyframe. We then extend the duration and pull the\n        //    PTS of the keyframe forward so that it covers the time range\n        //    of the frames that were disposed of.\n        //\n        // #1 is far prefereable over #2 which can cause \"stuttering\" but\n        // requires more things to be just right.\n\n        if (!gops[0][0].keyFrame) {\n          // Search for a gop for fusion from our gopCache\n          gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n          if (gopForFusion) {\n            // in order to provide more accurate timing information about the segment, save\n            // the number of seconds prepended to the original segment due to GOP fusion\n            prependedContentDuration = gopForFusion.duration;\n            gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n            // new gop at the beginning\n\n            gops.byteLength += gopForFusion.byteLength;\n            gops.nalCount += gopForFusion.nalCount;\n            gops.pts = gopForFusion.pts;\n            gops.dts = gopForFusion.dts;\n            gops.duration += gopForFusion.duration;\n          } else {\n            // If we didn't find a candidate gop fall back to keyframe-pulling\n            gops = frameUtils.extendFirstKeyFrame(gops);\n          }\n        } // Trim gops to align with gopsToAlignWith\n\n\n        if (gopsToAlignWith.length) {\n          var alignedGops;\n\n          if (options.alignGopsAtEnd) {\n            alignedGops = this.alignGopsAtEnd_(gops);\n          } else {\n            alignedGops = this.alignGopsAtStart_(gops);\n          }\n\n          if (!alignedGops) {\n            // save all the nals in the last GOP into the gop cache\n            this.gopCache_.unshift({\n              gop: gops.pop(),\n              pps: track.pps,\n              sps: track.sps\n            }); // Keep a maximum of 6 GOPs in the cache\n\n            this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n            nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n            this.resetStream_();\n            this.trigger('done', 'VideoSegmentStream');\n            return;\n          } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n          // when recalculated before sending off to CoalesceStream\n\n\n          trackDecodeInfo.clearDtsInfo(track);\n          gops = alignedGops;\n        }\n\n        trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n        // samples (that is, frames) in the video data\n\n        track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n        mdat = mp4Generator.mdat(frameUtils.concatenateNalData(gops));\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n        this.trigger('processedGopsInfo', gops.map(function (gop) {\n          return {\n            pts: gop.pts,\n            dts: gop.dts,\n            byteLength: gop.byteLength\n          };\n        }));\n        firstGop = gops[0];\n        lastGop = gops[gops.length - 1];\n        this.trigger('segmentTimingInfo', generateVideoSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n        this.trigger('timingInfo', {\n          start: gops[0].pts,\n          end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n        }); // save all the nals in the last GOP into the gop cache\n\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        }); // Keep a maximum of 6 GOPs in the cache\n\n        this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n        nalUnits = [];\n        this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n        this.trigger('timelineStartInfo', track.timelineStartInfo);\n        moof = mp4Generator.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n        // throwing away hundreds of media segment fragments\n\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n        sequenceNumber++;\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        this.trigger('data', {\n          track: track,\n          boxes: boxes\n        });\n        this.resetStream_(); // Continue with the flush process now\n\n        this.trigger('done', 'VideoSegmentStream');\n      };\n\n      this.reset = function () {\n        this.resetStream_();\n        nalUnits = [];\n        this.gopCache_.length = 0;\n        gopsToAlignWith.length = 0;\n        this.trigger('reset');\n      };\n\n      this.resetStream_ = function () {\n        trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n        // for instance, when we are rendition switching\n\n        config = undefined;\n        pps = undefined;\n      }; // Search for a candidate Gop for gop-fusion from the gop cache and\n      // return it or return null if no good candidate was found\n\n\n      this.getGopForFusion_ = function (nalUnit) {\n        var halfSecond = 45000,\n            // Half-a-second in a 90khz clock\n        allowableOverlap = 10000,\n            // About 3 frames @ 30fps\n        nearestDistance = Infinity,\n            dtsDistance,\n            nearestGopObj,\n            currentGop,\n            currentGopObj,\n            i; // Search for the GOP nearest to the beginning of this nal unit\n\n        for (i = 0; i < this.gopCache_.length; i++) {\n          currentGopObj = this.gopCache_[i];\n          currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n          if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n            continue;\n          } // Reject Gops that would require a negative baseMediaDecodeTime\n\n\n          if (currentGop.dts < track.timelineStartInfo.dts) {\n            continue;\n          } // The distance between the end of the gop and the start of the nalUnit\n\n\n          dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n          // a half-second of the nal unit\n\n          if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n            // Always use the closest GOP we found if there is more than\n            // one candidate\n            if (!nearestGopObj || nearestDistance > dtsDistance) {\n              nearestGopObj = currentGopObj;\n              nearestDistance = dtsDistance;\n            }\n          }\n        }\n\n        if (nearestGopObj) {\n          return nearestGopObj.gop;\n        }\n\n        return null;\n      }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n      // of gopsToAlignWith starting from the START of the list\n\n\n      this.alignGopsAtStart_ = function (gops) {\n        var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n        byteLength = gops.byteLength;\n        nalCount = gops.nalCount;\n        duration = gops.duration;\n        alignIndex = gopIndex = 0;\n\n        while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n          align = gopsToAlignWith[alignIndex];\n          gop = gops[gopIndex];\n\n          if (align.pts === gop.pts) {\n            break;\n          }\n\n          if (gop.pts > align.pts) {\n            // this current gop starts after the current gop we want to align on, so increment\n            // align index\n            alignIndex++;\n            continue;\n          } // current gop starts before the current gop we want to align on. so increment gop\n          // index\n\n\n          gopIndex++;\n          byteLength -= gop.byteLength;\n          nalCount -= gop.nalCount;\n          duration -= gop.duration;\n        }\n\n        if (gopIndex === 0) {\n          // no gops to trim\n          return gops;\n        }\n\n        if (gopIndex === gops.length) {\n          // all gops trimmed, skip appending all gops\n          return null;\n        }\n\n        alignedGops = gops.slice(gopIndex);\n        alignedGops.byteLength = byteLength;\n        alignedGops.duration = duration;\n        alignedGops.nalCount = nalCount;\n        alignedGops.pts = alignedGops[0].pts;\n        alignedGops.dts = alignedGops[0].dts;\n        return alignedGops;\n      }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n      // of gopsToAlignWith starting from the END of the list\n\n\n      this.alignGopsAtEnd_ = function (gops) {\n        var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n        alignIndex = gopsToAlignWith.length - 1;\n        gopIndex = gops.length - 1;\n        alignEndIndex = null;\n        matchFound = false;\n\n        while (alignIndex >= 0 && gopIndex >= 0) {\n          align = gopsToAlignWith[alignIndex];\n          gop = gops[gopIndex];\n\n          if (align.pts === gop.pts) {\n            matchFound = true;\n            break;\n          }\n\n          if (align.pts > gop.pts) {\n            alignIndex--;\n            continue;\n          }\n\n          if (alignIndex === gopsToAlignWith.length - 1) {\n            // gop.pts is greater than the last alignment candidate. If no match is found\n            // by the end of this loop, we still want to append gops that come after this\n            // point\n            alignEndIndex = gopIndex;\n          }\n\n          gopIndex--;\n        }\n\n        if (!matchFound && alignEndIndex === null) {\n          return null;\n        }\n\n        var trimIndex;\n\n        if (matchFound) {\n          trimIndex = gopIndex;\n        } else {\n          trimIndex = alignEndIndex;\n        }\n\n        if (trimIndex === 0) {\n          return gops;\n        }\n\n        var alignedGops = gops.slice(trimIndex);\n        var metadata = alignedGops.reduce(function (total, gop) {\n          total.byteLength += gop.byteLength;\n          total.duration += gop.duration;\n          total.nalCount += gop.nalCount;\n          return total;\n        }, {\n          byteLength: 0,\n          duration: 0,\n          nalCount: 0\n        });\n        alignedGops.byteLength = metadata.byteLength;\n        alignedGops.duration = metadata.duration;\n        alignedGops.nalCount = metadata.nalCount;\n        alignedGops.pts = alignedGops[0].pts;\n        alignedGops.dts = alignedGops[0].dts;\n        return alignedGops;\n      };\n\n      this.alignGopsWith = function (newGopsToAlignWith) {\n        gopsToAlignWith = newGopsToAlignWith;\n      };\n    };\n\n    _VideoSegmentStream.prototype = new stream();\n    /**\n     * A Stream that can combine multiple streams (ie. audio & video)\n     * into a single output segment for MSE. Also supports audio-only\n     * and video-only streams.\n     * @param options {object} transmuxer options object\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at media timeline start.\n     */\n\n    _CoalesceStream = function CoalesceStream(options, metadataStream) {\n      // Number of Tracks per output segment\n      // If greater than 1, we combine multiple\n      // tracks into a single segment\n      this.numberOfTracks = 0;\n      this.metadataStream = metadataStream;\n      options = options || {};\n\n      if (typeof options.remux !== 'undefined') {\n        this.remuxTracks = !!options.remux;\n      } else {\n        this.remuxTracks = true;\n      }\n\n      if (typeof options.keepOriginalTimestamps === 'boolean') {\n        this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n      } else {\n        this.keepOriginalTimestamps = false;\n      }\n\n      this.pendingTracks = [];\n      this.videoTrack = null;\n      this.pendingBoxes = [];\n      this.pendingCaptions = [];\n      this.pendingMetadata = [];\n      this.pendingBytes = 0;\n      this.emittedTracks = 0;\n\n      _CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n\n      this.push = function (output) {\n        // buffer incoming captions until the associated video segment\n        // finishes\n        if (output.text) {\n          return this.pendingCaptions.push(output);\n        } // buffer incoming id3 tags until the final flush\n\n\n        if (output.frames) {\n          return this.pendingMetadata.push(output);\n        } // Add this track to the list of pending tracks and store\n        // important information required for the construction of\n        // the final segment\n\n\n        this.pendingTracks.push(output.track);\n        this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n        // We unshift audio and push video because\n        // as of Chrome 75 when switching from\n        // one init segment to another if the video\n        // mdat does not appear after the audio mdat\n        // only audio will play for the duration of our transmux.\n\n        if (output.track.type === 'video') {\n          this.videoTrack = output.track;\n          this.pendingBoxes.push(output.boxes);\n        }\n\n        if (output.track.type === 'audio') {\n          this.audioTrack = output.track;\n          this.pendingBoxes.unshift(output.boxes);\n        }\n      };\n    };\n\n    _CoalesceStream.prototype = new stream();\n\n    _CoalesceStream.prototype.flush = function (flushSource) {\n      var offset = 0,\n          event = {\n        captions: [],\n        captionStreams: {},\n        metadata: [],\n        info: {}\n      },\n          caption,\n          id3,\n          initSegment,\n          timelineStartPts = 0,\n          i;\n\n      if (this.pendingTracks.length < this.numberOfTracks) {\n        if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n          // Return because we haven't received a flush from a data-generating\n          // portion of the segment (meaning that we have only recieved meta-data\n          // or captions.)\n          return;\n        } else if (this.remuxTracks) {\n          // Return until we have enough tracks from the pipeline to remux (if we\n          // are remuxing audio and video into a single MP4)\n          return;\n        } else if (this.pendingTracks.length === 0) {\n          // In the case where we receive a flush without any data having been\n          // received we consider it an emitted track for the purposes of coalescing\n          // `done` events.\n          // We do this for the case where there is an audio and video track in the\n          // segment but no audio data. (seen in several playlists with alternate\n          // audio tracks and no audio present in the main TS segments.)\n          this.emittedTracks++;\n\n          if (this.emittedTracks >= this.numberOfTracks) {\n            this.trigger('done');\n            this.emittedTracks = 0;\n          }\n\n          return;\n        }\n      }\n\n      if (this.videoTrack) {\n        timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n        videoProperties.forEach(function (prop) {\n          event.info[prop] = this.videoTrack[prop];\n        }, this);\n      } else if (this.audioTrack) {\n        timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n        audioProperties.forEach(function (prop) {\n          event.info[prop] = this.audioTrack[prop];\n        }, this);\n      }\n\n      if (this.videoTrack || this.audioTrack) {\n        if (this.pendingTracks.length === 1) {\n          event.type = this.pendingTracks[0].type;\n        } else {\n          event.type = 'combined';\n        }\n\n        this.emittedTracks += this.pendingTracks.length;\n        initSegment = mp4Generator.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n        event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n        // and track definitions\n\n        event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n        event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n        for (i = 0; i < this.pendingBoxes.length; i++) {\n          event.data.set(this.pendingBoxes[i], offset);\n          offset += this.pendingBoxes[i].byteLength;\n        } // Translate caption PTS times into second offsets to match the\n        // video timeline for the segment, and add track info\n\n\n        for (i = 0; i < this.pendingCaptions.length; i++) {\n          caption = this.pendingCaptions[i];\n          caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n          caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n          event.captionStreams[caption.stream] = true;\n          event.captions.push(caption);\n        } // Translate ID3 frame PTS times into second offsets to match the\n        // video timeline for the segment\n\n\n        for (i = 0; i < this.pendingMetadata.length; i++) {\n          id3 = this.pendingMetadata[i];\n          id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n          event.metadata.push(id3);\n        } // We add this to every single emitted segment even though we only need\n        // it for the first\n\n\n        event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n        this.pendingTracks.length = 0;\n        this.videoTrack = null;\n        this.pendingBoxes.length = 0;\n        this.pendingCaptions.length = 0;\n        this.pendingBytes = 0;\n        this.pendingMetadata.length = 0; // Emit the built segment\n        // We include captions and ID3 tags for backwards compatibility,\n        // ideally we should send only video and audio in the data event\n\n        this.trigger('data', event); // Emit each caption to the outside world\n        // Ideally, this would happen immediately on parsing captions,\n        // but we need to ensure that video data is sent back first\n        // so that caption timing can be adjusted to match video timing\n\n        for (i = 0; i < event.captions.length; i++) {\n          caption = event.captions[i];\n          this.trigger('caption', caption);\n        } // Emit each id3 tag to the outside world\n        // Ideally, this would happen immediately on parsing the tag,\n        // but we need to ensure that video data is sent back first\n        // so that ID3 frame timing can be adjusted to match video timing\n\n\n        for (i = 0; i < event.metadata.length; i++) {\n          id3 = event.metadata[i];\n          this.trigger('id3Frame', id3);\n        }\n      } // Only emit `done` if all tracks have been flushed and emitted\n\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n    };\n\n    _CoalesceStream.prototype.setRemux = function (val) {\n      this.remuxTracks = val;\n    };\n    /**\n     * A Stream that expects MP2T binary data as input and produces\n     * corresponding media segments, suitable for use with Media Source\n     * Extension (MSE) implementations that support the ISO BMFF byte\n     * stream format, like Chrome.\n     */\n\n\n    _Transmuxer = function Transmuxer(options) {\n      var self = this,\n          hasFlushed = true,\n          videoTrack,\n          audioTrack;\n\n      _Transmuxer.prototype.init.call(this);\n\n      options = options || {};\n      this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n      this.transmuxPipeline_ = {};\n\n      this.setupAacPipeline = function () {\n        var pipeline = {};\n        this.transmuxPipeline_ = pipeline;\n        pipeline.type = 'aac';\n        pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n        pipeline.aacStream = new aac();\n        pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n        pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n        pipeline.adtsStream = new adts();\n        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n        pipeline.headOfPipeline = pipeline.aacStream;\n        pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n        pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n        pipeline.metadataStream.on('timestamp', function (frame) {\n          pipeline.aacStream.setTimestamp(frame.timeStamp);\n        });\n        pipeline.aacStream.on('data', function (data) {\n          if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n            return;\n          }\n\n          audioTrack = audioTrack || {\n            timelineStartInfo: {\n              baseMediaDecodeTime: self.baseMediaDecodeTime\n            },\n            codec: 'adts',\n            type: 'audio'\n          }; // hook up the audio segment stream to the first track with aac data\n\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\n          pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n          pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n          self.trigger('trackinfo', {\n            hasAudio: !!audioTrack,\n            hasVideo: !!videoTrack\n          });\n        }); // Re-emit any data coming from the coalesce stream to the outside world\n\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      };\n\n      this.setupTsPipeline = function () {\n        var pipeline = {};\n        this.transmuxPipeline_ = pipeline;\n        pipeline.type = 'ts';\n        pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n        pipeline.packetStream = new m2ts_1.TransportPacketStream();\n        pipeline.parseStream = new m2ts_1.TransportParseStream();\n        pipeline.elementaryStream = new m2ts_1.ElementaryStream();\n        pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();\n        pipeline.adtsStream = new adts();\n        pipeline.h264Stream = new H264Stream$1();\n        pipeline.captionStream = new m2ts_1.CaptionStream();\n        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n        pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n        pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n        // demux the streams\n\n        pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n        pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n        pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n        pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n        pipeline.elementaryStream.on('data', function (data) {\n          var i;\n\n          if (data.type === 'metadata') {\n            i = data.tracks.length; // scan the tracks listed in the metadata\n\n            while (i--) {\n              if (!videoTrack && data.tracks[i].type === 'video') {\n                videoTrack = data.tracks[i];\n                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n              } else if (!audioTrack && data.tracks[i].type === 'audio') {\n                audioTrack = data.tracks[i];\n                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n              }\n            } // hook up the video segment stream to the first track with h264 data\n\n\n            if (videoTrack && !pipeline.videoSegmentStream) {\n              pipeline.coalesceStream.numberOfTracks++;\n              pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);\n              pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n                // When video emits timelineStartInfo data after a flush, we forward that\n                // info to the AudioSegmentStream, if it exists, because video timeline\n                // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n                // because this is a particularly subtle form of timestamp alteration.\n                if (audioTrack && !options.keepOriginalTimestamps) {\n                  audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n                  // very earliest DTS we have seen in video because Chrome will\n                  // interpret any video track with a baseMediaDecodeTime that is\n                  // non-zero as a gap.\n\n                  pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n                }\n              });\n              pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n              pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n              pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n                if (audioTrack) {\n                  pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n                }\n              });\n              pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n              pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n            }\n\n            if (audioTrack && !pipeline.audioSegmentStream) {\n              // hook up the audio segment stream to the first track with aac data\n              pipeline.coalesceStream.numberOfTracks++;\n              pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\n              pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n              pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n            } // emit pmt info\n\n\n            self.trigger('trackinfo', {\n              hasAudio: !!audioTrack,\n              hasVideo: !!videoTrack\n            });\n          }\n        }); // Re-emit any data coming from the coalesce stream to the outside world\n\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n        pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n          id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n          self.trigger('id3Frame', id3Frame);\n        });\n        pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      }; // hook up the segment streams once track metadata is delivered\n\n\n      this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        var pipeline = this.transmuxPipeline_;\n\n        if (!options.keepOriginalTimestamps) {\n          this.baseMediaDecodeTime = baseMediaDecodeTime;\n        }\n\n        if (audioTrack) {\n          audioTrack.timelineStartInfo.dts = undefined;\n          audioTrack.timelineStartInfo.pts = undefined;\n          trackDecodeInfo.clearDtsInfo(audioTrack);\n\n          if (pipeline.audioTimestampRolloverStream) {\n            pipeline.audioTimestampRolloverStream.discontinuity();\n          }\n        }\n\n        if (videoTrack) {\n          if (pipeline.videoSegmentStream) {\n            pipeline.videoSegmentStream.gopCache_ = [];\n          }\n\n          videoTrack.timelineStartInfo.dts = undefined;\n          videoTrack.timelineStartInfo.pts = undefined;\n          trackDecodeInfo.clearDtsInfo(videoTrack);\n          pipeline.captionStream.reset();\n        }\n\n        if (pipeline.timestampRolloverStream) {\n          pipeline.timestampRolloverStream.discontinuity();\n        }\n      };\n\n      this.setAudioAppendStart = function (timestamp) {\n        if (audioTrack) {\n          this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n        }\n      };\n\n      this.setRemux = function (val) {\n        var pipeline = this.transmuxPipeline_;\n        options.remux = val;\n\n        if (pipeline && pipeline.coalesceStream) {\n          pipeline.coalesceStream.setRemux(val);\n        }\n      };\n\n      this.alignGopsWith = function (gopsToAlignWith) {\n        if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n          this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n        }\n      }; // feed incoming data to the front of the parsing pipeline\n\n\n      this.push = function (data) {\n        if (hasFlushed) {\n          var isAac = isLikelyAacData$1(data);\n\n          if (isAac && this.transmuxPipeline_.type !== 'aac') {\n            this.setupAacPipeline();\n          } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n            this.setupTsPipeline();\n          }\n\n          hasFlushed = false;\n        }\n\n        this.transmuxPipeline_.headOfPipeline.push(data);\n      }; // flush any buffered data\n\n\n      this.flush = function () {\n        hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n        this.transmuxPipeline_.headOfPipeline.flush();\n      };\n\n      this.endTimeline = function () {\n        this.transmuxPipeline_.headOfPipeline.endTimeline();\n      };\n\n      this.reset = function () {\n        if (this.transmuxPipeline_.headOfPipeline) {\n          this.transmuxPipeline_.headOfPipeline.reset();\n        }\n      }; // Caption data has to be reset when seeking outside buffered range\n\n\n      this.resetCaptions = function () {\n        if (this.transmuxPipeline_.captionStream) {\n          this.transmuxPipeline_.captionStream.reset();\n        }\n      };\n    };\n\n    _Transmuxer.prototype = new stream();\n    var transmuxer = {\n      Transmuxer: _Transmuxer,\n      VideoSegmentStream: _VideoSegmentStream,\n      AudioSegmentStream: _AudioSegmentStream,\n      AUDIO_PROPERTIES: audioProperties,\n      VIDEO_PROPERTIES: videoProperties,\n      // exported for testing\n      generateVideoSegmentTimingInfo: generateVideoSegmentTimingInfo\n    };\n    var transmuxer_1 = transmuxer.Transmuxer;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var codecs = {\n      Adts: adts,\n      h264: h264\n    };\n    var ONE_SECOND_IN_TS$4 = clock.ONE_SECOND_IN_TS;\n    /**\n     * Constructs a single-track, ISO BMFF media segment from AAC data\n     * events. The output of this stream can be fed to a SourceBuffer\n     * configured with a suitable initialization segment.\n     */\n\n    var AudioSegmentStream$1 = function AudioSegmentStream$1(track, options) {\n      var adtsFrames = [],\n          sequenceNumber = 0,\n          earliestAllowedDts = 0,\n          audioAppendStartTs = 0,\n          videoBaseMediaDecodeTime = Infinity,\n          segmentStartPts = null,\n          segmentEndPts = null;\n      options = options || {};\n      AudioSegmentStream$1.prototype.init.call(this);\n\n      this.push = function (data) {\n        trackDecodeInfo.collectDtsInfo(track, data);\n\n        if (track) {\n          audioProperties.forEach(function (prop) {\n            track[prop] = data[prop];\n          });\n        } // buffer audio data until end() is called\n\n\n        adtsFrames.push(data);\n      };\n\n      this.setEarliestDts = function (earliestDts) {\n        earliestAllowedDts = earliestDts;\n      };\n\n      this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        videoBaseMediaDecodeTime = baseMediaDecodeTime;\n      };\n\n      this.setAudioAppendStart = function (timestamp) {\n        audioAppendStartTs = timestamp;\n      };\n\n      this.processFrames_ = function () {\n        var frames, moof, mdat, boxes, timingInfo; // return early if no audio data has been observed\n\n        if (adtsFrames.length === 0) {\n          return;\n        }\n\n        frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n\n        if (frames.length === 0) {\n          // return early if the frames are all after the earliest allowed DTS\n          // TODO should we clear the adtsFrames?\n          return;\n        }\n\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n        audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n        // samples (that is, adts frames) in the audio data\n\n        track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n        mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n        adtsFrames = [];\n        moof = mp4Generator.moof(sequenceNumber, [track]); // bump the sequence number for next time\n\n        sequenceNumber++;\n        track.initSegment = mp4Generator.initSegment([track]); // it would be great to allocate this array up front instead of\n        // throwing away hundreds of media segment fragments\n\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        trackDecodeInfo.clearDtsInfo(track);\n\n        if (segmentStartPts === null) {\n          segmentEndPts = segmentStartPts = frames[0].pts;\n        }\n\n        segmentEndPts += frames.length * (ONE_SECOND_IN_TS$4 * 1024 / track.samplerate);\n        timingInfo = {\n          start: segmentStartPts\n        };\n        this.trigger('timingInfo', timingInfo);\n        this.trigger('data', {\n          track: track,\n          boxes: boxes\n        });\n      };\n\n      this.flush = function () {\n        this.processFrames_(); // trigger final timing info\n\n        this.trigger('timingInfo', {\n          start: segmentStartPts,\n          end: segmentEndPts\n        });\n        this.resetTiming_();\n        this.trigger('done', 'AudioSegmentStream');\n      };\n\n      this.partialFlush = function () {\n        this.processFrames_();\n        this.trigger('partialdone', 'AudioSegmentStream');\n      };\n\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline', 'AudioSegmentStream');\n      };\n\n      this.resetTiming_ = function () {\n        trackDecodeInfo.clearDtsInfo(track);\n        segmentStartPts = null;\n        segmentEndPts = null;\n      };\n\n      this.reset = function () {\n        this.resetTiming_();\n        adtsFrames = [];\n        this.trigger('reset');\n      };\n    };\n\n    AudioSegmentStream$1.prototype = new stream();\n    var audioSegmentStream = AudioSegmentStream$1;\n\n    var VideoSegmentStream$1 = function VideoSegmentStream$1(track, options) {\n      var sequenceNumber = 0,\n          nalUnits = [],\n          frameCache = [],\n          // gopsToAlignWith = [],\n      config,\n          pps,\n          segmentStartPts = null,\n          segmentEndPts = null,\n          gops,\n          ensureNextFrameIsKeyFrame = true;\n      options = options || {};\n      VideoSegmentStream$1.prototype.init.call(this);\n\n      this.push = function (nalUnit) {\n        trackDecodeInfo.collectDtsInfo(track, nalUnit);\n\n        if (typeof track.timelineStartInfo.dts === 'undefined') {\n          track.timelineStartInfo.dts = nalUnit.dts;\n        } // record the track config\n\n\n        if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n          config = nalUnit.config;\n          track.sps = [nalUnit.data];\n          videoProperties.forEach(function (prop) {\n            track[prop] = config[prop];\n          }, this);\n        }\n\n        if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n          pps = nalUnit.data;\n          track.pps = [nalUnit.data];\n        } // buffer video until flush() is called\n\n\n        nalUnits.push(nalUnit);\n      };\n\n      this.processNals_ = function (cacheLastFrame) {\n        var i;\n        nalUnits = frameCache.concat(nalUnits); // Throw away nalUnits at the start of the byte stream until\n        // we find the first AUD\n\n        while (nalUnits.length) {\n          if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n            break;\n          }\n\n          nalUnits.shift();\n        } // Return early if no video data has been observed\n\n\n        if (nalUnits.length === 0) {\n          return;\n        }\n\n        var frames = frameUtils.groupNalsIntoFrames(nalUnits);\n\n        if (!frames.length) {\n          return;\n        } // note that the frame cache may also protect us from cases where we haven't\n        // pushed data for the entire first or last frame yet\n\n\n        frameCache = frames[frames.length - 1];\n\n        if (cacheLastFrame) {\n          frames.pop();\n          frames.duration -= frameCache.duration;\n          frames.nalCount -= frameCache.length;\n          frames.byteLength -= frameCache.byteLength;\n        }\n\n        if (!frames.length) {\n          nalUnits = [];\n          return;\n        }\n\n        this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n        if (ensureNextFrameIsKeyFrame) {\n          gops = frameUtils.groupFramesIntoGops(frames);\n\n          if (!gops[0][0].keyFrame) {\n            gops = frameUtils.extendFirstKeyFrame(gops);\n\n            if (!gops[0][0].keyFrame) {\n              // we haven't yet gotten a key frame, so reset nal units to wait for more nal\n              // units\n              nalUnits = [].concat.apply([], frames).concat(frameCache);\n              frameCache = [];\n              return;\n            }\n\n            frames = [].concat.apply([], gops);\n            frames.duration = gops.duration;\n          }\n\n          ensureNextFrameIsKeyFrame = false;\n        }\n\n        if (segmentStartPts === null) {\n          segmentStartPts = frames[0].pts;\n          segmentEndPts = segmentStartPts;\n        }\n\n        segmentEndPts += frames.duration;\n        this.trigger('timingInfo', {\n          start: segmentStartPts,\n          end: segmentEndPts\n        });\n\n        for (i = 0; i < frames.length; i++) {\n          var frame = frames[i];\n          track.samples = frameUtils.generateSampleTableForFrame(frame);\n          var mdat = mp4Generator.mdat(frameUtils.concatenateNalDataForFrame(frame));\n          trackDecodeInfo.clearDtsInfo(track);\n          trackDecodeInfo.collectDtsInfo(track, frame);\n          track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n          var moof = mp4Generator.moof(sequenceNumber, [track]);\n          sequenceNumber++;\n          track.initSegment = mp4Generator.initSegment([track]);\n          var boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n          boxes.set(moof);\n          boxes.set(mdat, moof.byteLength);\n          this.trigger('data', {\n            track: track,\n            boxes: boxes,\n            sequence: sequenceNumber,\n            videoFrameDts: frame.dts,\n            videoFramePts: frame.pts\n          });\n        }\n\n        nalUnits = [];\n      };\n\n      this.resetTimingAndConfig_ = function () {\n        config = undefined;\n        pps = undefined;\n        segmentStartPts = null;\n        segmentEndPts = null;\n      };\n\n      this.partialFlush = function () {\n        this.processNals_(true);\n        this.trigger('partialdone', 'VideoSegmentStream');\n      };\n\n      this.flush = function () {\n        this.processNals_(false); // reset config and pps because they may differ across segments\n        // for instance, when we are rendition switching\n\n        this.resetTimingAndConfig_();\n        this.trigger('done', 'VideoSegmentStream');\n      };\n\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline', 'VideoSegmentStream');\n      };\n\n      this.reset = function () {\n        this.resetTimingAndConfig_();\n        frameCache = [];\n        nalUnits = [];\n        ensureNextFrameIsKeyFrame = true;\n        this.trigger('reset');\n      };\n    };\n\n    VideoSegmentStream$1.prototype = new stream();\n    var videoSegmentStream = VideoSegmentStream$1;\n    var isLikelyAacData$2 = utils.isLikelyAacData;\n\n    var createPipeline = function createPipeline(object) {\n      object.prototype = new stream();\n      object.prototype.init.call(object);\n      return object;\n    };\n\n    var tsPipeline = function tsPipeline(options) {\n      var pipeline = {\n        type: 'ts',\n        tracks: {\n          audio: null,\n          video: null\n        },\n        packet: new m2ts_1.TransportPacketStream(),\n        parse: new m2ts_1.TransportParseStream(),\n        elementary: new m2ts_1.ElementaryStream(),\n        timestampRollover: new m2ts_1.TimestampRolloverStream(),\n        adts: new codecs.Adts(),\n        h264: new codecs.h264.H264Stream(),\n        captionStream: new m2ts_1.CaptionStream(),\n        metadataStream: new m2ts_1.MetadataStream()\n      };\n      pipeline.headOfPipeline = pipeline.packet; // Transport Stream\n\n      pipeline.packet.pipe(pipeline.parse).pipe(pipeline.elementary).pipe(pipeline.timestampRollover); // H264\n\n      pipeline.timestampRollover.pipe(pipeline.h264); // Hook up CEA-608/708 caption stream\n\n      pipeline.h264.pipe(pipeline.captionStream);\n      pipeline.timestampRollover.pipe(pipeline.metadataStream); // ADTS\n\n      pipeline.timestampRollover.pipe(pipeline.adts);\n      pipeline.elementary.on('data', function (data) {\n        if (data.type !== 'metadata') {\n          return;\n        }\n\n        for (var i = 0; i < data.tracks.length; i++) {\n          if (!pipeline.tracks[data.tracks[i].type]) {\n            pipeline.tracks[data.tracks[i].type] = data.tracks[i];\n            pipeline.tracks[data.tracks[i].type].timelineStartInfo.baseMediaDecodeTime = options.baseMediaDecodeTime;\n          }\n        }\n\n        if (pipeline.tracks.video && !pipeline.videoSegmentStream) {\n          pipeline.videoSegmentStream = new videoSegmentStream(pipeline.tracks.video, options);\n          pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n            if (pipeline.tracks.audio && !options.keepOriginalTimestamps) {\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - options.baseMediaDecodeTime);\n            }\n          });\n          pipeline.videoSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'videoTimingInfo'));\n          pipeline.videoSegmentStream.on('data', function (data) {\n            pipeline.trigger('data', {\n              type: 'video',\n              data: data\n            });\n          });\n          pipeline.videoSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n          pipeline.videoSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n          pipeline.videoSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n          pipeline.h264.pipe(pipeline.videoSegmentStream);\n        }\n\n        if (pipeline.tracks.audio && !pipeline.audioSegmentStream) {\n          pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n          pipeline.audioSegmentStream.on('data', function (data) {\n            pipeline.trigger('data', {\n              type: 'audio',\n              data: data\n            });\n          });\n          pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n          pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n          pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n          pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo'));\n          pipeline.adts.pipe(pipeline.audioSegmentStream);\n        } // emit pmt info\n\n\n        pipeline.trigger('trackinfo', {\n          hasAudio: !!pipeline.tracks.audio,\n          hasVideo: !!pipeline.tracks.video\n        });\n      });\n      pipeline.captionStream.on('data', function (caption) {\n        var timelineStartPts;\n\n        if (pipeline.tracks.video) {\n          timelineStartPts = pipeline.tracks.video.timelineStartInfo.pts || 0;\n        } else {\n          // This will only happen if we encounter caption packets before\n          // video data in a segment. This is an unusual/unlikely scenario,\n          // so we assume the timeline starts at zero for now.\n          timelineStartPts = 0;\n        } // Translate caption PTS times into second offsets into the\n        // video timeline for the segment\n\n\n        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, options.keepOriginalTimestamps);\n        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, options.keepOriginalTimestamps);\n        pipeline.trigger('caption', caption);\n      });\n      pipeline = createPipeline(pipeline);\n      pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n      return pipeline;\n    };\n\n    var aacPipeline = function aacPipeline(options) {\n      var pipeline = {\n        type: 'aac',\n        tracks: {\n          audio: null\n        },\n        metadataStream: new m2ts_1.MetadataStream(),\n        aacStream: new aac(),\n        audioRollover: new m2ts_1.TimestampRolloverStream('audio'),\n        timedMetadataRollover: new m2ts_1.TimestampRolloverStream('timed-metadata'),\n        adtsStream: new adts(true)\n      }; // set up the parsing pipeline\n\n      pipeline.headOfPipeline = pipeline.aacStream;\n      pipeline.aacStream.pipe(pipeline.audioRollover).pipe(pipeline.adtsStream);\n      pipeline.aacStream.pipe(pipeline.timedMetadataRollover).pipe(pipeline.metadataStream);\n      pipeline.metadataStream.on('timestamp', function (frame) {\n        pipeline.aacStream.setTimestamp(frame.timeStamp);\n      });\n      pipeline.aacStream.on('data', function (data) {\n        if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n          return;\n        }\n\n        pipeline.tracks.audio = pipeline.tracks.audio || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: options.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        }; // hook up the audio segment stream to the first track with aac data\n\n        pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n        pipeline.audioSegmentStream.on('data', function (data) {\n          pipeline.trigger('data', {\n            type: 'audio',\n            data: data\n          });\n        });\n        pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n        pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n        pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n        pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n        pipeline.adtsStream.pipe(pipeline.audioSegmentStream);\n        pipeline.trigger('trackinfo', {\n          hasAudio: !!pipeline.tracks.audio,\n          hasVideo: !!pipeline.tracks.video\n        });\n      }); // set the pipeline up as a stream before binding to get access to the trigger function\n\n      pipeline = createPipeline(pipeline);\n      pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n      return pipeline;\n    };\n\n    var setupPipelineListeners = function setupPipelineListeners(pipeline, transmuxer) {\n      pipeline.on('data', transmuxer.trigger.bind(transmuxer, 'data'));\n      pipeline.on('done', transmuxer.trigger.bind(transmuxer, 'done'));\n      pipeline.on('partialdone', transmuxer.trigger.bind(transmuxer, 'partialdone'));\n      pipeline.on('endedtimeline', transmuxer.trigger.bind(transmuxer, 'endedtimeline'));\n      pipeline.on('audioTimingInfo', transmuxer.trigger.bind(transmuxer, 'audioTimingInfo'));\n      pipeline.on('videoTimingInfo', transmuxer.trigger.bind(transmuxer, 'videoTimingInfo'));\n      pipeline.on('trackinfo', transmuxer.trigger.bind(transmuxer, 'trackinfo'));\n      pipeline.on('id3Frame', function (event) {\n        // add this to every single emitted segment even though it's only needed for the first\n        event.dispatchType = pipeline.metadataStream.dispatchType; // keep original time, can be adjusted if needed at a higher level\n\n        event.cueTime = clock.videoTsToSeconds(event.pts);\n        transmuxer.trigger('id3Frame', event);\n      });\n      pipeline.on('caption', function (event) {\n        transmuxer.trigger('caption', event);\n      });\n    };\n\n    var Transmuxer$1 = function Transmuxer$1(options) {\n      var pipeline = null,\n          hasFlushed = true;\n      options = options || {};\n      Transmuxer$1.prototype.init.call(this);\n      options.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n\n      this.push = function (bytes) {\n        if (hasFlushed) {\n          var isAac = isLikelyAacData$2(bytes);\n\n          if (isAac && (!pipeline || pipeline.type !== 'aac')) {\n            pipeline = aacPipeline(options);\n            setupPipelineListeners(pipeline, this);\n          } else if (!isAac && (!pipeline || pipeline.type !== 'ts')) {\n            pipeline = tsPipeline(options);\n            setupPipelineListeners(pipeline, this);\n          }\n\n          hasFlushed = false;\n        }\n\n        pipeline.headOfPipeline.push(bytes);\n      };\n\n      this.flush = function () {\n        if (!pipeline) {\n          return;\n        }\n\n        hasFlushed = true;\n        pipeline.headOfPipeline.flush();\n      };\n\n      this.partialFlush = function () {\n        if (!pipeline) {\n          return;\n        }\n\n        pipeline.headOfPipeline.partialFlush();\n      };\n\n      this.endTimeline = function () {\n        if (!pipeline) {\n          return;\n        }\n\n        pipeline.headOfPipeline.endTimeline();\n      };\n\n      this.reset = function () {\n        if (!pipeline) {\n          return;\n        }\n\n        pipeline.headOfPipeline.reset();\n      };\n\n      this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        if (!options.keepOriginalTimestamps) {\n          options.baseMediaDecodeTime = baseMediaDecodeTime;\n        }\n\n        if (!pipeline) {\n          return;\n        }\n\n        if (pipeline.tracks.audio) {\n          pipeline.tracks.audio.timelineStartInfo.dts = undefined;\n          pipeline.tracks.audio.timelineStartInfo.pts = undefined;\n          trackDecodeInfo.clearDtsInfo(pipeline.tracks.audio);\n\n          if (pipeline.audioRollover) {\n            pipeline.audioRollover.discontinuity();\n          }\n        }\n\n        if (pipeline.tracks.video) {\n          if (pipeline.videoSegmentStream) {\n            pipeline.videoSegmentStream.gopCache_ = [];\n          }\n\n          pipeline.tracks.video.timelineStartInfo.dts = undefined;\n          pipeline.tracks.video.timelineStartInfo.pts = undefined;\n          trackDecodeInfo.clearDtsInfo(pipeline.tracks.video); // pipeline.captionStream.reset();\n        }\n\n        if (pipeline.timestampRollover) {\n          pipeline.timestampRollover.discontinuity();\n        }\n      };\n\n      this.setRemux = function (val) {\n        options.remux = val;\n\n        if (pipeline && pipeline.coalesceStream) {\n          pipeline.coalesceStream.setRemux(val);\n        }\n      };\n\n      this.setAudioAppendStart = function (audioAppendStart) {\n        if (!pipeline || !pipeline.tracks.audio || !pipeline.audioSegmentStream) {\n          return;\n        }\n\n        pipeline.audioSegmentStream.setAudioAppendStart(audioAppendStart);\n      }; // TODO GOP alignment support\n      // Support may be a bit trickier than with full segment appends, as GOPs may be split\n      // and processed in a more granular fashion\n\n\n      this.alignGopsWith = function (gopsToAlignWith) {\n        return;\n      };\n    };\n\n    Transmuxer$1.prototype = new stream();\n    var transmuxer$1 = Transmuxer$1;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var toUnsigned = function toUnsigned(value) {\n      return value >>> 0;\n    };\n\n    var toHexString = function toHexString(value) {\n      return ('00' + value.toString(16)).slice(-2);\n    };\n\n    var bin = {\n      toUnsigned: toUnsigned,\n      toHexString: toHexString\n    };\n\n    var parseType$1 = function parseType$1(buffer) {\n      var result = '';\n      result += String.fromCharCode(buffer[0]);\n      result += String.fromCharCode(buffer[1]);\n      result += String.fromCharCode(buffer[2]);\n      result += String.fromCharCode(buffer[3]);\n      return result;\n    };\n\n    var parseType_1 = parseType$1;\n    var toUnsigned$1 = bin.toUnsigned;\n\n    var findBox = function findBox(data, path) {\n      var results = [],\n          i,\n          size,\n          type,\n          end,\n          subresults;\n\n      if (!path.length) {\n        // short-circuit the search for empty paths\n        return null;\n      }\n\n      for (i = 0; i < data.byteLength;) {\n        size = toUnsigned$1(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n        type = parseType_1(data.subarray(i + 4, i + 8));\n        end = size > 1 ? i + size : data.byteLength;\n\n        if (type === path[0]) {\n          if (path.length === 1) {\n            // this is the end of the path and we've found the box we were\n            // looking for\n            results.push(data.subarray(i + 8, end));\n          } else {\n            // recursively search for the next box along the path\n            subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n\n            if (subresults.length) {\n              results = results.concat(subresults);\n            }\n          }\n        }\n\n        i = end;\n      } // we've finished searching all of data\n\n\n      return results;\n    };\n\n    var findBox_1 = findBox;\n    var toUnsigned$2 = bin.toUnsigned;\n\n    var tfdt = function tfdt(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        baseMediaDecodeTime: toUnsigned$2(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7])\n      };\n\n      if (result.version === 1) {\n        result.baseMediaDecodeTime *= Math.pow(2, 32);\n        result.baseMediaDecodeTime += toUnsigned$2(data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11]);\n      }\n\n      return result;\n    };\n\n    var parseTfdt = tfdt;\n\n    var parseSampleFlags = function parseSampleFlags(flags) {\n      return {\n        isLeading: (flags[0] & 0x0c) >>> 2,\n        dependsOn: flags[0] & 0x03,\n        isDependedOn: (flags[1] & 0xc0) >>> 6,\n        hasRedundancy: (flags[1] & 0x30) >>> 4,\n        paddingValue: (flags[1] & 0x0e) >>> 1,\n        isNonSyncSample: flags[1] & 0x01,\n        degradationPriority: flags[2] << 8 | flags[3]\n      };\n    };\n\n    var parseSampleFlags_1 = parseSampleFlags;\n\n    var trun$1 = function trun$1(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        samples: []\n      },\n          view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          // Flag interpretation\n      dataOffsetPresent = result.flags[2] & 0x01,\n          // compare with 2nd byte of 0x1\n      firstSampleFlagsPresent = result.flags[2] & 0x04,\n          // compare with 2nd byte of 0x4\n      sampleDurationPresent = result.flags[1] & 0x01,\n          // compare with 2nd byte of 0x100\n      sampleSizePresent = result.flags[1] & 0x02,\n          // compare with 2nd byte of 0x200\n      sampleFlagsPresent = result.flags[1] & 0x04,\n          // compare with 2nd byte of 0x400\n      sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n          // compare with 2nd byte of 0x800\n      sampleCount = view.getUint32(4),\n          offset = 8,\n          sample;\n\n      if (dataOffsetPresent) {\n        // 32 bit signed integer\n        result.dataOffset = view.getInt32(offset);\n        offset += 4;\n      } // Overrides the flags for the first sample only. The order of\n      // optional values will be: duration, size, compositionTimeOffset\n\n\n      if (firstSampleFlagsPresent && sampleCount) {\n        sample = {\n          flags: parseSampleFlags_1(data.subarray(offset, offset + 4))\n        };\n        offset += 4;\n\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n\n        if (sampleCompositionTimeOffsetPresent) {\n          if (result.version === 1) {\n            sample.compositionTimeOffset = view.getInt32(offset);\n          } else {\n            sample.compositionTimeOffset = view.getUint32(offset);\n          }\n\n          offset += 4;\n        }\n\n        result.samples.push(sample);\n        sampleCount--;\n      }\n\n      while (sampleCount--) {\n        sample = {};\n\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n\n        if (sampleFlagsPresent) {\n          sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));\n          offset += 4;\n        }\n\n        if (sampleCompositionTimeOffsetPresent) {\n          if (result.version === 1) {\n            sample.compositionTimeOffset = view.getInt32(offset);\n          } else {\n            sample.compositionTimeOffset = view.getUint32(offset);\n          }\n\n          offset += 4;\n        }\n\n        result.samples.push(sample);\n      }\n\n      return result;\n    };\n\n    var parseTrun = trun$1;\n\n    var tfhd = function tfhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        trackId: view.getUint32(4)\n      },\n          baseDataOffsetPresent = result.flags[2] & 0x01,\n          sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n          defaultSampleDurationPresent = result.flags[2] & 0x08,\n          defaultSampleSizePresent = result.flags[2] & 0x10,\n          defaultSampleFlagsPresent = result.flags[2] & 0x20,\n          durationIsEmpty = result.flags[0] & 0x010000,\n          defaultBaseIsMoof = result.flags[0] & 0x020000,\n          i;\n      i = 8;\n\n      if (baseDataOffsetPresent) {\n        i += 4; // truncate top 4 bytes\n        // FIXME: should we read the full 64 bits?\n\n        result.baseDataOffset = view.getUint32(12);\n        i += 4;\n      }\n\n      if (sampleDescriptionIndexPresent) {\n        result.sampleDescriptionIndex = view.getUint32(i);\n        i += 4;\n      }\n\n      if (defaultSampleDurationPresent) {\n        result.defaultSampleDuration = view.getUint32(i);\n        i += 4;\n      }\n\n      if (defaultSampleSizePresent) {\n        result.defaultSampleSize = view.getUint32(i);\n        i += 4;\n      }\n\n      if (defaultSampleFlagsPresent) {\n        result.defaultSampleFlags = view.getUint32(i);\n      }\n\n      if (durationIsEmpty) {\n        result.durationIsEmpty = true;\n      }\n\n      if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n        result.baseDataOffsetIsMoof = true;\n      }\n\n      return result;\n    };\n\n    var parseTfhd = tfhd;\n    var discardEmulationPreventionBytes$1 = captionPacketParser.discardEmulationPreventionBytes;\n    var CaptionStream$1 = captionStream.CaptionStream;\n    /**\n      * Maps an offset in the mdat to a sample based on the the size of the samples.\n      * Assumes that `parseSamples` has been called first.\n      *\n      * @param {Number} offset - The offset into the mdat\n      * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n      * @return {?Object} The matching sample, or null if no match was found.\n      *\n      * @see ISO-BMFF-12/2015, Section 8.8.8\n     **/\n\n    var mapToSample = function mapToSample(offset, samples) {\n      var approximateOffset = offset;\n\n      for (var i = 0; i < samples.length; i++) {\n        var sample = samples[i];\n\n        if (approximateOffset < sample.size) {\n          return sample;\n        }\n\n        approximateOffset -= sample.size;\n      }\n\n      return null;\n    };\n    /**\n      * Finds SEI nal units contained in a Media Data Box.\n      * Assumes that `parseSamples` has been called first.\n      *\n      * @param {Uint8Array} avcStream - The bytes of the mdat\n      * @param {Object[]} samples - The samples parsed out by `parseSamples`\n      * @param {Number} trackId - The trackId of this video track\n      * @return {Object[]} seiNals - the parsed SEI NALUs found.\n      *   The contents of the seiNal should match what is expected by\n      *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n      *\n      * @see ISO-BMFF-12/2015, Section 8.1.1\n      * @see Rec. ITU-T H.264, 7.3.2.3.1\n     **/\n\n\n    var findSeiNals = function findSeiNals(avcStream, samples, trackId) {\n      var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n          result = [],\n          seiNal,\n          i,\n          length,\n          lastMatchedSample;\n\n      for (i = 0; i + 4 < avcStream.length; i += length) {\n        length = avcView.getUint32(i);\n        i += 4; // Bail if this doesn't appear to be an H264 stream\n\n        if (length <= 0) {\n          continue;\n        }\n\n        switch (avcStream[i] & 0x1F) {\n          case 0x06:\n            var data = avcStream.subarray(i + 1, i + 1 + length);\n            var matchingSample = mapToSample(i, samples);\n            seiNal = {\n              nalUnitType: 'sei_rbsp',\n              size: length,\n              data: data,\n              escapedRBSP: discardEmulationPreventionBytes$1(data),\n              trackId: trackId\n            };\n\n            if (matchingSample) {\n              seiNal.pts = matchingSample.pts;\n              seiNal.dts = matchingSample.dts;\n              lastMatchedSample = matchingSample;\n            } else if (lastMatchedSample) {\n              // If a matching sample cannot be found, use the last\n              // sample's values as they should be as close as possible\n              seiNal.pts = lastMatchedSample.pts;\n              seiNal.dts = lastMatchedSample.dts;\n            } else {\n              // eslint-disable-next-line no-console\n              console.log(\"We've encountered a nal unit without data. See mux.js#233.\");\n              break;\n            }\n\n            result.push(seiNal);\n            break;\n        }\n      }\n\n      return result;\n    };\n    /**\n      * Parses sample information out of Track Run Boxes and calculates\n      * the absolute presentation and decode timestamps of each sample.\n      *\n      * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n      * @param {Number} baseMediaDecodeTime - base media decode time from tfdt\n          @see ISO-BMFF-12/2015, Section 8.8.12\n      * @param {Object} tfhd - The parsed Track Fragment Header\n      *   @see inspect.parseTfhd\n      * @return {Object[]} the parsed samples\n      *\n      * @see ISO-BMFF-12/2015, Section 8.8.8\n     **/\n\n\n    var parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {\n      var currentDts = baseMediaDecodeTime;\n      var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n      var defaultSampleSize = tfhd.defaultSampleSize || 0;\n      var trackId = tfhd.trackId;\n      var allSamples = [];\n      truns.forEach(function (trun) {\n        // Note: We currently do not parse the sample table as well\n        // as the trun. It's possible some sources will require this.\n        // moov > trak > mdia > minf > stbl\n        var trackRun = parseTrun(trun);\n        var samples = trackRun.samples;\n        samples.forEach(function (sample) {\n          if (sample.duration === undefined) {\n            sample.duration = defaultSampleDuration;\n          }\n\n          if (sample.size === undefined) {\n            sample.size = defaultSampleSize;\n          }\n\n          sample.trackId = trackId;\n          sample.dts = currentDts;\n\n          if (sample.compositionTimeOffset === undefined) {\n            sample.compositionTimeOffset = 0;\n          }\n\n          sample.pts = currentDts + sample.compositionTimeOffset;\n          currentDts += sample.duration;\n        });\n        allSamples = allSamples.concat(samples);\n      });\n      return allSamples;\n    };\n    /**\n      * Parses out caption nals from an FMP4 segment's video tracks.\n      *\n      * @param {Uint8Array} segment - The bytes of a single segment\n      * @param {Number} videoTrackId - The trackId of a video track in the segment\n      * @return {Object.<Number, Object[]>} A mapping of video trackId to\n      *   a list of seiNals found in that track\n     **/\n\n\n    var parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {\n      // To get the samples\n      var trafs = findBox_1(segment, ['moof', 'traf']); // To get SEI NAL units\n\n      var mdats = findBox_1(segment, ['mdat']);\n      var captionNals = {};\n      var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n      mdats.forEach(function (mdat, index) {\n        var matchingTraf = trafs[index];\n        mdatTrafPairs.push({\n          mdat: mdat,\n          traf: matchingTraf\n        });\n      });\n      mdatTrafPairs.forEach(function (pair) {\n        var mdat = pair.mdat;\n        var traf = pair.traf;\n        var tfhd = findBox_1(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n        var headerInfo = parseTfhd(tfhd[0]);\n        var trackId = headerInfo.trackId;\n        var tfdt = findBox_1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n        var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n        var truns = findBox_1(traf, ['trun']);\n        var samples;\n        var seiNals; // Only parse video data for the chosen video track\n\n        if (videoTrackId === trackId && truns.length > 0) {\n          samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n          seiNals = findSeiNals(mdat, samples, trackId);\n\n          if (!captionNals[trackId]) {\n            captionNals[trackId] = [];\n          }\n\n          captionNals[trackId] = captionNals[trackId].concat(seiNals);\n        }\n      });\n      return captionNals;\n    };\n    /**\n      * Parses out inband captions from an MP4 container and returns\n      * caption objects that can be used by WebVTT and the TextTrack API.\n      * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n      * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n      * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n      *\n      * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n      * @param {Number} trackId - The id of the video track to parse\n      * @param {Number} timescale - The timescale for the video track from the init segment\n      *\n      * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n      * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n      * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n      * @return {String} parsedCaptions[].text - The visible content of the caption\n     **/\n\n\n    var parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {\n      var seiNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n      if (trackId === null) {\n        return null;\n      }\n\n      seiNals = parseCaptionNals(segment, trackId);\n      return {\n        seiNals: seiNals[trackId],\n        timescale: timescale\n      };\n    };\n    /**\n      * Converts SEI NALUs into captions that can be used by video.js\n     **/\n\n\n    var CaptionParser = function CaptionParser() {\n      var isInitialized = false;\n      var captionStream; // Stores segments seen before trackId and timescale are set\n\n      var segmentCache; // Stores video track ID of the track being parsed\n\n      var trackId; // Stores the timescale of the track being parsed\n\n      var timescale; // Stores captions parsed so far\n\n      var parsedCaptions; // Stores whether we are receiving partial data or not\n\n      var parsingPartial;\n      /**\n        * A method to indicate whether a CaptionParser has been initalized\n        * @returns {Boolean}\n       **/\n\n      this.isInitialized = function () {\n        return isInitialized;\n      };\n      /**\n        * Initializes the underlying CaptionStream, SEI NAL parsing\n        * and management, and caption collection\n       **/\n\n\n      this.init = function (options) {\n        captionStream = new CaptionStream$1();\n        isInitialized = true;\n        parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n        captionStream.on('data', function (event) {\n          // Convert to seconds in the source's timescale\n          event.startTime = event.startPts / timescale;\n          event.endTime = event.endPts / timescale;\n          parsedCaptions.captions.push(event);\n          parsedCaptions.captionStreams[event.stream] = true;\n        });\n      };\n      /**\n        * Determines if a new video track will be selected\n        * or if the timescale changed\n        * @return {Boolean}\n       **/\n\n\n      this.isNewInit = function (videoTrackIds, timescales) {\n        if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n          return false;\n        }\n\n        return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n      };\n      /**\n        * Parses out SEI captions and interacts with underlying\n        * CaptionStream to return dispatched captions\n        *\n        * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n        * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n        * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n        * @see parseEmbeddedCaptions\n        * @see m2ts/caption-stream.js\n       **/\n\n\n      this.parse = function (segment, videoTrackIds, timescales) {\n        var parsedData;\n\n        if (!this.isInitialized()) {\n          return null; // This is not likely to be a video segment\n        } else if (!videoTrackIds || !timescales) {\n          return null;\n        } else if (this.isNewInit(videoTrackIds, timescales)) {\n          // Use the first video track only as there is no\n          // mechanism to switch to other video tracks\n          trackId = videoTrackIds[0];\n          timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n          // data until we have one.\n          // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n        } else if (trackId === null || !timescale) {\n          segmentCache.push(segment);\n          return null;\n        } // Now that a timescale and trackId is set, parse cached segments\n\n\n        while (segmentCache.length > 0) {\n          var cachedSegment = segmentCache.shift();\n          this.parse(cachedSegment, videoTrackIds, timescales);\n        }\n\n        parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n        if (parsedData === null || !parsedData.seiNals) {\n          return null;\n        }\n\n        this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n        this.flushStream();\n        return parsedCaptions;\n      };\n      /**\n        * Pushes SEI NALUs onto CaptionStream\n        * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n        * Assumes that `parseCaptionNals` has been called first\n        * @see m2ts/caption-stream.js\n        **/\n\n\n      this.pushNals = function (nals) {\n        if (!this.isInitialized() || !nals || nals.length === 0) {\n          return null;\n        }\n\n        nals.forEach(function (nal) {\n          captionStream.push(nal);\n        });\n      };\n      /**\n        * Flushes underlying CaptionStream to dispatch processed, displayable captions\n        * @see m2ts/caption-stream.js\n       **/\n\n\n      this.flushStream = function () {\n        if (!this.isInitialized()) {\n          return null;\n        }\n\n        if (!parsingPartial) {\n          captionStream.flush();\n        } else {\n          captionStream.partialFlush();\n        }\n      };\n      /**\n        * Reset caption buckets for new data\n       **/\n\n\n      this.clearParsedCaptions = function () {\n        parsedCaptions.captions = [];\n        parsedCaptions.captionStreams = {};\n      };\n      /**\n        * Resets underlying CaptionStream\n        * @see m2ts/caption-stream.js\n       **/\n\n\n      this.resetCaptionStream = function () {\n        if (!this.isInitialized()) {\n          return null;\n        }\n\n        captionStream.reset();\n      };\n      /**\n        * Convenience method to clear all captions flushed from the\n        * CaptionStream and still being parsed\n        * @see m2ts/caption-stream.js\n       **/\n\n\n      this.clearAllCaptions = function () {\n        this.clearParsedCaptions();\n        this.resetCaptionStream();\n      };\n      /**\n        * Reset caption parser\n       **/\n\n\n      this.reset = function () {\n        segmentCache = [];\n        trackId = null;\n        timescale = null;\n\n        if (!parsedCaptions) {\n          parsedCaptions = {\n            captions: [],\n            // CC1, CC2, CC3, CC4\n            captionStreams: {}\n          };\n        } else {\n          this.clearParsedCaptions();\n        }\n\n        this.resetCaptionStream();\n      };\n\n      this.reset();\n    };\n\n    var captionParser = CaptionParser;\n    /* global self */\n\n    var typeFromStreamString = function typeFromStreamString(streamString) {\n      if (streamString === 'AudioSegmentStream') {\n        return 'audio';\n      }\n\n      return streamString === 'VideoSegmentStream' ? 'video' : '';\n    };\n    /**\n     * Re-emits transmuxer events by converting them into messages to the\n     * world outside the worker.\n     *\n     * @param {Object} transmuxer the transmuxer to wire events on\n     * @private\n     */\n\n\n    var wireFullTransmuxerEvents = function wireFullTransmuxerEvents(self, transmuxer) {\n      transmuxer.on('data', function (segment) {\n        // transfer ownership of the underlying ArrayBuffer\n        // instead of doing a copy to save memory\n        // ArrayBuffers are transferable but generic TypedArrays are not\n        // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n        var initArray = segment.initSegment;\n        segment.initSegment = {\n          data: initArray.buffer,\n          byteOffset: initArray.byteOffset,\n          byteLength: initArray.byteLength\n        };\n        var typedArray = segment.data;\n        segment.data = typedArray.buffer;\n        self.postMessage({\n          action: 'data',\n          segment: segment,\n          byteOffset: typedArray.byteOffset,\n          byteLength: typedArray.byteLength\n        }, [segment.data]);\n      });\n      transmuxer.on('done', function (data) {\n        self.postMessage({\n          action: 'done'\n        });\n      });\n      transmuxer.on('gopInfo', function (gopInfo) {\n        self.postMessage({\n          action: 'gopInfo',\n          gopInfo: gopInfo\n        });\n      });\n      transmuxer.on('videoSegmentTimingInfo', function (timingInfo) {\n        var videoSegmentTimingInfo = {\n          start: {\n            decode: clock_4(timingInfo.start.dts),\n            presentation: clock_4(timingInfo.start.pts)\n          },\n          end: {\n            decode: clock_4(timingInfo.end.dts),\n            presentation: clock_4(timingInfo.end.pts)\n          },\n          baseMediaDecodeTime: clock_4(timingInfo.baseMediaDecodeTime)\n        };\n\n        if (timingInfo.prependedContentDuration) {\n          videoSegmentTimingInfo.prependedContentDuration = clock_4(timingInfo.prependedContentDuration);\n        }\n\n        self.postMessage({\n          action: 'videoSegmentTimingInfo',\n          videoSegmentTimingInfo: videoSegmentTimingInfo\n        });\n      });\n      transmuxer.on('id3Frame', function (id3Frame) {\n        self.postMessage({\n          action: 'id3Frame',\n          id3Frame: id3Frame\n        });\n      });\n      transmuxer.on('caption', function (caption) {\n        self.postMessage({\n          action: 'caption',\n          caption: caption\n        });\n      });\n      transmuxer.on('trackinfo', function (trackInfo) {\n        self.postMessage({\n          action: 'trackinfo',\n          trackInfo: trackInfo\n        });\n      });\n      transmuxer.on('audioTimingInfo', function (audioTimingInfo) {\n        // convert to video TS since we prioritize video time over audio\n        self.postMessage({\n          action: 'audioTimingInfo',\n          audioTimingInfo: {\n            start: clock_4(audioTimingInfo.start),\n            end: clock_4(audioTimingInfo.end)\n          }\n        });\n      });\n      transmuxer.on('videoTimingInfo', function (videoTimingInfo) {\n        self.postMessage({\n          action: 'videoTimingInfo',\n          videoTimingInfo: {\n            start: clock_4(videoTimingInfo.start),\n            end: clock_4(videoTimingInfo.end)\n          }\n        });\n      });\n    };\n\n    var wirePartialTransmuxerEvents = function wirePartialTransmuxerEvents(self, transmuxer) {\n      transmuxer.on('data', function (event) {\n        // transfer ownership of the underlying ArrayBuffer\n        // instead of doing a copy to save memory\n        // ArrayBuffers are transferable but generic TypedArrays are not\n        // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n        var initSegment = {\n          data: event.data.track.initSegment.buffer,\n          byteOffset: event.data.track.initSegment.byteOffset,\n          byteLength: event.data.track.initSegment.byteLength\n        };\n        var boxes = {\n          data: event.data.boxes.buffer,\n          byteOffset: event.data.boxes.byteOffset,\n          byteLength: event.data.boxes.byteLength\n        };\n        var segment = {\n          boxes: boxes,\n          initSegment: initSegment,\n          type: event.type,\n          sequence: event.data.sequence\n        };\n\n        if (typeof event.data.videoFrameDts !== 'undefined') {\n          segment.videoFrameDtsTime = clock_4(event.data.videoFrameDts);\n        }\n\n        if (typeof event.data.videoFramePts !== 'undefined') {\n          segment.videoFramePtsTime = clock_4(event.data.videoFramePts);\n        }\n\n        self.postMessage({\n          action: 'data',\n          segment: segment\n        }, [segment.boxes.data, segment.initSegment.data]);\n      });\n      transmuxer.on('id3Frame', function (id3Frame) {\n        self.postMessage({\n          action: 'id3Frame',\n          id3Frame: id3Frame\n        });\n      });\n      transmuxer.on('caption', function (caption) {\n        self.postMessage({\n          action: 'caption',\n          caption: caption\n        });\n      });\n      transmuxer.on('done', function (data) {\n        self.postMessage({\n          action: 'done',\n          type: typeFromStreamString(data)\n        });\n      });\n      transmuxer.on('partialdone', function (data) {\n        self.postMessage({\n          action: 'partialdone',\n          type: typeFromStreamString(data)\n        });\n      });\n      transmuxer.on('endedsegment', function (data) {\n        self.postMessage({\n          action: 'endedSegment',\n          type: typeFromStreamString(data)\n        });\n      });\n      transmuxer.on('trackinfo', function (trackInfo) {\n        self.postMessage({\n          action: 'trackinfo',\n          trackInfo: trackInfo\n        });\n      });\n      transmuxer.on('audioTimingInfo', function (audioTimingInfo) {\n        // This can happen if flush is called when no\n        // audio has been processed. This should be an\n        // unusual case, but if it does occur should not\n        // result in valid data being returned\n        if (audioTimingInfo.start === null) {\n          self.postMessage({\n            action: 'audioTimingInfo',\n            audioTimingInfo: audioTimingInfo\n          });\n          return;\n        } // convert to video TS since we prioritize video time over audio\n\n\n        var timingInfoInSeconds = {\n          start: clock_4(audioTimingInfo.start)\n        };\n\n        if (audioTimingInfo.end) {\n          timingInfoInSeconds.end = clock_4(audioTimingInfo.end);\n        }\n\n        self.postMessage({\n          action: 'audioTimingInfo',\n          audioTimingInfo: timingInfoInSeconds\n        });\n      });\n      transmuxer.on('videoTimingInfo', function (videoTimingInfo) {\n        var timingInfoInSeconds = {\n          start: clock_4(videoTimingInfo.start)\n        };\n\n        if (videoTimingInfo.end) {\n          timingInfoInSeconds.end = clock_4(videoTimingInfo.end);\n        }\n\n        self.postMessage({\n          action: 'videoTimingInfo',\n          videoTimingInfo: timingInfoInSeconds\n        });\n      });\n    };\n    /**\n     * All incoming messages route through this hash. If no function exists\n     * to handle an incoming message, then we ignore the message.\n     *\n     * @class MessageHandlers\n     * @param {Object} options the options to initialize with\n     */\n\n\n    var MessageHandlers = /*#__PURE__*/function () {\n      function MessageHandlers(self, options) {\n        this.options = options || {};\n        this.self = self;\n        this.init();\n      }\n      /**\n       * initialize our web worker and wire all the events.\n       */\n\n\n      var _proto = MessageHandlers.prototype;\n\n      _proto.init = function init() {\n        if (this.transmuxer) {\n          this.transmuxer.dispose();\n        }\n\n        this.transmuxer = this.options.handlePartialData ? new transmuxer$1(this.options) : new transmuxer_1(this.options);\n\n        if (this.options.handlePartialData) {\n          wirePartialTransmuxerEvents(this.self, this.transmuxer);\n        } else {\n          wireFullTransmuxerEvents(this.self, this.transmuxer);\n        }\n      };\n\n      _proto.pushMp4Captions = function pushMp4Captions(data) {\n        if (!this.captionParser) {\n          this.captionParser = new captionParser();\n          this.captionParser.init();\n        }\n\n        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n        var parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);\n        this.self.postMessage({\n          action: 'mp4Captions',\n          captions: parsed && parsed.captions || [],\n          data: segment.buffer\n        }, [segment.buffer]);\n      };\n\n      _proto.clearAllMp4Captions = function clearAllMp4Captions() {\n        if (this.captionParser) {\n          this.captionParser.clearAllCaptions();\n        }\n      };\n\n      _proto.clearParsedMp4Captions = function clearParsedMp4Captions() {\n        if (this.captionParser) {\n          this.captionParser.clearParsedCaptions();\n        }\n      }\n      /**\n       * Adds data (a ts segment) to the start of the transmuxer pipeline for\n       * processing.\n       *\n       * @param {ArrayBuffer} data data to push into the muxer\n       */\n      ;\n\n      _proto.push = function push(data) {\n        // Cast array buffer to correct type for transmuxer\n        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n        this.transmuxer.push(segment);\n      }\n      /**\n       * Recreate the transmuxer so that the next segment added via `push`\n       * start with a fresh transmuxer.\n       */\n      ;\n\n      _proto.reset = function reset() {\n        this.transmuxer.reset();\n      }\n      /**\n       * Set the value that will be used as the `baseMediaDecodeTime` time for the\n       * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\n       * set relative to the first based on the PTS values.\n       *\n       * @param {Object} data used to set the timestamp offset in the muxer\n       */\n      ;\n\n      _proto.setTimestampOffset = function setTimestampOffset(data) {\n        var timestampOffset = data.timestampOffset || 0;\n        this.transmuxer.setBaseMediaDecodeTime(Math.round(clock_2(timestampOffset)));\n      };\n\n      _proto.setAudioAppendStart = function setAudioAppendStart(data) {\n        this.transmuxer.setAudioAppendStart(Math.ceil(clock_2(data.appendStart)));\n      };\n\n      _proto.setRemux = function setRemux(data) {\n        this.transmuxer.setRemux(data.remux);\n      }\n      /**\n       * Forces the pipeline to finish processing the last segment and emit it's\n       * results.\n       *\n       * @param {Object} data event data, not really used\n       */\n      ;\n\n      _proto.flush = function flush(data) {\n        this.transmuxer.flush(); // transmuxed done action is fired after both audio/video pipelines are flushed\n\n        self.postMessage({\n          action: 'done',\n          type: 'transmuxed'\n        });\n      };\n\n      _proto.partialFlush = function partialFlush(data) {\n        this.transmuxer.partialFlush(); // transmuxed partialdone action is fired after both audio/video pipelines are flushed\n\n        self.postMessage({\n          action: 'partialdone',\n          type: 'transmuxed'\n        });\n      };\n\n      _proto.endTimeline = function endTimeline() {\n        this.transmuxer.endTimeline(); // transmuxed endedtimeline action is fired after both audio/video pipelines end their\n        // timelines\n\n        self.postMessage({\n          action: 'endedtimeline',\n          type: 'transmuxed'\n        });\n      };\n\n      _proto.alignGopsWith = function alignGopsWith(data) {\n        this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\n      };\n\n      return MessageHandlers;\n    }();\n    /**\n     * Our web worker interface so that things can talk to mux.js\n     * that will be running in a web worker. the scope is passed to this by\n     * webworkify.\n     *\n     * @param {Object} self the scope for the web worker\n     */\n\n\n    var TransmuxerWorker = function TransmuxerWorker(self) {\n      self.onmessage = function (event) {\n        if (event.data.action === 'init' && event.data.options) {\n          this.messageHandlers = new MessageHandlers(self, event.data.options);\n          return;\n        }\n\n        if (!this.messageHandlers) {\n          this.messageHandlers = new MessageHandlers(self);\n        }\n\n        if (event.data && event.data.action && event.data.action !== 'init') {\n          if (this.messageHandlers[event.data.action]) {\n            this.messageHandlers[event.data.action](event.data);\n          }\n        }\n      };\n    };\n\n    var transmuxerWorker = new TransmuxerWorker(self);\n    return transmuxerWorker;\n  }();\n});\n/**\n * @file - codecs.js - Handles tasks regarding codec strings such as translating them to\n * codec strings, or translating codec strings into objects that can be examined.\n */\n\n/**\n * Returns a set of codec strings parsed from the playlist or the default\n * codec strings if no codecs were specified in the playlist\n *\n * @param {Playlist} media the current media playlist\n * @return {Object} an object with the video and audio codecs\n */\n\nvar getCodecs = function getCodecs(media) {\n  // if the codecs were explicitly specified, use them instead of the\n  // defaults\n  var mediaAttributes = media.attributes || {};\n\n  if (mediaAttributes.CODECS) {\n    return parseCodecs(mediaAttributes.CODECS);\n  }\n};\n\nvar isMaat = function isMaat(master, media) {\n  var mediaAttributes = media.attributes || {};\n  return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n};\n\nvar isMuxed = function isMuxed(master, media) {\n  if (!isMaat(master, media)) {\n    return true;\n  }\n\n  var mediaAttributes = media.attributes || {};\n  var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n\n  for (var groupId in audioGroup) {\n    // If an audio group has a URI (the case for HLS, as HLS will use external playlists),\n    // or there are listed playlists (the case for DASH, as the manifest will have already\n    // provided all of the details necessary to generate the audio playlist, as opposed to\n    // HLS' externally requested playlists), then the content is demuxed.\n    if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Calculates the codec strings for a working configuration of\n * SourceBuffers to play variant streams in a master playlist. If\n * there is no possible working configuration, an empty object will be\n * returned.\n *\n * @param master {Object} the m3u8 object for the master playlist\n * @param media {Object} the m3u8 object for the variant playlist\n * @return {Object} the codec strings.\n *\n * @private\n */\n\n\nvar codecsForPlaylist = function codecsForPlaylist(master, media) {\n  var mediaAttributes = media.attributes || {};\n  var codecInfo = getCodecs(media) || {}; // HLS with multiple-audio tracks must always get an audio codec.\n  // Put another way, there is no way to have a video-only multiple-audio HLS!\n\n  if (isMaat(master, media) && !codecInfo.audio) {\n    if (!isMuxed(master, media)) {\n      // It is possible for codecs to be specified on the audio media group playlist but\n      // not on the rendition playlist. This is mostly the case for DASH, where audio and\n      // video are always separate (and separately specified).\n      var defaultCodecs = codecsFromDefault(master, mediaAttributes.AUDIO);\n\n      if (defaultCodecs) {\n        codecInfo.audio = defaultCodecs.audio;\n      }\n    }\n  }\n\n  var codecs = {};\n\n  if (codecInfo.video) {\n    codecs.video = translateLegacyCodec(\"\" + codecInfo.video.type + codecInfo.video.details);\n  }\n\n  if (codecInfo.audio) {\n    codecs.audio = translateLegacyCodec(\"\" + codecInfo.audio.type + codecInfo.audio.details);\n  }\n\n  return codecs;\n};\n\nvar logger = function logger(source) {\n  if (videojs$1.log.debug) {\n    return videojs$1.log.debug.bind(videojs$1, 'VHS:', source + \" >\");\n  }\n\n  return function () {};\n};\n\nvar logFn = logger('PlaylistSelector');\n\nvar representationToString = function representationToString(representation) {\n  if (!representation || !representation.playlist) {\n    return;\n  }\n\n  var playlist = representation.playlist;\n  return JSON.stringify({\n    id: playlist.id,\n    bandwidth: representation.bandwidth,\n    width: representation.width,\n    height: representation.height,\n    codecs: playlist.attributes && playlist.attributes.CODECS || ''\n  });\n}; // Utilities\n\n/**\n * Returns the CSS value for the specified property on an element\n * using `getComputedStyle`. Firefox has a long-standing issue where\n * getComputedStyle() may return null when running in an iframe with\n * `display: none`.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n * @param {HTMLElement} el the htmlelement to work on\n * @param {string} the proprety to get the style for\n */\n\n\nvar safeGetComputedStyle = function safeGetComputedStyle(el, property) {\n  if (!el) {\n    return '';\n  }\n\n  var result = window$1.getComputedStyle(el);\n\n  if (!result) {\n    return '';\n  }\n\n  return result[property];\n};\n/**\n * Resuable stable sort function\n *\n * @param {Playlists} array\n * @param {Function} sortFn Different comparators\n * @function stableSort\n */\n\n\nvar stableSort = function stableSort(array, sortFn) {\n  var newArray = array.slice();\n  array.sort(function (left, right) {\n    var cmp = sortFn(left, right);\n\n    if (cmp === 0) {\n      return newArray.indexOf(left) - newArray.indexOf(right);\n    }\n\n    return cmp;\n  });\n};\n/**\n * A comparator function to sort two playlist object by bandwidth.\n *\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {number} Greater than zero if the bandwidth attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the bandwidth of right is greater than left and\n * exactly zero if the two are equal.\n */\n\n\nvar comparePlaylistBandwidth = function comparePlaylistBandwidth(left, right) {\n  var leftBandwidth;\n  var rightBandwidth;\n\n  if (left.attributes.BANDWIDTH) {\n    leftBandwidth = left.attributes.BANDWIDTH;\n  }\n\n  leftBandwidth = leftBandwidth || window$1.Number.MAX_VALUE;\n\n  if (right.attributes.BANDWIDTH) {\n    rightBandwidth = right.attributes.BANDWIDTH;\n  }\n\n  rightBandwidth = rightBandwidth || window$1.Number.MAX_VALUE;\n  return leftBandwidth - rightBandwidth;\n};\n/**\n * A comparator function to sort two playlist object by resolution (width).\n *\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {number} Greater than zero if the resolution.width attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the resolution.width of right is greater than left and\n * exactly zero if the two are equal.\n */\n\n\nvar comparePlaylistResolution = function comparePlaylistResolution(left, right) {\n  var leftWidth;\n  var rightWidth;\n\n  if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n    leftWidth = left.attributes.RESOLUTION.width;\n  }\n\n  leftWidth = leftWidth || window$1.Number.MAX_VALUE;\n\n  if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n    rightWidth = right.attributes.RESOLUTION.width;\n  }\n\n  rightWidth = rightWidth || window$1.Number.MAX_VALUE; // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n  // have the same media dimensions/ resolution\n\n  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n  }\n\n  return leftWidth - rightWidth;\n};\n/**\n * Chooses the appropriate media playlist based on bandwidth and player size\n *\n * @param {Object} master\n *        Object representation of the master manifest\n * @param {number} playerBandwidth\n *        Current calculated bandwidth of the player\n * @param {number} playerWidth\n *        Current width of the player element (should account for the device pixel ratio)\n * @param {number} playerHeight\n *        Current height of the player element (should account for the device pixel ratio)\n * @param {boolean} limitRenditionByPlayerDimensions\n *        True if the player width and height should be used during the selection, false otherwise\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\n\n\nvar simpleSelector = function simpleSelector(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions) {\n  var options = {\n    bandwidth: playerBandwidth,\n    width: playerWidth,\n    height: playerHeight,\n    limitRenditionByPlayerDimensions: limitRenditionByPlayerDimensions\n  }; // convert the playlists to an intermediary representation to make comparisons easier\n\n  var sortedPlaylistReps = master.playlists.map(function (playlist) {\n    var bandwidth;\n    var width = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n    var height = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n    bandwidth = playlist.attributes.BANDWIDTH;\n    bandwidth = bandwidth || window$1.Number.MAX_VALUE;\n    return {\n      bandwidth: bandwidth,\n      width: width,\n      height: height,\n      playlist: playlist\n    };\n  });\n  stableSort(sortedPlaylistReps, function (left, right) {\n    return left.bandwidth - right.bandwidth;\n  }); // filter out any playlists that have been excluded due to\n  // incompatible configurations\n\n  sortedPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return !Playlist.isIncompatible(rep.playlist);\n  }); // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n\n  var enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return Playlist.isEnabled(rep.playlist);\n  });\n\n  if (!enabledPlaylistReps.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n      return !Playlist.isDisabled(rep.playlist);\n    });\n  } // filter out any variant that has greater effective bitrate\n  // than the current estimated bandwidth\n\n\n  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function (rep) {\n    return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;\n  });\n  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1]; // get all of the renditions with the same (highest) bandwidth\n  // and then taking the very first element\n\n  var bandwidthBestRep = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0]; // if we're not going to limit renditions by player size, make an early decision.\n\n  if (limitRenditionByPlayerDimensions === false) {\n    var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n\n    if (_chosenRep && _chosenRep.playlist) {\n      var type = 'sortedPlaylistReps';\n\n      if (bandwidthBestRep) {\n        type = 'bandwidthBestRep';\n      }\n\n      if (enabledPlaylistReps[0]) {\n        type = 'enabledPlaylistReps';\n      }\n\n      logFn(\"choosing \" + representationToString(_chosenRep) + \" using \" + type + \" with options\", options);\n      return _chosenRep.playlist;\n    }\n\n    logFn('could not choose a playlist with options', options);\n    return null;\n  } // filter out playlists without resolution information\n\n\n  var haveResolution = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.width && rep.height;\n  }); // sort variants by resolution\n\n  stableSort(haveResolution, function (left, right) {\n    return left.width - right.width;\n  }); // if we have the exact resolution as the player use it\n\n  var resolutionBestRepList = haveResolution.filter(function (rep) {\n    return rep.width === playerWidth && rep.height === playerHeight;\n  });\n  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1]; // ensure that we pick the highest bandwidth variant that have exact resolution\n\n  var resolutionBestRep = resolutionBestRepList.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n  var resolutionPlusOneList;\n  var resolutionPlusOneSmallest;\n  var resolutionPlusOneRep; // find the smallest variant that is larger than the player\n  // if there is no match of exact resolution\n\n  if (!resolutionBestRep) {\n    resolutionPlusOneList = haveResolution.filter(function (rep) {\n      return rep.width > playerWidth || rep.height > playerHeight;\n    }); // find all the variants have the same smallest resolution\n\n    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function (rep) {\n      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;\n    }); // ensure that we also pick the highest bandwidth variant that\n    // is just-larger-than the video player\n\n    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function (rep) {\n      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n    })[0];\n  } // fallback chain of variants\n\n\n  var chosenRep = resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n\n  if (chosenRep && chosenRep.playlist) {\n    var _type = 'sortedPlaylistReps';\n\n    if (resolutionPlusOneRep) {\n      _type = 'resolutionPlusOneRep';\n    } else if (resolutionBestRep) {\n      _type = 'resolutionBestRep';\n    } else if (bandwidthBestRep) {\n      _type = 'bandwidthBestRep';\n    } else if (enabledPlaylistReps[0]) {\n      _type = 'enabledPlaylistReps';\n    }\n\n    logFn(\"choosing \" + representationToString(chosenRep) + \" using \" + _type + \" with options\", options);\n    return chosenRep.playlist;\n  }\n\n  logFn('could not choose a playlist with options', options);\n  return null;\n}; // Playlist Selectors\n\n/**\n * Chooses the appropriate media playlist based on the most recent\n * bandwidth estimate and the player size.\n *\n * Expects to be called within the context of an instance of VhsHandler\n *\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\n\n\nvar lastBandwidthSelector = function lastBandwidthSelector() {\n  var pixelRatio = this.useDevicePixelRatio ? window$1.devicePixelRatio || 1 : 1;\n  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions);\n};\n/**\n * Chooses the appropriate media playlist based on the potential to rebuffer\n *\n * @param {Object} settings\n *        Object of information required to use this selector\n * @param {Object} settings.master\n *        Object representation of the master manifest\n * @param {number} settings.currentTime\n *        The current time of the player\n * @param {number} settings.bandwidth\n *        Current measured bandwidth\n * @param {number} settings.duration\n *        Duration of the media\n * @param {number} settings.segmentDuration\n *        Segment duration to be used in round trip time calculations\n * @param {number} settings.timeUntilRebuffer\n *        Time left in seconds until the player has to rebuffer\n * @param {number} settings.currentTimeline\n *        The current timeline segments are being loaded from\n * @param {SyncController} settings.syncController\n *        SyncController for determining if we have a sync point for a given playlist\n * @return {Object|null}\n *         {Object} return.playlist\n *         The highest bandwidth playlist with the least amount of rebuffering\n *         {Number} return.rebufferingImpact\n *         The amount of time in seconds switching to this playlist will rebuffer. A\n *         negative value means that switching will cause zero rebuffering.\n */\n\n\nvar minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector(settings) {\n  var master = settings.master,\n      currentTime = settings.currentTime,\n      bandwidth = settings.bandwidth,\n      duration = settings.duration,\n      segmentDuration = settings.segmentDuration,\n      timeUntilRebuffer = settings.timeUntilRebuffer,\n      currentTimeline = settings.currentTimeline,\n      syncController = settings.syncController; // filter out any playlists that have been excluded due to\n  // incompatible configurations\n\n  var compatiblePlaylists = master.playlists.filter(function (playlist) {\n    return !Playlist.isIncompatible(playlist);\n  }); // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n\n  var enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);\n\n  if (!enabledPlaylists.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylists = compatiblePlaylists.filter(function (playlist) {\n      return !Playlist.isDisabled(playlist);\n    });\n  }\n\n  var bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, 'BANDWIDTH'));\n  var rebufferingEstimates = bandwidthPlaylists.map(function (playlist) {\n    var syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime); // If there is no sync point for this playlist, switching to it will require a\n    // sync request first. This will double the request time\n\n    var numRequests = syncPoint ? 1 : 2;\n    var requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n    return {\n      playlist: playlist,\n      rebufferingImpact: rebufferingImpact\n    };\n  });\n  var noRebufferingPlaylists = rebufferingEstimates.filter(function (estimate) {\n    return estimate.rebufferingImpact <= 0;\n  }); // Sort by bandwidth DESC\n\n  stableSort(noRebufferingPlaylists, function (a, b) {\n    return comparePlaylistBandwidth(b.playlist, a.playlist);\n  });\n\n  if (noRebufferingPlaylists.length) {\n    return noRebufferingPlaylists[0];\n  }\n\n  stableSort(rebufferingEstimates, function (a, b) {\n    return a.rebufferingImpact - b.rebufferingImpact;\n  });\n  return rebufferingEstimates[0] || null;\n};\n/**\n * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n * one with video.  If no renditions with video exist, return the lowest audio rendition.\n *\n * Expects to be called within the context of an instance of VhsHandler\n *\n * @return {Object|null}\n *         {Object} return.playlist\n *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n *         exists pick the lowest audio rendition.\n */\n\n\nvar lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector() {\n  var _this = this; // filter out any playlists that have been excluded due to\n  // incompatible configurations or playback errors\n\n\n  var playlists = this.playlists.master.playlists.filter(Playlist.isEnabled); // Sort ascending by bitrate\n\n  stableSort(playlists, function (a, b) {\n    return comparePlaylistBandwidth(a, b);\n  }); // Parse and assume that playlists with no video codec have no video\n  // (this is not necessarily true, although it is generally true).\n  //\n  // If an entire manifest has no valid videos everything will get filtered\n  // out.\n\n  var playlistsWithVideo = playlists.filter(function (playlist) {\n    return !!codecsForPlaylist(_this.playlists.master, playlist).video;\n  });\n  return playlistsWithVideo[0] || null;\n};\n/**\n * @file text-tracks.js\n */\n\n/**\n * Create captions text tracks on video.js if they do not exist\n *\n * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n * @param {Object} tech the video.js tech\n * @param {Object} captionStream the caption stream to create\n * @private\n */\n\n\nvar createCaptionsTrackIfNotExists = function createCaptionsTrackIfNotExists(inbandTextTracks, tech, captionStream) {\n  if (!inbandTextTracks[captionStream]) {\n    tech.trigger({\n      type: 'usage',\n      name: 'vhs-608'\n    });\n    tech.trigger({\n      type: 'usage',\n      name: 'hls-608'\n    });\n    var track = tech.textTracks().getTrackById(captionStream);\n\n    if (track) {\n      // Resuse an existing track with a CC# id because this was\n      // very likely created by videojs-contrib-hls from information\n      // in the m3u8 for us to use\n      inbandTextTracks[captionStream] = track;\n    } else {\n      // Otherwise, create a track with the default `CC#` label and\n      // without a language\n      inbandTextTracks[captionStream] = tech.addRemoteTextTrack({\n        kind: 'captions',\n        id: captionStream,\n        label: captionStream\n      }, false).track;\n    }\n  }\n};\n/**\n * Add caption text track data to a source handler given an array of captions\n *\n * @param {Object}\n *   @param {Object} inbandTextTracks the inband text tracks\n *   @param {number} timestampOffset the timestamp offset of the source buffer\n *   @param {Array} captionArray an array of caption data\n * @private\n */\n\n\nvar addCaptionData = function addCaptionData(_ref) {\n  var inbandTextTracks = _ref.inbandTextTracks,\n      captionArray = _ref.captionArray,\n      timestampOffset = _ref.timestampOffset;\n\n  if (!captionArray) {\n    return;\n  }\n\n  var Cue = window$1.WebKitDataCue || window$1.VTTCue;\n  captionArray.forEach(function (caption) {\n    var track = caption.stream;\n    inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));\n  });\n};\n/**\n * Define properties on a cue for backwards compatability,\n * but warn the user that the way that they are using it\n * is depricated and will be removed at a later date.\n *\n * @param {Cue} cue the cue to add the properties on\n * @private\n */\n\n\nvar deprecateOldCue = function deprecateOldCue(cue) {\n  Object.defineProperties(cue.frame, {\n    id: {\n      get: function get() {\n        videojs$1.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n        return cue.value.key;\n      }\n    },\n    value: {\n      get: function get() {\n        videojs$1.log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    },\n    privateData: {\n      get: function get() {\n        videojs$1.log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    }\n  });\n};\n/**\n * Add metadata text track data to a source handler given an array of metadata\n *\n * @param {Object}\n *   @param {Object} inbandTextTracks the inband text tracks\n *   @param {Array} metadataArray an array of meta data\n *   @param {number} timestampOffset the timestamp offset of the source buffer\n *   @param {number} videoDuration the duration of the video\n * @private\n */\n\n\nvar addMetadata = function addMetadata(_ref2) {\n  var inbandTextTracks = _ref2.inbandTextTracks,\n      metadataArray = _ref2.metadataArray,\n      timestampOffset = _ref2.timestampOffset,\n      videoDuration = _ref2.videoDuration;\n\n  if (!metadataArray) {\n    return;\n  }\n\n  var Cue = window$1.WebKitDataCue || window$1.VTTCue;\n  var metadataTrack = inbandTextTracks.metadataTrack_;\n\n  if (!metadataTrack) {\n    return;\n  }\n\n  metadataArray.forEach(function (metadata) {\n    var time = metadata.cueTime + timestampOffset; // if time isn't a finite number between 0 and Infinity, like NaN,\n    // ignore this bit of metadata.\n    // This likely occurs when you have an non-timed ID3 tag like TIT2,\n    // which is the \"Title/Songname/Content description\" frame\n\n    if (typeof time !== 'number' || window$1.isNaN(time) || time < 0 || !(time < Infinity)) {\n      return;\n    }\n\n    metadata.frames.forEach(function (frame) {\n      var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\n      cue.frame = frame;\n      cue.value = frame;\n      deprecateOldCue(cue);\n      metadataTrack.addCue(cue);\n    });\n  });\n\n  if (!metadataTrack.cues || !metadataTrack.cues.length) {\n    return;\n  } // Updating the metadeta cues so that\n  // the endTime of each cue is the startTime of the next cue\n  // the endTime of last cue is the duration of the video\n\n\n  var cues = metadataTrack.cues;\n  var cuesArray = []; // Create a copy of the TextTrackCueList...\n  // ...disregarding cues with a falsey value\n\n  for (var i = 0; i < cues.length; i++) {\n    if (cues[i]) {\n      cuesArray.push(cues[i]);\n    }\n  } // Group cues by their startTime value\n\n\n  var cuesGroupedByStartTime = cuesArray.reduce(function (obj, cue) {\n    var timeSlot = obj[cue.startTime] || [];\n    timeSlot.push(cue);\n    obj[cue.startTime] = timeSlot;\n    return obj;\n  }, {}); // Sort startTimes by ascending order\n\n  var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function (a, b) {\n    return Number(a) - Number(b);\n  }); // Map each cue group's endTime to the next group's startTime\n\n  sortedStartTimes.forEach(function (startTime, idx) {\n    var cueGroup = cuesGroupedByStartTime[startTime];\n    var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration; // Map each cue's endTime the next group's startTime\n\n    cueGroup.forEach(function (cue) {\n      cue.endTime = nextTime;\n    });\n  });\n};\n/**\n * Create metadata text track on video.js if it does not exist\n *\n * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n * @param {string} dispatchType the inband metadata track dispatch type\n * @param {Object} tech the video.js tech\n * @private\n */\n\n\nvar createMetadataTrackIfNotExists = function createMetadataTrackIfNotExists(inbandTextTracks, dispatchType, tech) {\n  if (inbandTextTracks.metadataTrack_) {\n    return;\n  }\n\n  inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({\n    kind: 'metadata',\n    label: 'Timed Metadata'\n  }, false).track;\n  inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;\n};\n/**\n * Remove cues from a track on video.js.\n *\n * @param {Double} start start of where we should remove the cue\n * @param {Double} end end of where the we should remove the cue\n * @param {Object} track the text track to remove the cues from\n * @private\n */\n\n\nvar removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {\n  var i;\n  var cue;\n\n  if (!track) {\n    return;\n  }\n\n  if (!track.cues) {\n    return;\n  }\n\n  i = track.cues.length;\n\n  while (i--) {\n    cue = track.cues[i]; // Remove any overlapping cue\n\n    if (cue.startTime >= start && cue.endTime <= end) {\n      track.removeCue(cue);\n    }\n  }\n};\n/**\n * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n * front of current time.\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {number} currentTime\n *        The current time\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n * @return {Array}\n *         List of gops considered safe to append over\n */\n\n\nvar gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, currentTime, mapping) {\n  if (typeof currentTime === 'undefined' || currentTime === null || !buffer.length) {\n    return [];\n  } // pts value for current time + 3 seconds to give a bit more wiggle room\n\n\n  var currentTimePts = Math.ceil((currentTime - mapping + 3) * ONE_SECOND_IN_TS);\n  var i;\n\n  for (i = 0; i < buffer.length; i++) {\n    if (buffer[i].pts > currentTimePts) {\n      break;\n    }\n  }\n\n  return buffer.slice(i);\n};\n/**\n * Appends gop information (timing and byteLength) received by the transmuxer for the\n * gops appended in the last call to appendBuffer\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Array} gops\n *        List of new gop information\n * @param {boolean} replace\n *        If true, replace the buffer with the new gop information. If false, append the\n *        new gop information to the buffer in the right location of time.\n * @return {Array}\n *         Updated list of gop information\n */\n\n\nvar updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {\n  if (!gops.length) {\n    return buffer;\n  }\n\n  if (replace) {\n    // If we are in safe append mode, then completely overwrite the gop buffer\n    // with the most recent appeneded data. This will make sure that when appending\n    // future segments, we only try to align with gops that are both ahead of current\n    // time and in the last segment appended.\n    return gops.slice();\n  }\n\n  var start = gops[0].pts;\n  var i = 0;\n\n  for (i; i < buffer.length; i++) {\n    if (buffer[i].pts >= start) {\n      break;\n    }\n  }\n\n  return buffer.slice(0, i).concat(gops);\n};\n/**\n * Removes gop information in buffer that overlaps with provided start and end\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Double} start\n *        position to start the remove at\n * @param {Double} end\n *        position to end the remove at\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n */\n\n\nvar removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {\n  var startPts = Math.ceil((start - mapping) * ONE_SECOND_IN_TS);\n  var endPts = Math.ceil((end - mapping) * ONE_SECOND_IN_TS);\n  var updatedBuffer = buffer.slice();\n  var i = buffer.length;\n\n  while (i--) {\n    if (buffer[i].pts <= endPts) {\n      break;\n    }\n  }\n\n  if (i === -1) {\n    // no removal because end of remove range is before start of buffer\n    return updatedBuffer;\n  }\n\n  var j = i + 1;\n\n  while (j--) {\n    if (buffer[j].pts <= startPts) {\n      break;\n    }\n  } // clamp remove range start to 0 index\n\n\n  j = Math.max(j, 0);\n  updatedBuffer.splice(j, i - j + 1);\n  return updatedBuffer;\n};\n\nvar shallowEqual = function shallowEqual(a, b) {\n  // if both are undefined\n  // or one or the other is undefined\n  // they are not equal\n  if (!a && !b || !a && b || a && !b) {\n    return false;\n  } // they are the same object and thus, equal\n\n\n  if (a === b) {\n    return true;\n  } // sort keys so we can make sure they have\n  // all the same keys later.\n\n\n  var akeys = Object.keys(a).sort();\n  var bkeys = Object.keys(b).sort(); // different number of keys, not equal\n\n  if (akeys.length !== bkeys.length) {\n    return false;\n  }\n\n  for (var i = 0; i < akeys.length; i++) {\n    var key = akeys[i]; // different sorted keys, not equal\n\n    if (key !== bkeys[i]) {\n      return false;\n    } // different values, not equal\n\n\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar CHECK_BUFFER_DELAY = 500;\n\nvar finite = function finite(num) {\n  return typeof num === 'number' && isFinite(num);\n};\n\nvar illegalMediaSwitch = function illegalMediaSwitch(loaderType, startingMedia, trackInfo) {\n  // Although these checks should most likely cover non 'main' types, for now it narrows\n  // the scope of our checks.\n  if (loaderType !== 'main' || !startingMedia || !trackInfo) {\n    return null;\n  }\n\n  if (!trackInfo.hasAudio && !trackInfo.hasVideo) {\n    return 'Neither audio nor video found in segment.';\n  }\n\n  if (startingMedia.hasVideo && !trackInfo.hasVideo) {\n    return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  if (!startingMedia.hasVideo && trackInfo.hasVideo) {\n    return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  return null;\n};\n/**\n * Calculates a time value that is safe to remove from the back buffer without interrupting\n * playback.\n *\n * @param {TimeRange} seekable\n *        The current seekable range\n * @param {number} currentTime\n *        The current time of the player\n * @param {number} targetDuration\n *        The target duration of the current playlist\n * @return {number}\n *         Time that is safe to remove from the back buffer without interrupting playback\n */\n\n\nvar safeBackBufferTrimTime = function safeBackBufferTrimTime(seekable, currentTime, targetDuration) {\n  // 30 seconds before the playhead provides a safe default for trimming.\n  //\n  // Choosing a reasonable default is particularly important for high bitrate content and\n  // VOD videos/live streams with large windows, as the buffer may end up overfilled and\n  // throw an APPEND_BUFFER_ERR.\n  var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;\n\n  if (seekable.length) {\n    // Some live playlists may have a shorter window of content than the full allowed back\n    // buffer. For these playlists, don't save content that's no longer within the window.\n    trimTime = Math.max(trimTime, seekable.start(0));\n  } // Don't remove within target duration of the current time to avoid the possibility of\n  // removing the GOP currently being played, as removing it can cause playback stalls.\n\n\n  var maxTrimTime = currentTime - targetDuration;\n  return Math.min(maxTrimTime, trimTime);\n};\n\nvar segmentInfoString = function segmentInfoString(segmentInfo) {\n  var _segmentInfo$segment = segmentInfo.segment,\n      start = _segmentInfo$segment.start,\n      end = _segmentInfo$segment.end,\n      _segmentInfo$playlist = segmentInfo.playlist,\n      seq = _segmentInfo$playlist.mediaSequence,\n      id = _segmentInfo$playlist.id,\n      _segmentInfo$playlist2 = _segmentInfo$playlist.segments,\n      segments = _segmentInfo$playlist2 === void 0 ? [] : _segmentInfo$playlist2,\n      index = segmentInfo.mediaIndex,\n      timeline = segmentInfo.timeline;\n  return [\"appending [\" + index + \"] of [\" + seq + \", \" + (seq + segments.length) + \"] from playlist [\" + id + \"]\", \"[\" + start + \" => \" + end + \"] in timeline [\" + timeline + \"]\"].join(' ');\n};\n\nvar timingInfoPropertyForMedia = function timingInfoPropertyForMedia(mediaType) {\n  return mediaType + \"TimingInfo\";\n};\n/**\n * Returns the timestamp offset to use for the segment.\n *\n * @param {number} segmentTimeline\n *        The timeline of the segment\n * @param {number} currentTimeline\n *        The timeline currently being followed by the loader\n * @param {number} startOfSegment\n *        The estimated segment start\n * @param {TimeRange[]} buffered\n *        The loader's buffer\n * @param {boolean} overrideCheck\n *        If true, no checks are made to see if the timestamp offset value should be set,\n *        but sets it directly to a value.\n *\n * @return {number|null}\n *         Either a number representing a new timestamp offset, or null if the segment is\n *         part of the same timeline\n */\n\n\nvar timestampOffsetForSegment = function timestampOffsetForSegment(_ref) {\n  var segmentTimeline = _ref.segmentTimeline,\n      currentTimeline = _ref.currentTimeline,\n      startOfSegment = _ref.startOfSegment,\n      buffered = _ref.buffered,\n      overrideCheck = _ref.overrideCheck; // Check to see if we are crossing a discontinuity to see if we need to set the\n  // timestamp offset on the transmuxer and source buffer.\n  //\n  // Previously, we changed the timestampOffset if the start of this segment was less than\n  // the currently set timestampOffset, but this isn't desirable as it can produce bad\n  // behavior, especially around long running live streams.\n\n  if (!overrideCheck && segmentTimeline === currentTimeline) {\n    return null;\n  } // segmentInfo.startOfSegment used to be used as the timestamp offset, however, that\n  // value uses the end of the last segment if it is available. While this value\n  // should often be correct, it's better to rely on the buffered end, as the new\n  // content post discontinuity should line up with the buffered end as if it were\n  // time 0 for the new content.\n\n\n  return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;\n};\n/**\n * Returns whether or not the loader should wait for a timeline change from the timeline\n * change controller before processing the segment.\n *\n * Primary timing in VHS goes by video. This is different from most media players, as\n * audio is more often used as the primary timing source. For the foreseeable future, VHS\n * will continue to use video as the primary timing source, due to the current logic and\n * expectations built around it.\n\n * Since the timing follows video, in order to maintain sync, the video loader is\n * responsible for setting both audio and video source buffer timestamp offsets.\n *\n * Setting different values for audio and video source buffers could lead to\n * desyncing. The following examples demonstrate some of the situations where this\n * distinction is important. Note that all of these cases involve demuxed content. When\n * content is muxed, the audio and video are packaged together, therefore syncing\n * separate media playlists is not an issue.\n *\n * CASE 1: Audio prepares to load a new timeline before video:\n *\n * Timeline:       0                 1\n * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n * Audio Loader:                     ^\n * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n * Video Loader              ^\n *\n * In the above example, the audio loader is preparing to load the 6th segment, the first\n * after a discontinuity, while the video loader is still loading the 5th segment, before\n * the discontinuity.\n *\n * If the audio loader goes ahead and loads and appends the 6th segment before the video\n * loader crosses the discontinuity, then when appended, the 6th audio segment will use\n * the timestamp offset from timeline 0. This will likely lead to desyncing. In addition,\n * the audio loader must provide the audioAppendStart value to trim the content in the\n * transmuxer, and that value relies on the audio timestamp offset. Since the audio\n * timestamp offset is set by the video (main) loader, the audio loader shouldn't load the\n * segment until that value is provided.\n *\n * CASE 2: Video prepares to load a new timeline before audio:\n *\n * Timeline:       0                 1\n * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n * Audio Loader:             ^\n * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n * Video Loader                      ^\n *\n * In the above example, the video loader is preparing to load the 6th segment, the first\n * after a discontinuity, while the audio loader is still loading the 5th segment, before\n * the discontinuity.\n *\n * If the video loader goes ahead and loads and appends the 6th segment, then once the\n * segment is loaded and processed, both the video and audio timestamp offsets will be\n * set, since video is used as the primary timing source. This is to ensure content lines\n * up appropriately, as any modifications to the video timing are reflected by audio when\n * the video loader sets the audio and video timestamp offsets to the same value. However,\n * setting the timestamp offset for audio before audio has had a chance to change\n * timelines will likely lead to desyncing, as the audio loader will append segment 5 with\n * a timestamp intended to apply to segments from timeline 1 rather than timeline 0.\n *\n * CASE 3: When seeking, audio prepares to load a new timeline before video\n *\n * Timeline:       0                 1\n * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n * Audio Loader:           ^\n * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n * Video Loader            ^\n *\n * In the above example, both audio and video loaders are loading segments from timeline\n * 0, but imagine that the seek originated from timeline 1.\n *\n * When seeking to a new timeline, the timestamp offset will be set based on the expected\n * segment start of the loaded video segment. In order to maintain sync, the audio loader\n * must wait for the video loader to load its segment and update both the audio and video\n * timestamp offsets before it may load and append its own segment. This is the case\n * whether the seek results in a mismatched segment request (e.g., the audio loader\n * chooses to load segment 3 and the video loader chooses to load segment 4) or the\n * loaders choose to load the same segment index from each playlist, as the segments may\n * not be aligned perfectly, even for matching segment indexes.\n *\n * @param {Object} timelinechangeController\n * @param {number} currentTimeline\n *        The timeline currently being followed by the loader\n * @param {number} segmentTimeline\n *        The timeline of the segment being loaded\n * @param {('main'|'audio')} loaderType\n *        The loader type\n * @param {boolean} audioDisabled\n *        Whether the audio is disabled for the loader. This should only be true when the\n *        loader may have muxed audio in its segment, but should not append it, e.g., for\n *        the main loader when an alternate audio playlist is active.\n *\n * @return {boolean}\n *         Whether the loader should wait for a timeline change from the timeline change\n *         controller before processing the segment\n */\n\n\nvar shouldWaitForTimelineChange = function shouldWaitForTimelineChange(_ref2) {\n  var timelineChangeController = _ref2.timelineChangeController,\n      currentTimeline = _ref2.currentTimeline,\n      segmentTimeline = _ref2.segmentTimeline,\n      loaderType = _ref2.loaderType,\n      audioDisabled = _ref2.audioDisabled;\n\n  if (currentTimeline === segmentTimeline) {\n    return false;\n  }\n\n  if (loaderType === 'audio') {\n    var lastMainTimelineChange = timelineChangeController.lastTimelineChange({\n      type: 'main'\n    }); // Audio loader should wait if:\n    //\n    // * main hasn't had a timeline change yet (thus has not loaded its first segment)\n    // * main hasn't yet changed to the timeline audio is looking to load\n\n    return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;\n  } // The main loader only needs to wait for timeline changes if there's demuxed audio.\n  // Otherwise, there's nothing to wait for, since audio would be muxed into the main\n  // loader's segments (or the content is audio/video only and handled by the main\n  // loader).\n\n\n  if (loaderType === 'main' && audioDisabled) {\n    var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({\n      type: 'audio'\n    }); // Main loader should wait for the audio loader if audio is not pending a timeline\n    // change to the current timeline.\n    //\n    // Since the main loader is responsible for setting the timestamp offset for both\n    // audio and video, the main loader must wait for audio to be about to change to its\n    // timeline before setting the offset, otherwise, if audio is behind in loading,\n    // segments from the previous timeline would be adjusted by the new timestamp offset.\n    //\n    // This requirement means that video will not cross a timeline until the audio is\n    // about to cross to it, so that way audio and video will always cross the timeline\n    // together.\n    //\n    // In addition to normal timeline changes, these rules also apply to the start of a\n    // stream (going from a non-existent timeline, -1, to timeline 0). It's important\n    // that these rules apply to the first timeline change because if they did not, it's\n    // possible that the main loader will cross two timelines before the audio loader has\n    // crossed one. Logic may be implemented to handle the startup as a special case, but\n    // it's easier to simply treat all timeline changes the same.\n\n    if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * An object that manages segment loading and appending.\n *\n * @class SegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\n\nvar SegmentLoader = /*#__PURE__*/function (_videojs$EventTarget) {\n  _inheritsLoose(SegmentLoader, _videojs$EventTarget);\n\n  function SegmentLoader(settings, options) {\n    var _this;\n\n    _this = _videojs$EventTarget.call(this) || this; // check pre-conditions\n\n    if (!settings) {\n      throw new TypeError('Initialization settings are required');\n    }\n\n    if (typeof settings.currentTime !== 'function') {\n      throw new TypeError('No currentTime getter specified');\n    }\n\n    if (!settings.mediaSource) {\n      throw new TypeError('No MediaSource specified');\n    } // public properties\n\n\n    _this.bandwidth = settings.bandwidth;\n    _this.throughput = {\n      rate: 0,\n      count: 0\n    };\n    _this.roundTrip = NaN;\n\n    _this.resetStats_();\n\n    _this.mediaIndex = null; // private settings\n\n    _this.hasPlayed_ = settings.hasPlayed;\n    _this.currentTime_ = settings.currentTime;\n    _this.seekable_ = settings.seekable;\n    _this.seeking_ = settings.seeking;\n    _this.duration_ = settings.duration;\n    _this.mediaSource_ = settings.mediaSource;\n    _this.vhs_ = settings.vhs;\n    _this.loaderType_ = settings.loaderType;\n    _this.currentMediaInfo_ = void 0;\n    _this.startingMediaInfo_ = void 0;\n    _this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n    _this.goalBufferLength_ = settings.goalBufferLength;\n    _this.sourceType_ = settings.sourceType;\n    _this.sourceUpdater_ = settings.sourceUpdater;\n    _this.inbandTextTracks_ = settings.inbandTextTracks;\n    _this.state_ = 'INIT';\n    _this.handlePartialData_ = settings.handlePartialData;\n    _this.timelineChangeController_ = settings.timelineChangeController;\n    _this.shouldSaveSegmentTimingInfo_ = true; // private instance variables\n\n    _this.checkBufferTimeout_ = null;\n    _this.error_ = void 0;\n    _this.currentTimeline_ = -1;\n    _this.pendingSegment_ = null;\n    _this.xhrOptions_ = null;\n    _this.pendingSegments_ = [];\n    _this.audioDisabled_ = false;\n    _this.isPendingTimestampOffset_ = false; // TODO possibly move gopBuffer and timeMapping info to a separate controller\n\n    _this.gopBuffer_ = [];\n    _this.timeMapping_ = 0;\n    _this.safeAppend_ = videojs$1.browser.IE_VERSION >= 11;\n    _this.appendInitSegment_ = {\n      audio: true,\n      video: true\n    };\n    _this.playlistOfLastInitSegment_ = {\n      audio: null,\n      video: null\n    };\n    _this.callQueue_ = []; // If the segment loader prepares to load a segment, but does not have enough\n    // information yet to start the loading process (e.g., if the audio loader wants to\n    // load a segment from the next timeline but the main loader hasn't yet crossed that\n    // timeline), then the load call will be added to the queue until it is ready to be\n    // processed.\n\n    _this.loadQueue_ = [];\n    _this.metadataQueue_ = {\n      id3: [],\n      caption: []\n    }; // Fragmented mp4 playback\n\n    _this.activeInitSegmentId_ = null;\n    _this.initSegments_ = {}; // HLSe playback\n\n    _this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;\n    _this.keyCache_ = {};\n    _this.decrypter_ = settings.decrypter; // Manages the tracking and generation of sync-points, mappings\n    // between a time in the display time and a segment index within\n    // a playlist\n\n    _this.syncController_ = settings.syncController;\n    _this.syncPoint_ = {\n      segmentIndex: 0,\n      time: 0\n    };\n    _this.transmuxer_ = _this.createTransmuxer_();\n\n    _this.triggerSyncInfoUpdate_ = function () {\n      return _this.trigger('syncinfoupdate');\n    };\n\n    _this.syncController_.on('syncinfoupdate', _this.triggerSyncInfoUpdate_);\n\n    _this.mediaSource_.addEventListener('sourceopen', function () {\n      if (!_this.isEndOfStream_()) {\n        _this.ended_ = false;\n      }\n    }); // ...for determining the fetch location\n\n\n    _this.fetchAtBuffer_ = false;\n    _this.logger_ = logger(\"SegmentLoader[\" + _this.loaderType_ + \"]\");\n    Object.defineProperty(_assertThisInitialized(_this), 'state', {\n      get: function get() {\n        return this.state_;\n      },\n      set: function set(newState) {\n        if (newState !== this.state_) {\n          this.logger_(this.state_ + \" -> \" + newState);\n          this.state_ = newState;\n          this.trigger('statechange');\n        }\n      }\n    });\n\n    _this.sourceUpdater_.on('ready', function () {\n      if (_this.hasEnoughInfoToAppend_()) {\n        _this.processCallQueue_();\n      }\n    }); // Only the main loader needs to listen for pending timeline changes, as the main\n    // loader should wait for audio to be ready to change its timeline so that both main\n    // and audio timelines change together. For more details, see the\n    // shouldWaitForTimelineChange function.\n\n\n    if (_this.loaderType_ === 'main') {\n      _this.timelineChangeController_.on('pendingtimelinechange', function () {\n        if (_this.hasEnoughInfoToAppend_()) {\n          _this.processCallQueue_();\n        }\n      });\n    } // The main loader only listens on pending timeline changes, but the audio loader,\n    // since its loads follow main, needs to listen on timeline changes. For more details,\n    // see the shouldWaitForTimelineChange function.\n\n\n    if (_this.loaderType_ === 'audio') {\n      _this.timelineChangeController_.on('timelinechange', function () {\n        if (_this.hasEnoughInfoToLoad_()) {\n          _this.processLoadQueue_();\n        }\n\n        if (_this.hasEnoughInfoToAppend_()) {\n          _this.processCallQueue_();\n        }\n      });\n    }\n\n    return _this;\n  }\n\n  var _proto = SegmentLoader.prototype;\n\n  _proto.createTransmuxer_ = function createTransmuxer_() {\n    var transmuxer = new TransmuxWorker();\n    transmuxer.postMessage({\n      action: 'init',\n      options: {\n        remux: false,\n        alignGopsAtEnd: this.safeAppend_,\n        keepOriginalTimestamps: true,\n        handlePartialData: this.handlePartialData_\n      }\n    });\n    return transmuxer;\n  }\n  /**\n   * reset all of our media stats\n   *\n   * @private\n   */\n  ;\n\n  _proto.resetStats_ = function resetStats_() {\n    this.mediaBytesTransferred = 0;\n    this.mediaRequests = 0;\n    this.mediaRequestsAborted = 0;\n    this.mediaRequestsTimedout = 0;\n    this.mediaRequestsErrored = 0;\n    this.mediaTransferDuration = 0;\n    this.mediaSecondsLoaded = 0;\n  }\n  /**\n   * dispose of the SegmentLoader and reset to the default state\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.trigger('dispose');\n    this.state = 'DISPOSED';\n    this.pause();\n    this.abort_();\n\n    if (this.transmuxer_) {\n      this.transmuxer_.terminate(); // Although it isn't an instance of a class, the segment transmuxer must still be\n      // cleaned up.\n\n      segmentTransmuxer.dispose();\n    }\n\n    this.resetStats_();\n\n    if (this.checkBufferTimeout_) {\n      window$1.clearTimeout(this.checkBufferTimeout_);\n    }\n\n    if (this.syncController_ && this.triggerSyncInfoUpdate_) {\n      this.syncController_.off('syncinfoupdate', this.triggerSyncInfoUpdate_);\n    }\n\n    this.off();\n  };\n\n  _proto.setAudio = function setAudio(enable) {\n    this.audioDisabled_ = !enable;\n\n    if (enable) {\n      this.appendInitSegment_.audio = true;\n    } else {\n      // remove current track audio if it gets disabled\n      this.sourceUpdater_.removeAudio(0, this.duration_());\n    }\n  }\n  /**\n   * abort anything that is currently doing on with the SegmentLoader\n   * and reset to a default state\n   */\n  ;\n\n  _proto.abort = function abort() {\n    if (this.state !== 'WAITING') {\n      if (this.pendingSegment_) {\n        this.pendingSegment_ = null;\n      }\n\n      return;\n    }\n\n    this.abort_(); // We aborted the requests we were waiting on, so reset the loader's state to READY\n    // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n    // when the request is aborted. This will prevent the loader from being stuck in the\n    // WAITING state indefinitely.\n\n    this.state = 'READY'; // don't wait for buffer check timeouts to begin fetching the\n    // next segment\n\n    if (!this.paused()) {\n      this.monitorBuffer_();\n    }\n  }\n  /**\n   * abort all pending xhr requests and null any pending segements\n   *\n   * @private\n   */\n  ;\n\n  _proto.abort_ = function abort_() {\n    if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {\n      this.pendingSegment_.abortRequests();\n    } // clear out the segment being processed\n\n\n    this.pendingSegment_ = null;\n    this.callQueue_ = [];\n    this.loadQueue_ = [];\n    this.metadataQueue_.id3 = [];\n    this.metadataQueue_.caption = [];\n    this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);\n  };\n\n  _proto.checkForAbort_ = function checkForAbort_(requestId) {\n    // If the state is APPENDING, then aborts will not modify the state, meaning the first\n    // callback that happens should reset the state to READY so that loading can continue.\n    if (this.state === 'APPENDING' && !this.pendingSegment_) {\n      this.state = 'READY';\n      return true;\n    }\n\n    if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * set an error on the segment loader and null out any pending segements\n   *\n   * @param {Error} error the error to set on the SegmentLoader\n   * @return {Error} the error that was set or that is currently set\n   */\n  ;\n\n  _proto.error = function error(_error) {\n    if (typeof _error !== 'undefined') {\n      this.logger_('error occurred:', _error);\n      this.error_ = _error;\n    }\n\n    this.pendingSegment_ = null;\n    return this.error_;\n  };\n\n  _proto.endOfStream = function endOfStream() {\n    this.ended_ = true;\n\n    if (this.transmuxer_) {\n      // need to clear out any cached data to prepare for the new segment\n      segmentTransmuxer.reset(this.transmuxer_);\n    }\n\n    this.gopBuffer_.length = 0;\n    this.pause();\n    this.trigger('ended');\n  }\n  /**\n   * Indicates which time ranges are buffered\n   *\n   * @return {TimeRange}\n   *         TimeRange object representing the current buffered ranges\n   */\n  ;\n\n  _proto.buffered_ = function buffered_() {\n    if (!this.sourceUpdater_ || !this.startingMediaInfo_) {\n      return videojs$1.createTimeRanges();\n    }\n\n    if (this.loaderType_ === 'main') {\n      var _this$startingMediaIn = this.startingMediaInfo_,\n          hasAudio = _this$startingMediaIn.hasAudio,\n          hasVideo = _this$startingMediaIn.hasVideo,\n          isMuxed = _this$startingMediaIn.isMuxed;\n\n      if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) {\n        return this.sourceUpdater_.buffered();\n      }\n\n      if (hasVideo) {\n        return this.sourceUpdater_.videoBuffered();\n      }\n    } // One case that can be ignored for now is audio only with alt audio,\n    // as we don't yet have proper support for that.\n\n\n    return this.sourceUpdater_.audioBuffered();\n  }\n  /**\n   * Gets and sets init segment for the provided map\n   *\n   * @param {Object} map\n   *        The map object representing the init segment to get or set\n   * @param {boolean=} set\n   *        If true, the init segment for the provided map should be saved\n   * @return {Object}\n   *         map object for desired init segment\n   */\n  ;\n\n  _proto.initSegmentForMap = function initSegmentForMap(map, set) {\n    if (set === void 0) {\n      set = false;\n    }\n\n    if (!map) {\n      return null;\n    }\n\n    var id = initSegmentId(map);\n    var storedMap = this.initSegments_[id];\n\n    if (set && !storedMap && map.bytes) {\n      this.initSegments_[id] = storedMap = {\n        resolvedUri: map.resolvedUri,\n        byterange: map.byterange,\n        bytes: map.bytes,\n        tracks: map.tracks,\n        timescales: map.timescales\n      };\n    }\n\n    return storedMap || map;\n  }\n  /**\n   * Gets and sets key for the provided key\n   *\n   * @param {Object} key\n   *        The key object representing the key to get or set\n   * @param {boolean=} set\n   *        If true, the key for the provided key should be saved\n   * @return {Object}\n   *         Key object for desired key\n   */\n  ;\n\n  _proto.segmentKey = function segmentKey(key, set) {\n    if (set === void 0) {\n      set = false;\n    }\n\n    if (!key) {\n      return null;\n    }\n\n    var id = segmentKeyId(key);\n    var storedKey = this.keyCache_[id]; // TODO: We should use the HTTP Expires header to invalidate our cache per\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-6.2.3\n\n    if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) {\n      this.keyCache_[id] = storedKey = {\n        resolvedUri: key.resolvedUri,\n        bytes: key.bytes\n      };\n    }\n\n    var result = {\n      resolvedUri: (storedKey || key).resolvedUri\n    };\n\n    if (storedKey) {\n      result.bytes = storedKey.bytes;\n    }\n\n    return result;\n  }\n  /**\n   * Returns true if all configuration required for loading is present, otherwise false.\n   *\n   * @return {boolean} True if the all configuration is ready for loading\n   * @private\n   */\n  ;\n\n  _proto.couldBeginLoading_ = function couldBeginLoading_() {\n    return this.playlist_ && !this.paused();\n  }\n  /**\n   * load a playlist and start to fill the buffer\n   */\n  ;\n\n  _proto.load = function load() {\n    // un-pause\n    this.monitorBuffer_(); // if we don't have a playlist yet, keep waiting for one to be\n    // specified\n\n    if (!this.playlist_) {\n      return;\n    } // not sure if this is the best place for this\n\n\n    this.syncController_.setDateTimeMapping(this.playlist_); // if all the configuration is ready, initialize and begin loading\n\n    if (this.state === 'INIT' && this.couldBeginLoading_()) {\n      return this.init_();\n    } // if we're in the middle of processing a segment already, don't\n    // kick off an additional segment request\n\n\n    if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n      return;\n    }\n\n    this.state = 'READY';\n  }\n  /**\n   * Once all the starting parameters have been specified, begin\n   * operation. This method should only be invoked from the INIT\n   * state.\n   *\n   * @private\n   */\n  ;\n\n  _proto.init_ = function init_() {\n    this.state = 'READY'; // if this is the audio segment loader, and it hasn't been inited before, then any old\n    // audio data from the muxed content should be removed\n\n    this.resetEverything();\n    return this.monitorBuffer_();\n  }\n  /**\n   * set a playlist on the segment loader\n   *\n   * @param {PlaylistLoader} media the playlist to set on the segment loader\n   */\n  ;\n\n  _proto.playlist = function playlist(newPlaylist, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!newPlaylist) {\n      return;\n    }\n\n    var oldPlaylist = this.playlist_;\n    var segmentInfo = this.pendingSegment_;\n    this.playlist_ = newPlaylist;\n    this.xhrOptions_ = options; // when we haven't started playing yet, the start of a live playlist\n    // is always our zero-time so force a sync update each time the playlist\n    // is refreshed from the server\n    //\n    // Use the INIT state to determine if playback has started, as the playlist sync info\n    // should be fixed once requests begin (as sync points are generated based on sync\n    // info), but not before then.\n\n    if (this.state === 'INIT') {\n      newPlaylist.syncInfo = {\n        mediaSequence: newPlaylist.mediaSequence,\n        time: 0\n      };\n    }\n\n    var oldId = null;\n\n    if (oldPlaylist) {\n      if (oldPlaylist.id) {\n        oldId = oldPlaylist.id;\n      } else if (oldPlaylist.uri) {\n        oldId = oldPlaylist.uri;\n      }\n    }\n\n    this.logger_(\"playlist update [\" + oldId + \" => \" + (newPlaylist.id || newPlaylist.uri) + \"]\"); // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n    // in LIVE, we always want to update with new playlists (including refreshes)\n\n    this.trigger('syncinfoupdate'); // if we were unpaused but waiting for a playlist, start\n    // buffering now\n\n    if (this.state === 'INIT' && this.couldBeginLoading_()) {\n      return this.init_();\n    }\n\n    if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n      if (this.mediaIndex !== null || this.handlePartialData_) {\n        // we must \"resync\" the segment loader when we switch renditions and\n        // the segment loader is already synced to the previous rendition\n        //\n        // or if we're handling partial data, we need to ensure the transmuxer is cleared\n        // out before we start adding more data\n        this.resyncLoader();\n      }\n\n      this.currentMediaInfo_ = void 0;\n      this.trigger('playlistupdate'); // the rest of this function depends on `oldPlaylist` being defined\n\n      return;\n    } // we reloaded the same playlist so we are in a live scenario\n    // and we will likely need to adjust the mediaIndex\n\n\n    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n    this.logger_(\"live window shift [\" + mediaSequenceDiff + \"]\"); // update the mediaIndex on the SegmentLoader\n    // this is important because we can abort a request and this value must be\n    // equal to the last appended mediaIndex\n\n    if (this.mediaIndex !== null) {\n      this.mediaIndex -= mediaSequenceDiff;\n    } // update the mediaIndex on the SegmentInfo object\n    // this is important because we will update this.mediaIndex with this value\n    // in `handleAppendsDone_` after the segment has been successfully appended\n\n\n    if (segmentInfo) {\n      segmentInfo.mediaIndex -= mediaSequenceDiff; // we need to update the referenced segment so that timing information is\n      // saved for the new playlist's segment, however, if the segment fell off the\n      // playlist, we can leave the old reference and just lose the timing info\n\n      if (segmentInfo.mediaIndex >= 0) {\n        segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n      }\n    }\n\n    this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n  }\n  /**\n   * Prevent the loader from fetching additional segments. If there\n   * is a segment request outstanding, it will finish processing\n   * before the loader halts. A segment loader can be unpaused by\n   * calling load().\n   */\n  ;\n\n  _proto.pause = function pause() {\n    if (this.checkBufferTimeout_) {\n      window$1.clearTimeout(this.checkBufferTimeout_);\n      this.checkBufferTimeout_ = null;\n    }\n  }\n  /**\n   * Returns whether the segment loader is fetching additional\n   * segments when given the opportunity. This property can be\n   * modified through calls to pause() and load().\n   */\n  ;\n\n  _proto.paused = function paused() {\n    return this.checkBufferTimeout_ === null;\n  }\n  /**\n   * Delete all the buffered data and reset the SegmentLoader\n   *\n   * @param {Function} [done] an optional callback to be executed when the remove\n   * operation is complete\n   */\n  ;\n\n  _proto.resetEverything = function resetEverything(done) {\n    this.ended_ = false;\n    this.appendInitSegment_ = {\n      audio: true,\n      video: true\n    };\n    this.resetLoader(); // remove from 0, the earliest point, to Infinity, to signify removal of everything.\n    // VTT Segment Loader doesn't need to do anything but in the regular SegmentLoader,\n    // we then clamp the value to duration if necessary.\n\n    this.remove(0, Infinity, done); // clears fmp4 captions\n\n    if (this.transmuxer_) {\n      this.transmuxer_.postMessage({\n        action: 'clearAllMp4Captions'\n      });\n    }\n  }\n  /**\n   * Force the SegmentLoader to resync and start loading around the currentTime instead\n   * of starting at the end of the buffer\n   *\n   * Useful for fast quality changes\n   */\n  ;\n\n  _proto.resetLoader = function resetLoader() {\n    this.fetchAtBuffer_ = false;\n    this.resyncLoader();\n  }\n  /**\n   * Force the SegmentLoader to restart synchronization and make a conservative guess\n   * before returning to the simple walk-forward method\n   */\n  ;\n\n  _proto.resyncLoader = function resyncLoader() {\n    if (this.transmuxer_) {\n      // need to clear out any cached data to prepare for the new segment\n      segmentTransmuxer.reset(this.transmuxer_);\n    }\n\n    this.mediaIndex = null;\n    this.syncPoint_ = null;\n    this.isPendingTimestampOffset_ = false;\n    this.callQueue_ = [];\n    this.loadQueue_ = [];\n    this.metadataQueue_.id3 = [];\n    this.metadataQueue_.caption = [];\n    this.abort();\n\n    if (this.transmuxer_) {\n      this.transmuxer_.postMessage({\n        action: 'clearParsedMp4Captions'\n      });\n    }\n  }\n  /**\n   * Remove any data in the source buffer between start and end times\n   *\n   * @param {number} start - the start time of the region to remove from the buffer\n   * @param {number} end - the end time of the region to remove from the buffer\n   * @param {Function} [done] - an optional callback to be executed when the remove\n   * operation is complete\n   */\n  ;\n\n  _proto.remove = function remove(start, end, done) {\n    if (done === void 0) {\n      done = function done() {};\n    } // clamp end to duration if we need to remove everything.\n    // This is due to a browser bug that causes issues if we remove to Infinity.\n    // videojs/videojs-contrib-hls#1225\n\n\n    if (end === Infinity) {\n      end = this.duration_();\n    }\n\n    if (!this.sourceUpdater_ || !this.currentMediaInfo_) {\n      // nothing to remove if we haven't processed any media\n      return;\n    } // set it to one to complete this function's removes\n\n\n    var removesRemaining = 1;\n\n    var removeFinished = function removeFinished() {\n      removesRemaining--;\n\n      if (removesRemaining === 0) {\n        done();\n      }\n    };\n\n    if (!this.audioDisabled_) {\n      removesRemaining++;\n      this.sourceUpdater_.removeAudio(start, end, removeFinished);\n    }\n\n    if (this.loaderType_ === 'main' && this.currentMediaInfo_ && this.currentMediaInfo_.hasVideo) {\n      this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n      removesRemaining++;\n      this.sourceUpdater_.removeVideo(start, end, removeFinished);\n    } // remove any captions and ID3 tags\n\n\n    for (var track in this.inbandTextTracks_) {\n      removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);\n    }\n\n    removeCuesFromTrack(start, end, this.segmentMetadataTrack_); // finished this function's removes\n\n    removeFinished();\n  }\n  /**\n   * (re-)schedule monitorBufferTick_ to run as soon as possible\n   *\n   * @private\n   */\n  ;\n\n  _proto.monitorBuffer_ = function monitorBuffer_() {\n    if (this.checkBufferTimeout_) {\n      window$1.clearTimeout(this.checkBufferTimeout_);\n    }\n\n    this.checkBufferTimeout_ = window$1.setTimeout(this.monitorBufferTick_.bind(this), 1);\n  }\n  /**\n   * As long as the SegmentLoader is in the READY state, periodically\n   * invoke fillBuffer_().\n   *\n   * @private\n   */\n  ;\n\n  _proto.monitorBufferTick_ = function monitorBufferTick_() {\n    if (this.state === 'READY') {\n      this.fillBuffer_();\n    }\n\n    if (this.checkBufferTimeout_) {\n      window$1.clearTimeout(this.checkBufferTimeout_);\n    }\n\n    this.checkBufferTimeout_ = window$1.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n  }\n  /**\n   * fill the buffer with segements unless the sourceBuffers are\n   * currently updating\n   *\n   * Note: this function should only ever be called by monitorBuffer_\n   * and never directly\n   *\n   * @private\n   */\n  ;\n\n  _proto.fillBuffer_ = function fillBuffer_() {\n    // TODO since the source buffer maintains a queue, and we shouldn't call this function\n    // except when we're ready for the next segment, this check can most likely be removed\n    if (this.sourceUpdater_.updating()) {\n      return;\n    }\n\n    if (!this.syncPoint_) {\n      this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n    }\n\n    var buffered = this.buffered_(); // see if we need to begin loading immediately\n\n    var segmentInfo = this.checkBuffer_(buffered, this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n\n    if (!segmentInfo) {\n      return;\n    }\n\n    segmentInfo.timestampOffset = timestampOffsetForSegment({\n      segmentTimeline: segmentInfo.timeline,\n      currentTimeline: this.currentTimeline_,\n      startOfSegment: segmentInfo.startOfSegment,\n      buffered: buffered,\n      overrideCheck: this.isPendingTimestampOffset_\n    });\n    this.isPendingTimestampOffset_ = false;\n\n    if (typeof segmentInfo.timestampOffset === 'number') {\n      this.timelineChangeController_.pendingTimelineChange({\n        type: this.loaderType_,\n        from: this.currentTimeline_,\n        to: segmentInfo.timeline\n      });\n    }\n\n    this.loadSegment_(segmentInfo);\n  }\n  /**\n   * Determines if we should call endOfStream on the media source based\n   * on the state of the buffer or if appened segment was the final\n   * segment in the playlist.\n   *\n   * @param {number} [mediaIndex] the media index of segment we last appended\n   * @param {Object} [playlist] a media playlist object\n   * @return {boolean} do we need to call endOfStream on the MediaSource\n   */\n  ;\n\n  _proto.isEndOfStream_ = function isEndOfStream_(mediaIndex, playlist) {\n    if (mediaIndex === void 0) {\n      mediaIndex = this.mediaIndex;\n    }\n\n    if (playlist === void 0) {\n      playlist = this.playlist_;\n    }\n\n    if (!playlist || !this.mediaSource_) {\n      return false;\n    } // mediaIndex is zero based but length is 1 based\n\n\n    var appendedLastSegment = mediaIndex + 1 === playlist.segments.length; // if we've buffered to the end of the video, we need to call endOfStream\n    // so that MediaSources can trigger the `ended` event when it runs out of\n    // buffered data instead of waiting for me\n\n    return playlist.endList && this.mediaSource_.readyState === 'open' && appendedLastSegment;\n  }\n  /**\n   * Determines what segment request should be made, given current playback\n   * state.\n   *\n   * @param {TimeRanges} buffered - the state of the buffer\n   * @param {Object} playlist - the playlist object to fetch segments from\n   * @param {number} mediaIndex - the previous mediaIndex fetched or null\n   * @param {boolean} hasPlayed - a flag indicating whether we have played or not\n   * @param {number} currentTime - the playback position in seconds\n   * @param {Object} syncPoint - a segment info object that describes the\n   * @return {Object} a segment request object that describes the segment to load\n   */\n  ;\n\n  _proto.checkBuffer_ = function checkBuffer_(buffered, playlist, currentMediaIndex, hasPlayed, currentTime, syncPoint) {\n    var lastBufferedEnd = 0;\n\n    if (buffered.length) {\n      lastBufferedEnd = buffered.end(buffered.length - 1);\n    }\n\n    var bufferedTime = Math.max(0, lastBufferedEnd - currentTime);\n\n    if (!playlist.segments.length) {\n      return null;\n    } // if there is plenty of content buffered, and the video has\n    // been played before relax for awhile\n\n\n    if (bufferedTime >= this.goalBufferLength_()) {\n      return null;\n    } // if the video has not yet played once, and we already have\n    // one segment downloaded do nothing\n\n\n    if (!hasPlayed && bufferedTime >= 1) {\n      return null;\n    }\n\n    var nextMediaIndex = null;\n    var startOfSegment;\n    var isSyncRequest = false; // When the syncPoint is null, there is no way of determining a good\n    // conservative segment index to fetch from\n    // The best thing to do here is to get the kind of sync-point data by\n    // making a request\n\n    if (syncPoint === null) {\n      nextMediaIndex = this.getSyncSegmentCandidate_(playlist);\n      isSyncRequest = true;\n    } else if (currentMediaIndex !== null) {\n      // Under normal playback conditions fetching is a simple walk forward\n      var segment = playlist.segments[currentMediaIndex];\n\n      if (segment && segment.end) {\n        startOfSegment = segment.end;\n      } else {\n        startOfSegment = lastBufferedEnd;\n      }\n\n      nextMediaIndex = currentMediaIndex + 1; // There is a sync-point but the lack of a mediaIndex indicates that\n      // we need to make a good conservative guess about which segment to\n      // fetch\n    } else if (this.fetchAtBuffer_) {\n      // Find the segment containing the end of the buffer\n      var mediaSourceInfo = Playlist.getMediaInfoForTime(playlist, lastBufferedEnd, syncPoint.segmentIndex, syncPoint.time);\n      nextMediaIndex = mediaSourceInfo.mediaIndex;\n      startOfSegment = mediaSourceInfo.startTime;\n    } else {\n      // Find the segment containing currentTime\n      var _mediaSourceInfo = Playlist.getMediaInfoForTime(playlist, currentTime, syncPoint.segmentIndex, syncPoint.time);\n\n      nextMediaIndex = _mediaSourceInfo.mediaIndex;\n      startOfSegment = _mediaSourceInfo.startTime;\n    }\n\n    var segmentInfo = this.generateSegmentInfo_(playlist, nextMediaIndex, startOfSegment, isSyncRequest);\n\n    if (!segmentInfo) {\n      return;\n    } // if this is the last segment in the playlist\n    // we are not seeking and end of stream has already been called\n    // do not re-request\n\n\n    if (this.mediaSource_ && this.playlist_ && segmentInfo.mediaIndex === this.playlist_.segments.length - 1 && this.mediaSource_.readyState === 'ended' && !this.seeking_()) {\n      return;\n    }\n\n    this.logger_(\"checkBuffer_ returning \" + segmentInfo.uri, {\n      segmentInfo: segmentInfo,\n      playlist: playlist,\n      currentMediaIndex: currentMediaIndex,\n      nextMediaIndex: nextMediaIndex,\n      startOfSegment: startOfSegment,\n      isSyncRequest: isSyncRequest\n    });\n    return segmentInfo;\n  }\n  /**\n   * The segment loader has no recourse except to fetch a segment in the\n   * current playlist and use the internal timestamps in that segment to\n   * generate a syncPoint. This function returns a good candidate index\n   * for that process.\n   *\n   * @param {Object} playlist - the playlist object to look for a\n   * @return {number} An index of a segment from the playlist to load\n   */\n  ;\n\n  _proto.getSyncSegmentCandidate_ = function getSyncSegmentCandidate_(playlist) {\n    var _this2 = this;\n\n    if (this.currentTimeline_ === -1) {\n      return 0;\n    }\n\n    var segmentIndexArray = playlist.segments.map(function (s, i) {\n      return {\n        timeline: s.timeline,\n        segmentIndex: i\n      };\n    }).filter(function (s) {\n      return s.timeline === _this2.currentTimeline_;\n    });\n\n    if (segmentIndexArray.length) {\n      return segmentIndexArray[Math.min(segmentIndexArray.length - 1, 1)].segmentIndex;\n    }\n\n    return Math.max(playlist.segments.length - 1, 0);\n  };\n\n  _proto.generateSegmentInfo_ = function generateSegmentInfo_(playlist, mediaIndex, startOfSegment, isSyncRequest) {\n    if (mediaIndex < 0 || mediaIndex >= playlist.segments.length) {\n      return null;\n    }\n\n    var segment = playlist.segments[mediaIndex];\n    var audioBuffered = this.sourceUpdater_.audioBuffered();\n    var videoBuffered = this.sourceUpdater_.videoBuffered();\n    var audioAppendStart;\n    var gopsToAlignWith;\n\n    if (audioBuffered.length) {\n      // since the transmuxer is using the actual timing values, but the buffer is\n      // adjusted by the timestamp offset, we must adjust the value here\n      audioAppendStart = audioBuffered.end(audioBuffered.length - 1) - this.sourceUpdater_.audioTimestampOffset();\n    }\n\n    if (videoBuffered.length) {\n      gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_, // since the transmuxer is using the actual timing values, but the time is\n      // adjusted by the timestmap offset, we must adjust the value here\n      this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);\n    }\n\n    return {\n      requestId: 'segment-loader-' + Math.random(),\n      // resolve the segment URL relative to the playlist\n      uri: segment.resolvedUri,\n      // the segment's mediaIndex at the time it was requested\n      mediaIndex: mediaIndex,\n      // whether or not to update the SegmentLoader's state with this\n      // segment's mediaIndex\n      isSyncRequest: isSyncRequest,\n      startOfSegment: startOfSegment,\n      // the segment's playlist\n      playlist: playlist,\n      // unencrypted bytes of the segment\n      bytes: null,\n      // when a key is defined for this segment, the encrypted bytes\n      encryptedBytes: null,\n      // The target timestampOffset for this segment when we append it\n      // to the source buffer\n      timestampOffset: null,\n      // The timeline that the segment is in\n      timeline: segment.timeline,\n      // The expected duration of the segment in seconds\n      duration: segment.duration,\n      // retain the segment in case the playlist updates while doing an async process\n      segment: segment,\n      byteLength: 0,\n      transmuxer: this.transmuxer_,\n      audioAppendStart: audioAppendStart,\n      gopsToAlignWith: gopsToAlignWith\n    };\n  }\n  /**\n   * Determines if the network has enough bandwidth to complete the current segment\n   * request in a timely manner. If not, the request will be aborted early and bandwidth\n   * updated to trigger a playlist switch.\n   *\n   * @param {Object} stats\n   *        Object containing stats about the request timing and size\n   * @return {boolean} True if the request was aborted, false otherwise\n   * @private\n   */\n  ;\n\n  _proto.abortRequestEarly_ = function abortRequestEarly_(stats) {\n    if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition\n    // TODO: Replace using timeout with a boolean indicating whether this playlist is\n    //       the lowestEnabledRendition.\n    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes\n    !this.playlist_.attributes.BANDWIDTH) {\n      return false;\n    } // Wait at least 1 second since the first byte of data has been received before\n    // using the calculated bandwidth from the progress event to allow the bitrate\n    // to stabilize\n\n\n    if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n      return false;\n    }\n\n    var currentTime = this.currentTime_();\n    var measuredBandwidth = stats.bandwidth;\n    var segmentDuration = this.pendingSegment_.duration;\n    var requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived); // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n    // if we are only left with less than 1 second when the request completes.\n    // A negative timeUntilRebuffering indicates we are already rebuffering\n\n    var timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1; // Only consider aborting early if the estimated time to finish the download\n    // is larger than the estimated time until the player runs out of forward buffer\n\n    if (requestTimeRemaining <= timeUntilRebuffer$1) {\n      return false;\n    }\n\n    var switchCandidate = minRebufferMaxBandwidthSelector({\n      master: this.vhs_.playlists.master,\n      currentTime: currentTime,\n      bandwidth: measuredBandwidth,\n      duration: this.duration_(),\n      segmentDuration: segmentDuration,\n      timeUntilRebuffer: timeUntilRebuffer$1,\n      currentTimeline: this.currentTimeline_,\n      syncController: this.syncController_\n    });\n\n    if (!switchCandidate) {\n      return;\n    }\n\n    var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;\n    var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n    var minimumTimeSaving = 0.5; // If we are already rebuffering, increase the amount of variance we add to the\n    // potential round trip time of the new request so that we are not too aggressive\n    // with switching to a playlist that might save us a fraction of a second.\n\n    if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {\n      minimumTimeSaving = 1;\n    }\n\n    if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n      return false;\n    } // set the bandwidth to that of the desired playlist being sure to scale by\n    // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n    // don't trigger a bandwidthupdate as the bandwidth is artifial\n\n\n    this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;\n    this.abort();\n    this.trigger('earlyabort');\n    return true;\n  };\n\n  _proto.handleAbort_ = function handleAbort_() {\n    this.mediaRequestsAborted += 1;\n  }\n  /**\n   * XHR `progress` event handler\n   *\n   * @param {Event}\n   *        The XHR `progress` event\n   * @param {Object} simpleSegment\n   *        A simplified segment object copy\n   * @private\n   */\n  ;\n\n  _proto.handleProgress_ = function handleProgress_(event, simpleSegment) {\n    if (this.checkForAbort_(simpleSegment.requestId) || this.abortRequestEarly_(simpleSegment.stats)) {\n      return;\n    }\n\n    this.trigger('progress');\n  };\n\n  _proto.handleTrackInfo_ = function handleTrackInfo_(simpleSegment, trackInfo) {\n    if (this.checkForAbort_(simpleSegment.requestId) || this.abortRequestEarly_(simpleSegment.stats)) {\n      return;\n    }\n\n    if (this.checkForIllegalMediaSwitch(trackInfo)) {\n      return;\n    }\n\n    trackInfo = trackInfo || {}; // When we have track info, determine what media types this loader is dealing with.\n    // Guard against cases where we're not getting track info at all until we are\n    // certain that all streams will provide it.\n\n    if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {\n      this.appendInitSegment_ = {\n        audio: true,\n        video: true\n      };\n      this.startingMediaInfo_ = trackInfo;\n      this.currentMediaInfo_ = trackInfo;\n      this.logger_('trackinfo update', trackInfo);\n      this.trigger('trackinfo');\n    } // trackinfo may cause an abort if the trackinfo\n    // causes a codec change to an unsupported codec.\n\n\n    if (this.checkForAbort_(simpleSegment.requestId) || this.abortRequestEarly_(simpleSegment.stats)) {\n      return;\n    } // set trackinfo on the pending segment so that\n    // it can append.\n\n\n    this.pendingSegment_.trackInfo = trackInfo; // check if any calls were waiting on the track info\n\n    if (this.hasEnoughInfoToAppend_()) {\n      this.processCallQueue_();\n    }\n  };\n\n  _proto.handleTimingInfo_ = function handleTimingInfo_(simpleSegment, mediaType, timeType, time) {\n    if (this.checkForAbort_(simpleSegment.requestId) || this.abortRequestEarly_(simpleSegment.stats)) {\n      return;\n    }\n\n    var segmentInfo = this.pendingSegment_;\n    var timingInfoProperty = timingInfoPropertyForMedia(mediaType);\n    segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};\n    segmentInfo[timingInfoProperty][timeType] = time;\n    this.logger_(\"timinginfo: \" + mediaType + \" - \" + timeType + \" - \" + time); // check if any calls were waiting on the timing info\n\n    if (this.hasEnoughInfoToAppend_()) {\n      this.processCallQueue_();\n    }\n  };\n\n  _proto.handleCaptions_ = function handleCaptions_(simpleSegment, captionData) {\n    var _this3 = this;\n\n    if (this.checkForAbort_(simpleSegment.requestId) || this.abortRequestEarly_(simpleSegment.stats)) {\n      return;\n    } // This could only happen with fmp4 segments, but\n    // should still not happen in general\n\n\n    if (captionData.length === 0) {\n      this.logger_('SegmentLoader received no captions from a caption event');\n      return;\n    }\n\n    var segmentInfo = this.pendingSegment_; // Wait until we have some video data so that caption timing\n    // can be adjusted by the timestamp offset\n\n    if (!segmentInfo.hasAppendedData_) {\n      this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));\n      return;\n    }\n\n    var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();\n    var captionTracks = {}; // get total start/end and captions for each track/stream\n\n    captionData.forEach(function (caption) {\n      // caption.stream is actually a track name...\n      // set to the existing values in tracks or default values\n      captionTracks[caption.stream] = captionTracks[caption.stream] || {\n        // Infinity, as any other value will be less than this\n        startTime: Infinity,\n        captions: [],\n        // 0 as an other value will be more than this\n        endTime: 0\n      };\n      var captionTrack = captionTracks[caption.stream];\n      captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);\n      captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);\n      captionTrack.captions.push(caption);\n    });\n    Object.keys(captionTracks).forEach(function (trackName) {\n      var _captionTracks$trackN = captionTracks[trackName],\n          startTime = _captionTracks$trackN.startTime,\n          endTime = _captionTracks$trackN.endTime,\n          captions = _captionTracks$trackN.captions;\n      var inbandTextTracks = _this3.inbandTextTracks_;\n\n      _this3.logger_(\"adding cues from \" + startTime + \" -> \" + endTime + \" for \" + trackName);\n\n      createCaptionsTrackIfNotExists(inbandTextTracks, _this3.vhs_.tech_, trackName); // clear out any cues that start and end at the same time period for the same track.\n      // We do this because a rendition change that also changes the timescale for captions\n      // will result in captions being re-parsed for certain segments. If we add them again\n      // without clearing we will have two of the same captions visible.\n\n      removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);\n      addCaptionData({\n        captionArray: captions,\n        inbandTextTracks: inbandTextTracks,\n        timestampOffset: timestampOffset\n      });\n    }); // Reset stored captions since we added parsed\n    // captions to a text track at this point\n\n    if (this.transmuxer_) {\n      this.transmuxer_.postMessage({\n        action: 'clearParsedMp4Captions'\n      });\n    }\n  };\n\n  _proto.handleId3_ = function handleId3_(simpleSegment, id3Frames, dispatchType) {\n    if (this.checkForAbort_(simpleSegment.requestId) || this.abortRequestEarly_(simpleSegment.stats)) {\n      return;\n    }\n\n    var segmentInfo = this.pendingSegment_; // we need to have appended data in order for the timestamp offset to be set\n\n    if (!segmentInfo.hasAppendedData_) {\n      this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));\n      return;\n    }\n\n    var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(); // There's potentially an issue where we could double add metadata if there's a muxed\n    // audio/video source with a metadata track, and an alt audio with a metadata track.\n    // However, this probably won't happen, and if it does it can be handled then.\n\n    createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);\n    addMetadata({\n      inbandTextTracks: this.inbandTextTracks_,\n      metadataArray: id3Frames,\n      timestampOffset: timestampOffset,\n      videoDuration: this.duration_()\n    });\n  };\n\n  _proto.processMetadataQueue_ = function processMetadataQueue_() {\n    this.metadataQueue_.id3.forEach(function (fn) {\n      return fn();\n    });\n    this.metadataQueue_.caption.forEach(function (fn) {\n      return fn();\n    });\n    this.metadataQueue_.id3 = [];\n    this.metadataQueue_.caption = [];\n  };\n\n  _proto.processCallQueue_ = function processCallQueue_() {\n    var callQueue = this.callQueue_; // Clear out the queue before the queued functions are run, since some of the\n    // functions may check the length of the load queue and default to pushing themselves\n    // back onto the queue.\n\n    this.callQueue_ = [];\n    callQueue.forEach(function (fun) {\n      return fun();\n    });\n  };\n\n  _proto.processLoadQueue_ = function processLoadQueue_() {\n    var loadQueue = this.loadQueue_; // Clear out the queue before the queued functions are run, since some of the\n    // functions may check the length of the load queue and default to pushing themselves\n    // back onto the queue.\n\n    this.loadQueue_ = [];\n    loadQueue.forEach(function (fun) {\n      return fun();\n    });\n  }\n  /**\n   * Determines whether the loader has enough info to load the next segment.\n   *\n   * @return {boolean}\n   *         Whether or not the loader has enough info to load the next segment\n   */\n  ;\n\n  _proto.hasEnoughInfoToLoad_ = function hasEnoughInfoToLoad_() {\n    // Since primary timing goes by video, only the audio loader potentially needs to wait\n    // to load.\n    if (this.loaderType_ !== 'audio') {\n      return true;\n    }\n\n    var segmentInfo = this.pendingSegment_; // A fill buffer must have already run to establish a pending segment before there's\n    // enough info to load.\n\n    if (!segmentInfo) {\n      return false;\n    } // The first segment can and should be loaded immediately so that source buffers are\n    // created together (before appending). Source buffer creation uses the presence of\n    // audio and video data to determine whether to create audio/video source buffers, and\n    // uses processed (transmuxed or parsed) media to determine the types required.\n\n\n    if (!this.currentMediaInfo_) {\n      return true;\n    }\n\n    if ( // Technically, instead of waiting to load a segment on timeline changes, a segment\n    // can be requested and downloaded and only wait before it is transmuxed or parsed.\n    // But in practice, there are a few reasons why it is better to wait until a loader\n    // is ready to append that segment before requesting and downloading:\n    //\n    // 1. Because audio and main loaders cross discontinuities together, if this loader\n    //    is waiting for the other to catch up, then instead of requesting another\n    //    segment and using up more bandwidth, by not yet loading, more bandwidth is\n    //    allotted to the loader currently behind.\n    // 2. media-segment-request doesn't have to have logic to consider whether a segment\n    // is ready to be processed or not, isolating the queueing behavior to the loader.\n    // 3. The audio loader bases some of its segment properties on timing information\n    //    provided by the main loader, meaning that, if the logic for waiting on\n    //    processing was in media-segment-request, then it would also need to know how\n    //    to re-generate the segment information after the main loader caught up.\n    shouldWaitForTimelineChange({\n      timelineChangeController: this.timelineChangeController_,\n      currentTimeline: this.currentTimeline_,\n      segmentTimeline: segmentInfo.timeline,\n      loaderType: this.loaderType_,\n      audioDisabled: this.audioDisabled_\n    })) {\n      return false;\n    }\n\n    return true;\n  };\n\n  _proto.hasEnoughInfoToAppend_ = function hasEnoughInfoToAppend_() {\n    if (!this.sourceUpdater_.ready()) {\n      // waiting on one of the segment loaders to get enough data to create source buffers\n      return false;\n    }\n\n    var segmentInfo = this.pendingSegment_; // no segment to append any data for or\n    // we do not have information on this specific\n    // segment yet\n\n    if (!segmentInfo || !segmentInfo.trackInfo) {\n      return false;\n    }\n\n    if (!this.handlePartialData_) {\n      var _this$currentMediaInf = this.currentMediaInfo_,\n          hasAudio = _this$currentMediaInf.hasAudio,\n          hasVideo = _this$currentMediaInf.hasVideo,\n          isMuxed = _this$currentMediaInf.isMuxed;\n\n      if (hasVideo && !segmentInfo.videoTimingInfo) {\n        return false;\n      } // muxed content only relies on video timing information for now.\n\n\n      if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) {\n        return false;\n      }\n    }\n\n    if (shouldWaitForTimelineChange({\n      timelineChangeController: this.timelineChangeController_,\n      currentTimeline: this.currentTimeline_,\n      segmentTimeline: segmentInfo.timeline,\n      loaderType: this.loaderType_,\n      audioDisabled: this.audioDisabled_\n    })) {\n      return false;\n    }\n\n    return true;\n  };\n\n  _proto.handleData_ = function handleData_(simpleSegment, result) {\n    if (this.checkForAbort_(simpleSegment.requestId) || this.abortRequestEarly_(simpleSegment.stats)) {\n      return;\n    } // If there's anything in the call queue, then this data came later and should be\n    // executed after the calls currently queued.\n\n\n    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {\n      this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));\n      return;\n    }\n\n    var segmentInfo = this.pendingSegment_; // update the time mapping so we can translate from display time to media time\n\n    this.setTimeMapping_(segmentInfo.timeline); // for tracking overall stats\n\n    this.updateMediaSecondsLoaded_(segmentInfo.segment); // Note that the state isn't changed from loading to appending. This is because abort\n    // logic may change behavior depending on the state, and changing state too early may\n    // inflate our estimates of bandwidth. In the future this should be re-examined to\n    // note more granular states.\n    // don't process and append data if the mediaSource is closed\n\n    if (this.mediaSource_.readyState === 'closed') {\n      return;\n    } // if this request included an initialization segment, save that data\n    // to the initSegment cache\n\n\n    if (simpleSegment.map) {\n      simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true); // move over init segment properties to media request\n\n      segmentInfo.segment.map = simpleSegment.map;\n    } // if this request included a segment key, save that data in the cache\n\n\n    if (simpleSegment.key) {\n      this.segmentKey(simpleSegment.key, true);\n    }\n\n    segmentInfo.isFmp4 = simpleSegment.isFmp4;\n    segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n\n    if (segmentInfo.isFmp4) {\n      this.trigger('fmp4');\n      segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;\n    } else {\n      var useVideoTimingInfo = this.loaderType_ === 'main' && this.currentMediaInfo_.hasVideo;\n      var firstVideoFrameTimeForData;\n\n      if (useVideoTimingInfo) {\n        firstVideoFrameTimeForData = this.handlePartialData_ ? result.videoFramePtsTime : segmentInfo.videoTimingInfo.start;\n      } // Segment loader knows more about segment timing than the transmuxer (in certain\n      // aspects), so make any changes required for a more accurate start time.\n      // Don't set the end time yet, as the segment may not be finished processing.\n\n\n      segmentInfo.timingInfo.start = this.trueSegmentStart_({\n        currentStart: segmentInfo.timingInfo.start,\n        playlist: segmentInfo.playlist,\n        mediaIndex: segmentInfo.mediaIndex,\n        currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),\n        useVideoTimingInfo: useVideoTimingInfo,\n        firstVideoFrameTimeForData: firstVideoFrameTimeForData,\n        videoTimingInfo: segmentInfo.videoTimingInfo,\n        audioTimingInfo: segmentInfo.audioTimingInfo\n      });\n    } // Init segments for audio and video only need to be appended in certain cases. Now\n    // that data is about to be appended, we can check the final cases to determine\n    // whether we should append an init segment.\n\n\n    this.updateAppendInitSegmentStatus(segmentInfo, result.type); // Timestamp offset should be updated once we get new data and have its timing info,\n    // as we use the start of the segment to offset the best guess (playlist provided)\n    // timestamp offset.\n\n    this.updateSourceBufferTimestampOffset_(segmentInfo); // Save some state so that in the future anything waiting on first append (and/or\n    // timestamp offset(s)) can process immediately. While the extra state isn't optimal,\n    // we need some notion of whether the timestamp offset or other relevant information\n    // has had a chance to be set.\n\n    segmentInfo.hasAppendedData_ = true; // Now that the timestamp offset should be set, we can append any waiting ID3 tags.\n\n    this.processMetadataQueue_();\n    this.appendData_(segmentInfo, result);\n  };\n\n  _proto.updateAppendInitSegmentStatus = function updateAppendInitSegmentStatus(segmentInfo, type) {\n    // alt audio doesn't manage timestamp offset\n    if (this.loaderType_ === 'main' && typeof segmentInfo.timestampOffset === 'number' && // in the case that we're handling partial data, we don't want to append an init\n    // segment for each chunk\n    !segmentInfo.changedTimestampOffset) {\n      // if the timestamp offset changed, the timeline may have changed, so we have to re-\n      // append init segments\n      this.appendInitSegment_ = {\n        audio: true,\n        video: true\n      };\n    }\n\n    if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {\n      // make sure we append init segment on playlist changes, in case the media config\n      // changed\n      this.appendInitSegment_[type] = true;\n    }\n  };\n\n  _proto.getInitSegmentAndUpdateState_ = function getInitSegmentAndUpdateState_(_ref3) {\n    var type = _ref3.type,\n        initSegment = _ref3.initSegment,\n        map = _ref3.map,\n        playlist = _ref3.playlist; // \"The EXT-X-MAP tag specifies how to obtain the Media Initialization Section\n    // (Section 3) required to parse the applicable Media Segments.  It applies to every\n    // Media Segment that appears after it in the Playlist until the next EXT-X-MAP tag\n    // or until the end of the playlist.\"\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.5\n\n    if (map) {\n      var id = initSegmentId(map);\n\n      if (this.activeInitSegmentId_ === id) {\n        // don't need to re-append the init segment if the ID matches\n        return null;\n      } // a map-specified init segment takes priority over any transmuxed (or otherwise\n      // obtained) init segment\n      //\n      // this also caches the init segment for later use\n\n\n      initSegment = this.initSegmentForMap(map, true).bytes;\n      this.activeInitSegmentId_ = id;\n    } // We used to always prepend init segments for video, however, that shouldn't be\n    // necessary. Instead, we should only append on changes, similar to what we've always\n    // done for audio. This is more important (though may not be that important) for\n    // frame-by-frame appending for LHLS, simply because of the increased quantity of\n    // appends.\n\n\n    if (initSegment && this.appendInitSegment_[type]) {\n      // Make sure we track the playlist that we last used for the init segment, so that\n      // we can re-append the init segment in the event that we get data from a new\n      // playlist. Discontinuities and track changes are handled in other sections.\n      this.playlistOfLastInitSegment_[type] = playlist; // we should only be appending the next init segment if we detect a change, or if\n      // the segment has a map\n\n      this.appendInitSegment_[type] = map ? true : false; // we need to clear out the fmp4 active init segment id, since\n      // we are appending the muxer init segment\n\n      this.activeInitSegmentId_ = null;\n      return initSegment;\n    }\n\n    return null;\n  };\n\n  _proto.appendToSourceBuffer_ = function appendToSourceBuffer_(_ref4) {\n    var _this4 = this;\n\n    var segmentInfo = _ref4.segmentInfo,\n        type = _ref4.type,\n        initSegment = _ref4.initSegment,\n        data = _ref4.data;\n    var segments = [data];\n    var byteLength = data.byteLength;\n\n    if (initSegment) {\n      // if the media initialization segment is changing, append it before the content\n      // segment\n      segments.unshift(initSegment);\n      byteLength += initSegment.byteLength;\n    } // Technically we should be OK appending the init segment separately, however, we\n    // haven't yet tested that, and prepending is how we have always done things.\n\n\n    var bytes = concatSegments({\n      bytes: byteLength,\n      segments: segments\n    });\n    this.sourceUpdater_.appendBuffer({\n      segmentInfo: segmentInfo,\n      type: type,\n      bytes: bytes\n    }, function (error) {\n      if (error) {\n        _this4.error(type + \" append of \" + bytes.length + \"b failed for segment #\" + segmentInfo.mediaIndex + \" in playlist \" + segmentInfo.playlist.id); // If an append errors, we can't recover.\n        // (see https://w3c.github.io/media-source/#sourcebuffer-append-error).\n        // Trigger a special error so that it can be handled separately from normal,\n        // recoverable errors.\n\n\n        _this4.trigger('appenderror');\n      }\n    });\n  };\n\n  _proto.handleVideoSegmentTimingInfo_ = function handleVideoSegmentTimingInfo_(requestId, videoSegmentTimingInfo) {\n    if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {\n      return;\n    }\n\n    var segment = this.pendingSegment_.segment;\n\n    if (!segment.videoTimingInfo) {\n      segment.videoTimingInfo = {};\n    }\n\n    segment.videoTimingInfo.transmuxerPrependedSeconds = videoSegmentTimingInfo.prependedContentDuration || 0;\n    segment.videoTimingInfo.transmuxedPresentationStart = videoSegmentTimingInfo.start.presentation;\n    segment.videoTimingInfo.transmuxedPresentationEnd = videoSegmentTimingInfo.end.presentation; // mainly used as a reference for debugging\n\n    segment.videoTimingInfo.baseMediaDecodeTime = videoSegmentTimingInfo.baseMediaDecodeTime;\n  };\n\n  _proto.appendData_ = function appendData_(segmentInfo, result) {\n    var type = result.type,\n        data = result.data;\n\n    if (!data || !data.byteLength) {\n      return;\n    }\n\n    if (type === 'audio' && this.audioDisabled_) {\n      return;\n    }\n\n    var initSegment = this.getInitSegmentAndUpdateState_({\n      type: type,\n      initSegment: result.initSegment,\n      playlist: segmentInfo.playlist,\n      map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null\n    });\n    this.appendToSourceBuffer_({\n      segmentInfo: segmentInfo,\n      type: type,\n      initSegment: initSegment,\n      data: data\n    });\n  }\n  /**\n   * load a specific segment from a request into the buffer\n   *\n   * @private\n   */\n  ;\n\n  _proto.loadSegment_ = function loadSegment_(segmentInfo) {\n    var _this5 = this;\n\n    this.state = 'WAITING';\n    this.pendingSegment_ = segmentInfo;\n    this.trimBackBuffer_(segmentInfo);\n\n    if (typeof segmentInfo.timestampOffset === 'number') {\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({\n          action: 'clearAllMp4Captions'\n        });\n      }\n    }\n\n    if (!this.hasEnoughInfoToLoad_()) {\n      this.loadQueue_.push(function () {\n        var buffered = _this5.buffered_();\n\n        if (typeof segmentInfo.timestampOffset === 'number') {\n          // The timestamp offset needs to be regenerated, as the buffer most likely\n          // changed since the function was added to the queue. This is expected, as the\n          // load is usually pending the main loader appending new segments.\n          //\n          // Note also that the overrideCheck property is set to true. This is because\n          // isPendingTimestampOffset is set back to false after the first set of the\n          // timestamp offset (before it was added to the queue). But the presence of\n          // timestamp offset as a property of segmentInfo serves as enough evidence that\n          // it should be regenerated.\n          segmentInfo.timestampOffset = timestampOffsetForSegment({\n            segmentTimeline: segmentInfo.timeline,\n            currentTimeline: _this5.currentTimeline_,\n            startOfSegment: segmentInfo.startOfSegment,\n            buffered: buffered,\n            overrideCheck: true\n          });\n        }\n\n        delete segmentInfo.audioAppendStart;\n\n        var audioBuffered = _this5.sourceUpdater_.audioBuffered();\n\n        if (audioBuffered.length) {\n          // Because the audio timestamp offset may have been changed by the main loader,\n          // the audioAppendStart should be regenerated.\n          //\n          // Since the transmuxer is using the actual timing values, but the buffer is\n          // adjusted by the timestamp offset, the value must be adjusted.\n          segmentInfo.audioAppendStart = audioBuffered.end(audioBuffered.length - 1) - _this5.sourceUpdater_.audioTimestampOffset();\n        }\n\n        _this5.updateTransmuxerAndRequestSegment_(segmentInfo);\n      });\n      return;\n    }\n\n    this.updateTransmuxerAndRequestSegment_(segmentInfo);\n  };\n\n  _proto.updateTransmuxerAndRequestSegment_ = function updateTransmuxerAndRequestSegment_(segmentInfo) {\n    // We'll update the source buffer's timestamp offset once we have transmuxed data, but\n    // the transmuxer still needs to be updated before then.\n    //\n    // Even though keepOriginalTimestamps is set to true for the transmuxer, timestamp\n    // offset must be passed to the transmuxer for stream correcting adjustments.\n    if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {\n      this.gopBuffer_.length = 0; // gopsToAlignWith was set before the GOP buffer was cleared\n\n      segmentInfo.gopsToAlignWith = [];\n      this.timeMapping_ = 0; // reset values in the transmuxer since a discontinuity should start fresh\n\n      this.transmuxer_.postMessage({\n        action: 'reset'\n      });\n      this.transmuxer_.postMessage({\n        action: 'setTimestampOffset',\n        timestampOffset: segmentInfo.timestampOffset\n      });\n    }\n\n    var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);\n    segmentInfo.abortRequests = mediaSegmentRequest({\n      xhr: this.vhs_.xhr,\n      xhrOptions: this.xhrOptions_,\n      decryptionWorker: this.decrypter_,\n      segment: simpleSegment,\n      handlePartialData: this.handlePartialData_,\n      abortFn: this.handleAbort_.bind(this),\n      progressFn: this.handleProgress_.bind(this),\n      trackInfoFn: this.handleTrackInfo_.bind(this),\n      timingInfoFn: this.handleTimingInfo_.bind(this),\n      videoSegmentTimingInfoFn: this.handleVideoSegmentTimingInfo_.bind(this, segmentInfo.requestId),\n      captionsFn: this.handleCaptions_.bind(this),\n      id3Fn: this.handleId3_.bind(this),\n      dataFn: this.handleData_.bind(this),\n      doneFn: this.segmentRequestFinished_.bind(this)\n    });\n  }\n  /**\n   * trim the back buffer so that we don't have too much data\n   * in the source buffer\n   *\n   * @private\n   *\n   * @param {Object} segmentInfo - the current segment\n   */\n  ;\n\n  _proto.trimBackBuffer_ = function trimBackBuffer_(segmentInfo) {\n    var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); // Chrome has a hard limit of 150MB of\n    // buffer and a very conservative \"garbage collector\"\n    // We manually clear out the old buffer to ensure\n    // we don't trigger the QuotaExceeded error\n    // on the source buffer during subsequent appends\n\n    if (removeToTime > 0) {\n      this.remove(0, removeToTime);\n    }\n  }\n  /**\n   * created a simplified copy of the segment object with just the\n   * information necessary to perform the XHR and decryption\n   *\n   * @private\n   *\n   * @param {Object} segmentInfo - the current segment\n   * @return {Object} a simplified segment object copy\n   */\n  ;\n\n  _proto.createSimplifiedSegmentObj_ = function createSimplifiedSegmentObj_(segmentInfo) {\n    var segment = segmentInfo.segment;\n    var simpleSegment = {\n      resolvedUri: segment.resolvedUri,\n      byterange: segment.byterange,\n      requestId: segmentInfo.requestId,\n      transmuxer: segmentInfo.transmuxer,\n      audioAppendStart: segmentInfo.audioAppendStart,\n      gopsToAlignWith: segmentInfo.gopsToAlignWith\n    };\n    var previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex];\n\n    if (previousSegment && previousSegment.end && previousSegment.timeline === segment.timeline) {\n      simpleSegment.baseStartTime = previousSegment.end + segmentInfo.timestampOffset;\n    }\n\n    if (segment.key) {\n      // if the media sequence is greater than 2^32, the IV will be incorrect\n      // assuming 10s segments, that would be about 1300 years\n      var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n      simpleSegment.key = this.segmentKey(segment.key);\n      simpleSegment.key.iv = iv;\n    }\n\n    if (segment.map) {\n      simpleSegment.map = this.initSegmentForMap(segment.map);\n    }\n\n    return simpleSegment;\n  };\n\n  _proto.saveTransferStats_ = function saveTransferStats_(stats) {\n    // every request counts as a media request even if it has been aborted\n    // or canceled due to a timeout\n    this.mediaRequests += 1;\n\n    if (stats) {\n      this.mediaBytesTransferred += stats.bytesReceived;\n      this.mediaTransferDuration += stats.roundTripTime;\n    }\n  };\n\n  _proto.saveBandwidthRelatedStats_ = function saveBandwidthRelatedStats_(stats) {\n    this.bandwidth = stats.bandwidth;\n    this.roundTrip = stats.roundTripTime; // byteLength will be used for throughput, and should be based on bytes receieved,\n    // which we only know at the end of the request and should reflect total bytes\n    // downloaded rather than just bytes processed from components of the segment\n\n    this.pendingSegment_.byteLength = stats.bytesReceived;\n  };\n\n  _proto.handleTimeout_ = function handleTimeout_() {\n    // although the VTT segment loader bandwidth isn't really used, it's good to\n    // maintain functinality between segment loaders\n    this.mediaRequestsTimedout += 1;\n    this.bandwidth = 1;\n    this.roundTrip = NaN;\n    this.trigger('bandwidthupdate');\n  }\n  /**\n   * Handle the callback from the segmentRequest function and set the\n   * associated SegmentLoader state and errors if necessary\n   *\n   * @private\n   */\n  ;\n\n  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {\n    // TODO handle special cases, e.g., muxed audio/video but only audio in the segment\n    // check the call queue directly since this function doesn't need to deal with any\n    // data, and can continue even if the source buffers are not set up and we didn't get\n    // any data from the segment\n    if (this.callQueue_.length) {\n      this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));\n      return;\n    }\n\n    this.saveTransferStats_(simpleSegment.stats); // The request was aborted and the SegmentLoader has already been reset\n\n    if (!this.pendingSegment_) {\n      return;\n    } // the request was aborted and the SegmentLoader has already started\n    // another request. this can happen when the timeout for an aborted\n    // request triggers due to a limitation in the XHR library\n    // do not count this as any sort of request or we risk double-counting\n\n\n    if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n      return;\n    } // an error occurred from the active pendingSegment_ so reset everything\n\n\n    if (error) {\n      this.pendingSegment_ = null;\n      this.state = 'READY'; // aborts are not a true error condition and nothing corrective needs to be done\n\n      if (error.code === REQUEST_ERRORS.ABORTED) {\n        return;\n      }\n\n      this.pause(); // the error is really just that at least one of the requests timed-out\n      // set the bandwidth to a very low value and trigger an ABR switch to\n      // take emergency action\n\n      if (error.code === REQUEST_ERRORS.TIMEOUT) {\n        this.handleTimeout_();\n        return;\n      } // if control-flow has arrived here, then the error is real\n      // emit an error event to blacklist the current playlist\n\n\n      this.mediaRequestsErrored += 1;\n      this.error(error);\n      this.trigger('error');\n      return;\n    } // the response was a success so set any bandwidth stats the request\n    // generated for ABR purposes\n\n\n    this.saveBandwidthRelatedStats_(simpleSegment.stats);\n    var segmentInfo = this.pendingSegment_;\n    segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n\n    if (result.gopInfo) {\n      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);\n    } // Although we may have already started appending on progress, we shouldn't switch the\n    // state away from loading until we are officially done loading the segment data.\n\n\n    this.state = 'APPENDING';\n    var isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist);\n    var isWalkingForward = this.mediaIndex !== null;\n    var isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && // TODO verify this behavior\n    // currentTimeline starts at -1, but we shouldn't end the timeline switching to 0,\n    // the first timeline\n    segmentInfo.timeline > 0;\n\n    if (!segmentInfo.isFmp4 && (isEndOfStream || isWalkingForward && isDiscontinuity)) {\n      segmentTransmuxer.endTimeline(this.transmuxer_);\n    } // used for testing\n\n\n    this.trigger('appending');\n    this.waitForAppendsToComplete_(segmentInfo);\n  };\n\n  _proto.setTimeMapping_ = function setTimeMapping_(timeline) {\n    var timelineMapping = this.syncController_.mappingForTimeline(timeline);\n\n    if (timelineMapping !== null) {\n      this.timeMapping_ = timelineMapping;\n    }\n  };\n\n  _proto.updateMediaSecondsLoaded_ = function updateMediaSecondsLoaded_(segment) {\n    if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n      this.mediaSecondsLoaded += segment.end - segment.start;\n    } else {\n      this.mediaSecondsLoaded += segment.duration;\n    }\n  };\n\n  _proto.shouldUpdateTransmuxerTimestampOffset_ = function shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {\n    if (timestampOffset === null) {\n      return false;\n    } // note that we're potentially using the same timestamp offset for both video and\n    // audio\n\n\n    if (this.loaderType_ === 'main' && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n      return true;\n    }\n\n    if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.trueSegmentStart_ = function trueSegmentStart_(_ref5) {\n    var currentStart = _ref5.currentStart,\n        playlist = _ref5.playlist,\n        mediaIndex = _ref5.mediaIndex,\n        firstVideoFrameTimeForData = _ref5.firstVideoFrameTimeForData,\n        currentVideoTimestampOffset = _ref5.currentVideoTimestampOffset,\n        useVideoTimingInfo = _ref5.useVideoTimingInfo,\n        videoTimingInfo = _ref5.videoTimingInfo,\n        audioTimingInfo = _ref5.audioTimingInfo;\n\n    if (typeof currentStart !== 'undefined') {\n      // if start was set once, keep using it\n      return currentStart;\n    }\n\n    if (!useVideoTimingInfo) {\n      return audioTimingInfo.start;\n    }\n\n    var previousSegment = playlist.segments[mediaIndex - 1]; // The start of a segment should be the start of the first full frame contained\n    // within that segment. Since the transmuxer maintains a cache of incomplete data\n    // from and/or the last frame seen, the start time may reflect a frame that starts\n    // in the previous segment. Check for that case and ensure the start time is\n    // accurate for the segment.\n\n    if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === 'undefined' || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {\n      return firstVideoFrameTimeForData;\n    }\n\n    return videoTimingInfo.start;\n  };\n\n  _proto.waitForAppendsToComplete_ = function waitForAppendsToComplete_(segmentInfo) {\n    if (!this.currentMediaInfo_) {\n      this.error({\n        message: 'No starting media returned, likely due to an unsupported media format.',\n        blacklistDuration: Infinity\n      });\n      this.trigger('error');\n      return;\n    } // Although transmuxing is done, appends may not yet be finished. Throw a marker\n    // on each queue this loader is responsible for to ensure that the appends are\n    // complete.\n\n\n    var _this$currentMediaInf2 = this.currentMediaInfo_,\n        hasAudio = _this$currentMediaInf2.hasAudio,\n        hasVideo = _this$currentMediaInf2.hasVideo,\n        isMuxed = _this$currentMediaInf2.isMuxed;\n    var waitForVideo = this.loaderType_ === 'main' && hasVideo; // TODO: does this break partial support for muxed content?\n\n    var waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;\n    segmentInfo.waitingOnAppends = 0; // segments with no data\n\n    if (!segmentInfo.hasAppendedData_) {\n      if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === 'number') {\n        // When there's no audio or video data in the segment, there's no audio or video\n        // timing information.\n        //\n        // If there's no audio or video timing information, then the timestamp offset\n        // can't be adjusted to the appropriate value for the transmuxer and source\n        // buffers.\n        //\n        // Therefore, the next segment should be used to set the timestamp offset.\n        this.isPendingTimestampOffset_ = true;\n      } // override settings for metadata only segments\n\n\n      segmentInfo.timingInfo = {\n        start: 0\n      };\n      segmentInfo.waitingOnAppends++;\n\n      if (!this.isPendingTimestampOffset_) {\n        // update the timestampoffset\n        this.updateSourceBufferTimestampOffset_(segmentInfo); // make sure the metadata queue is processed even though we have\n        // no video/audio data.\n\n        this.processMetadataQueue_();\n      } // append is \"done\" instantly with no data.\n\n\n      this.checkAppendsDone_(segmentInfo);\n      return;\n    } // Since source updater could call back synchronously, do the increments first.\n\n\n    if (waitForVideo) {\n      segmentInfo.waitingOnAppends++;\n    }\n\n    if (waitForAudio) {\n      segmentInfo.waitingOnAppends++;\n    }\n\n    if (waitForVideo) {\n      this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n    }\n\n    if (waitForAudio) {\n      this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n    }\n  };\n\n  _proto.checkAppendsDone_ = function checkAppendsDone_(segmentInfo) {\n    if (this.checkForAbort_(segmentInfo.requestId)) {\n      return;\n    }\n\n    segmentInfo.waitingOnAppends--;\n\n    if (segmentInfo.waitingOnAppends === 0) {\n      this.handleAppendsDone_();\n    }\n  };\n\n  _proto.checkForIllegalMediaSwitch = function checkForIllegalMediaSwitch(trackInfo) {\n    var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.currentMediaInfo_, trackInfo);\n\n    if (illegalMediaSwitchError) {\n      this.error({\n        message: illegalMediaSwitchError,\n        blacklistDuration: Infinity\n      });\n      this.trigger('error');\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.updateSourceBufferTimestampOffset_ = function updateSourceBufferTimestampOffset_(segmentInfo) {\n    if (segmentInfo.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has\n    // priority, timing-wise, so we must wait\n    typeof segmentInfo.timingInfo.start !== 'number' || // already updated the timestamp offset for this segment\n    segmentInfo.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset\n    this.loaderType_ !== 'main') {\n      return;\n    }\n\n    var didChange = false; // Primary timing goes by video, and audio is trimmed in the transmuxer, meaning that\n    // the timing info here comes from video. In the event that the audio is longer than\n    // the video, this will trim the start of the audio.\n    // This also trims any offset from 0 at the beginning of the media\n\n    segmentInfo.timestampOffset -= segmentInfo.timingInfo.start; // In the event that there are partial segment downloads, each will try to update the\n    // timestamp offset. Retaining this bit of state prevents us from updating in the\n    // future (within the same segment), however, there may be a better way to handle it.\n\n    segmentInfo.changedTimestampOffset = true;\n\n    if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n      this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);\n      didChange = true;\n    }\n\n    if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n      this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);\n      didChange = true;\n    }\n\n    if (didChange) {\n      this.trigger('timestampoffset');\n    }\n  };\n\n  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_(segmentInfo) {\n    segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n    var useVideoTimingInfo = this.loaderType_ === 'main' && this.currentMediaInfo_.hasVideo;\n    var prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;\n\n    if (!prioritizedTimingInfo) {\n      return;\n    }\n\n    segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === 'number' ? // End time may not exist in a case where we aren't parsing the full segment (one\n    // current example is the case of fmp4), so use the rough duration to calculate an\n    // end time.\n    prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;\n  }\n  /**\n   * callback to run when appendBuffer is finished. detects if we are\n   * in a good state to do things with the data we got, or if we need\n   * to wait for more\n   *\n   * @private\n   */\n  ;\n\n  _proto.handleAppendsDone_ = function handleAppendsDone_() {\n    // appendsdone can cause an abort\n    if (this.pendingSegment_) {\n      this.trigger('appendsdone');\n    }\n\n    if (!this.pendingSegment_) {\n      this.state = 'READY'; // TODO should this move into this.checkForAbort to speed up requests post abort in\n      // all appending cases?\n\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n\n      return;\n    }\n\n    var segmentInfo = this.pendingSegment_; // Now that the end of the segment has been reached, we can set the end time. It's\n    // best to wait until all appends are done so we're sure that the primary media is\n    // finished (and we have its end time).\n\n    this.updateTimingInfoEnd_(segmentInfo);\n\n    if (this.shouldSaveSegmentTimingInfo_) {\n      // Timeline mappings should only be saved for the main loader. This is for multiple\n      // reasons:\n      //\n      // 1) Only one mapping is saved per timeline, meaning that if both the audio loader\n      //    and the main loader try to save the timeline mapping, whichever comes later\n      //    will overwrite the first. In theory this is OK, as the mappings should be the\n      //    same, however, it breaks for (2)\n      // 2) In the event of a live stream, the initial live point will make for a somewhat\n      //    arbitrary mapping. If audio and video streams are not perfectly in-sync, then\n      //    the mapping will be off for one of the streams, dependent on which one was\n      //    first saved (see (1)).\n      // 3) Primary timing goes by video in VHS, so the mapping should be video.\n      //\n      // Since the audio loader will wait for the main loader to load the first segment,\n      // the main loader will save the first timeline mapping, and ensure that there won't\n      // be a case where audio loads two segments without saving a mapping (thus leading\n      // to missing segment timing info).\n      this.syncController_.saveSegmentTimingInfo({\n        segmentInfo: segmentInfo,\n        shouldSaveTimelineMapping: this.loaderType_ === 'main'\n      });\n    }\n\n    this.logger_(segmentInfoString(segmentInfo));\n    this.recordThroughput_(segmentInfo);\n    this.pendingSegment_ = null;\n    this.state = 'READY'; // TODO minor, but for partial segment downloads, this can be done earlier to save\n    // on bandwidth and download time\n\n    if (segmentInfo.isSyncRequest) {\n      this.trigger('syncinfoupdate');\n      return;\n    }\n\n    this.addSegmentMetadataCue_(segmentInfo);\n    this.fetchAtBuffer_ = true;\n\n    if (this.currentTimeline_ !== segmentInfo.timeline) {\n      this.timelineChangeController_.lastTimelineChange({\n        type: this.loaderType_,\n        from: this.currentTimeline_,\n        to: segmentInfo.timeline\n      }); // If audio is not disabled, the main segment loader is responsible for updating\n      // the audio timeline as well. If the content is video only, this won't have any\n      // impact.\n\n      if (this.loaderType_ === 'main' && !this.audioDisabled_) {\n        this.timelineChangeController_.lastTimelineChange({\n          type: 'audio',\n          from: this.currentTimeline_,\n          to: segmentInfo.timeline\n        });\n      }\n    }\n\n    this.currentTimeline_ = segmentInfo.timeline; // We must update the syncinfo to recalculate the seekable range before\n    // the following conditional otherwise it may consider this a bad \"guess\"\n    // and attempt to resync when the post-update seekable window and live\n    // point would mean that this was the perfect segment to fetch\n\n    this.trigger('syncinfoupdate');\n    var segment = segmentInfo.segment; // If we previously appended a segment that ends more than 3 targetDurations before\n    // the currentTime_ that means that our conservative guess was too conservative.\n    // In that case, reset the loader state so that we try to use any information gained\n    // from the previous request to create a new, more accurate, sync-point.\n\n    if (segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3) {\n      this.resetEverything();\n      return;\n    }\n\n    var isWalkingForward = this.mediaIndex !== null; // Don't do a rendition switch unless we have enough time to get a sync segment\n    // and conservatively guess\n\n    if (isWalkingForward) {\n      this.trigger('bandwidthupdate');\n    }\n\n    this.trigger('progress');\n    this.mediaIndex = segmentInfo.mediaIndex; // any time an update finishes and the last segment is in the\n    // buffer, end the stream. this ensures the \"ended\" event will\n    // fire if playback reaches that point.\n\n    if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist)) {\n      this.endOfStream();\n    } // used for testing\n\n\n    this.trigger('appended');\n\n    if (!this.paused()) {\n      this.monitorBuffer_();\n    }\n  }\n  /**\n   * Records the current throughput of the decrypt, transmux, and append\n   * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n   * moving average of the throughput. `throughput.count` is the number of\n   * data points in the average.\n   *\n   * @private\n   * @param {Object} segmentInfo the object returned by loadSegment\n   */\n  ;\n\n  _proto.recordThroughput_ = function recordThroughput_(segmentInfo) {\n    var rate = this.throughput.rate; // Add one to the time to ensure that we don't accidentally attempt to divide\n    // by zero in the case where the throughput is ridiculously high\n\n    var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1; // Multiply by 8000 to convert from bytes/millisecond to bits/second\n\n    var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000); // This is just a cumulative moving average calculation:\n    //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n\n    this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n  }\n  /**\n   * Adds a cue to the segment-metadata track with some metadata information about the\n   * segment\n   *\n   * @private\n   * @param {Object} segmentInfo\n   *        the object returned by loadSegment\n   * @method addSegmentMetadataCue_\n   */\n  ;\n\n  _proto.addSegmentMetadataCue_ = function addSegmentMetadataCue_(segmentInfo) {\n    if (!this.segmentMetadataTrack_) {\n      return;\n    }\n\n    var segment = segmentInfo.segment;\n    var start = segment.start;\n    var end = segment.end; // Do not try adding the cue if the start and end times are invalid.\n\n    if (!finite(start) || !finite(end)) {\n      return;\n    }\n\n    removeCuesFromTrack(start, end, this.segmentMetadataTrack_);\n    var Cue = window$1.WebKitDataCue || window$1.VTTCue;\n    var value = {\n      custom: segment.custom,\n      dateTimeObject: segment.dateTimeObject,\n      dateTimeString: segment.dateTimeString,\n      bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\n      resolution: segmentInfo.playlist.attributes.RESOLUTION,\n      codecs: segmentInfo.playlist.attributes.CODECS,\n      byteLength: segmentInfo.byteLength,\n      uri: segmentInfo.uri,\n      timeline: segmentInfo.timeline,\n      playlist: segmentInfo.playlist.id,\n      start: start,\n      end: end\n    };\n    var data = JSON.stringify(value);\n    var cue = new Cue(start, end, data); // Attach the metadata to the value property of the cue to keep consistency between\n    // the differences of WebKitDataCue in safari and VTTCue in other browsers\n\n    cue.value = value;\n    this.segmentMetadataTrack_.addCue(cue);\n  };\n\n  return SegmentLoader;\n}(videojs$1.EventTarget);\n\nfunction noop() {}\n\nvar toTitleCase$1 = function toTitleCase(string) {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replace(/./, function (w) {\n    return w.toUpperCase();\n  });\n};\n\nvar bufferTypes = ['video', 'audio'];\n\nvar _updating = function updating(type, sourceUpdater) {\n  var sourceBuffer = sourceUpdater[type + \"Buffer\"];\n  return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];\n};\n\nvar nextQueueIndexOfType = function nextQueueIndexOfType(type, queue) {\n  for (var i = 0; i < queue.length; i++) {\n    var queueEntry = queue[i];\n\n    if (queueEntry.type === 'mediaSource') {\n      // If the next entry is a media source entry (uses multiple source buffers), block\n      // processing to allow it to go through first.\n      return null;\n    }\n\n    if (queueEntry.type === type) {\n      return i;\n    }\n  }\n\n  return null;\n};\n\nvar shiftQueue = function shiftQueue(type, sourceUpdater) {\n  if (sourceUpdater.queue.length === 0) {\n    return;\n  }\n\n  var queueIndex = 0;\n  var queueEntry = sourceUpdater.queue[queueIndex];\n\n  if (queueEntry.type === 'mediaSource') {\n    if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== 'closed') {\n      sourceUpdater.queue.shift();\n      queueEntry.action(sourceUpdater);\n\n      if (queueEntry.doneFn) {\n        queueEntry.doneFn();\n      } // Only specific source buffer actions must wait for async updateend events. Media\n      // Source actions process synchronously. Therefore, both audio and video source\n      // buffers are now clear to process the next queue entries.\n\n\n      shiftQueue('audio', sourceUpdater);\n      shiftQueue('video', sourceUpdater);\n    } // Media Source actions require both source buffers, so if the media source action\n    // couldn't process yet (because one or both source buffers are busy), block other\n    // queue actions until both are available and the media source action can process.\n\n\n    return;\n  }\n\n  if (type === 'mediaSource') {\n    // If the queue was shifted by a media source action (this happens when pushing a\n    // media source action onto the queue), then it wasn't from an updateend event from an\n    // audio or video source buffer, so there's no change from previous state, and no\n    // processing should be done.\n    return;\n  } // Media source queue entries don't need to consider whether the source updater is\n  // started (i.e., source buffers are created) as they don't need the source buffers, but\n  // source buffer queue entries do.\n\n\n  if (!sourceUpdater.started_ || sourceUpdater.mediaSource.readyState === 'closed' || _updating(type, sourceUpdater)) {\n    return;\n  }\n\n  if (queueEntry.type !== type) {\n    queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);\n\n    if (queueIndex === null) {\n      // Either there's no queue entry that uses this source buffer type in the queue, or\n      // there's a media source queue entry before the next entry of this type, in which\n      // case wait for that action to process first.\n      return;\n    }\n\n    queueEntry = sourceUpdater.queue[queueIndex];\n  }\n\n  sourceUpdater.queue.splice(queueIndex, 1);\n  queueEntry.action(type, sourceUpdater);\n\n  if (!queueEntry.doneFn) {\n    // synchronous operation, process next entry\n    shiftQueue(type, sourceUpdater);\n    return;\n  } // asynchronous operation, so keep a record that this source buffer type is in use\n\n\n  sourceUpdater.queuePending[type] = queueEntry;\n};\n\nvar cleanupBuffer = function cleanupBuffer(type, sourceUpdater) {\n  var buffer = sourceUpdater[type + \"Buffer\"];\n  var titleType = toTitleCase$1(type);\n\n  if (!buffer) {\n    return;\n  }\n\n  buffer.removeEventListener('updateend', sourceUpdater[\"on\" + titleType + \"UpdateEnd_\"]);\n  buffer.removeEventListener('error', sourceUpdater[\"on\" + titleType + \"Error_\"]);\n  sourceUpdater.codecs[type] = null;\n  sourceUpdater[type + \"Buffer\"] = null;\n};\n\nvar inSourceBuffers = function inSourceBuffers(mediaSource, sourceBuffer) {\n  return mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;\n};\n\nvar actions = {\n  appendBuffer: function appendBuffer(bytes, segmentInfo) {\n    return function (type, sourceUpdater) {\n      var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n\n      sourceUpdater.logger_(\"Appending segment \" + segmentInfo.mediaIndex + \"'s \" + bytes.length + \" bytes to \" + type + \"Buffer\");\n      sourceBuffer.appendBuffer(bytes);\n    };\n  },\n  remove: function remove(start, end) {\n    return function (type, sourceUpdater) {\n      var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n\n      sourceUpdater.logger_(\"Removing \" + start + \" to \" + end + \" from \" + type + \"Buffer\");\n      sourceBuffer.remove(start, end);\n    };\n  },\n  timestampOffset: function timestampOffset(offset) {\n    return function (type, sourceUpdater) {\n      var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n\n      sourceUpdater.logger_(\"Setting \" + type + \"timestampOffset to \" + offset);\n      sourceBuffer.timestampOffset = offset;\n    };\n  },\n  callback: function callback(_callback) {\n    return function (type, sourceUpdater) {\n      _callback();\n    };\n  },\n  endOfStream: function endOfStream(error) {\n    return function (sourceUpdater) {\n      if (sourceUpdater.mediaSource.readyState !== 'open') {\n        return;\n      }\n\n      sourceUpdater.logger_(\"Calling mediaSource endOfStream(\" + (error || '') + \")\");\n\n      try {\n        sourceUpdater.mediaSource.endOfStream(error);\n      } catch (e) {\n        videojs$1.log.warn('Failed to call media source endOfStream', e);\n      }\n    };\n  },\n  duration: function duration(_duration) {\n    return function (sourceUpdater) {\n      sourceUpdater.logger_(\"Setting mediaSource duration to \" + _duration);\n\n      try {\n        sourceUpdater.mediaSource.duration = _duration;\n      } catch (e) {\n        videojs$1.log.warn('Failed to set media source duration', e);\n      }\n    };\n  },\n  abort: function abort() {\n    return function (type, sourceUpdater) {\n      if (sourceUpdater.mediaSource.readyState !== 'open') {\n        return;\n      }\n\n      var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n\n      sourceUpdater.logger_(\"calling abort on \" + type + \"Buffer\");\n\n      try {\n        sourceBuffer.abort();\n      } catch (e) {\n        videojs$1.log.warn(\"Failed to abort on \" + type + \"Buffer\", e);\n      }\n    };\n  },\n  addSourceBuffer: function addSourceBuffer(type, codec) {\n    return function (sourceUpdater) {\n      var titleType = toTitleCase$1(type);\n      var mime = getMimeForCodec(codec);\n      sourceUpdater.logger_(\"Adding \" + type + \"Buffer with codec \" + codec + \" to mediaSource\");\n      var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);\n      sourceBuffer.addEventListener('updateend', sourceUpdater[\"on\" + titleType + \"UpdateEnd_\"]);\n      sourceBuffer.addEventListener('error', sourceUpdater[\"on\" + titleType + \"Error_\"]);\n      sourceUpdater.codecs[type] = codec;\n      sourceUpdater[type + \"Buffer\"] = sourceBuffer;\n    };\n  },\n  removeSourceBuffer: function removeSourceBuffer(type) {\n    return function (sourceUpdater) {\n      var sourceBuffer = sourceUpdater[type + \"Buffer\"];\n      cleanupBuffer(type, sourceUpdater); // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n\n      sourceUpdater.logger_(\"Removing \" + type + \"Buffer with codec \" + sourceUpdater.codecs[type] + \" from mediaSource\");\n\n      try {\n        sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);\n      } catch (e) {\n        videojs$1.log.warn(\"Failed to removeSourceBuffer \" + type + \"Buffer\", e);\n      }\n    };\n  },\n  changeType: function changeType(codec) {\n    return function (type, sourceUpdater) {\n      var sourceBuffer = sourceUpdater[type + \"Buffer\"];\n      var mime = getMimeForCodec(codec); // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      } // do not update codec if we don't need to.\n\n\n      if (sourceUpdater.codecs[type] === codec) {\n        return;\n      }\n\n      sourceUpdater.logger_(\"changing \" + type + \"Buffer codec from \" + sourceUpdater.codecs[type] + \" to \" + codec);\n      sourceBuffer.changeType(mime);\n      sourceUpdater.codecs[type] = codec;\n    };\n  }\n};\n\nvar pushQueue = function pushQueue(_ref) {\n  var type = _ref.type,\n      sourceUpdater = _ref.sourceUpdater,\n      action = _ref.action,\n      doneFn = _ref.doneFn,\n      name = _ref.name;\n  sourceUpdater.queue.push({\n    type: type,\n    action: action,\n    doneFn: doneFn,\n    name: name\n  });\n  shiftQueue(type, sourceUpdater);\n};\n\nvar onUpdateend = function onUpdateend(type, sourceUpdater) {\n  return function (e) {\n    // Although there should, in theory, be a pending action for any updateend receieved,\n    // there are some actions that may trigger updateend events without set definitions in\n    // the w3c spec. For instance, setting the duration on the media source may trigger\n    // updateend events on source buffers. This does not appear to be in the spec. As such,\n    // if we encounter an updateend without a corresponding pending action from our queue\n    // for that source buffer type, process the next action.\n    if (sourceUpdater.queuePending[type]) {\n      var doneFn = sourceUpdater.queuePending[type].doneFn;\n      sourceUpdater.queuePending[type] = null;\n\n      if (doneFn) {\n        // if there's an error, report it\n        doneFn(sourceUpdater[type + \"Error_\"]);\n      }\n    }\n\n    shiftQueue(type, sourceUpdater);\n  };\n};\n/**\n * A queue of callbacks to be serialized and applied when a\n * MediaSource and its associated SourceBuffers are not in the\n * updating state. It is used by the segment loader to update the\n * underlying SourceBuffers when new data is loaded, for instance.\n *\n * @class SourceUpdater\n * @param {MediaSource} mediaSource the MediaSource to create the SourceBuffer from\n * @param {string} mimeType the desired MIME type of the underlying SourceBuffer\n */\n\n\nvar SourceUpdater = /*#__PURE__*/function (_videojs$EventTarget) {\n  _inheritsLoose(SourceUpdater, _videojs$EventTarget);\n\n  function SourceUpdater(mediaSource) {\n    var _this;\n\n    _this = _videojs$EventTarget.call(this) || this;\n    _this.mediaSource = mediaSource;\n\n    _this.sourceopenListener_ = function () {\n      return shiftQueue('mediaSource', _assertThisInitialized(_this));\n    };\n\n    _this.mediaSource.addEventListener('sourceopen', _this.sourceopenListener_);\n\n    _this.logger_ = logger('SourceUpdater'); // initial timestamp offset is 0\n\n    _this.audioTimestampOffset_ = 0;\n    _this.videoTimestampOffset_ = 0;\n    _this.queue = [];\n    _this.queuePending = {\n      audio: null,\n      video: null\n    };\n    _this.delayedAudioAppendQueue_ = [];\n    _this.videoAppendQueued_ = false;\n    _this.codecs = {};\n    _this.onVideoUpdateEnd_ = onUpdateend('video', _assertThisInitialized(_this));\n    _this.onAudioUpdateEnd_ = onUpdateend('audio', _assertThisInitialized(_this));\n\n    _this.onVideoError_ = function (e) {\n      // used for debugging\n      _this.videoError_ = e;\n    };\n\n    _this.onAudioError_ = function (e) {\n      // used for debugging\n      _this.audioError_ = e;\n    };\n\n    _this.started_ = false;\n    return _this;\n  }\n\n  var _proto = SourceUpdater.prototype;\n\n  _proto.ready = function ready() {\n    return this.started_;\n  };\n\n  _proto.createSourceBuffers = function createSourceBuffers(codecs) {\n    if (this.ready()) {\n      // already created them before\n      return;\n    } // the intial addOrChangeSourceBuffers will always be\n    // two add buffers.\n\n\n    this.addOrChangeSourceBuffers(codecs);\n    this.started_ = true;\n    this.trigger('ready');\n  }\n  /**\n   * Add a type of source buffer to the media source.\n   *\n   * @param {string} type\n   *        The type of source buffer to add.\n   *\n   * @param {string} codec\n   *        The codec to add the source buffer with.\n   */\n  ;\n\n  _proto.addSourceBuffer = function addSourceBuffer(type, codec) {\n    pushQueue({\n      type: 'mediaSource',\n      sourceUpdater: this,\n      action: actions.addSourceBuffer(type, codec),\n      name: 'addSourceBuffer'\n    });\n  }\n  /**\n   * call abort on a source buffer.\n   *\n   * @param {string} type\n   *        The type of source buffer to call abort on.\n   */\n  ;\n\n  _proto.abort = function abort(type) {\n    pushQueue({\n      type: type,\n      sourceUpdater: this,\n      action: actions.abort(type),\n      name: 'abort'\n    });\n  }\n  /**\n   * Call removeSourceBuffer and remove a specific type\n   * of source buffer on the mediaSource.\n   *\n   * @param {string} type\n   *        The type of source buffer to remove.\n   */\n  ;\n\n  _proto.removeSourceBuffer = function removeSourceBuffer(type) {\n    if (!this.canRemoveSourceBuffer()) {\n      videojs$1.log.error('removeSourceBuffer is not supported!');\n      return;\n    }\n\n    pushQueue({\n      type: 'mediaSource',\n      sourceUpdater: this,\n      action: actions.removeSourceBuffer(type),\n      name: 'removeSourceBuffer'\n    });\n  }\n  /**\n   * Whether or not the removeSourceBuffer function is supported\n   * on the mediaSource.\n   *\n   * @return {boolean}\n   *          if removeSourceBuffer can be called.\n   */\n  ;\n\n  _proto.canRemoveSourceBuffer = function canRemoveSourceBuffer() {\n    // IE reports that it supports removeSourceBuffer, but often throws\n    // errors when attempting to use the function. So we report that it\n    // does not support removeSourceBuffer.\n    return !videojs$1.browser.IE_VERSION && window$1.MediaSource && window$1.MediaSource.prototype && typeof window$1.MediaSource.prototype.removeSourceBuffer === 'function';\n  }\n  /**\n   * Whether or not the changeType function is supported\n   * on our SourceBuffers.\n   *\n   * @return {boolean}\n   *         if changeType can be called.\n   */\n  ;\n\n  SourceUpdater.canChangeType = function canChangeType() {\n    return window$1.SourceBuffer && window$1.SourceBuffer.prototype && typeof window$1.SourceBuffer.prototype.changeType === 'function';\n  }\n  /**\n   * Whether or not the changeType function is supported\n   * on our SourceBuffers.\n   *\n   * @return {boolean}\n   *         if changeType can be called.\n   */\n  ;\n\n  _proto.canChangeType = function canChangeType() {\n    return this.constructor.canChangeType();\n  }\n  /**\n   * Call the changeType function on a source buffer, given the code and type.\n   *\n   * @param {string} type\n   *        The type of source buffer to call changeType on.\n   *\n   * @param {string} codec\n   *        The codec string to change type with on the source buffer.\n   */\n  ;\n\n  _proto.changeType = function changeType(type, codec) {\n    if (!this.canChangeType()) {\n      videojs$1.log.error('changeType is not supported!');\n      return;\n    }\n\n    pushQueue({\n      type: type,\n      sourceUpdater: this,\n      action: actions.changeType(codec),\n      name: 'changeType'\n    });\n  }\n  /**\n   * Add source buffers with a codec or, if they are already created,\n   * call changeType on source buffers using changeType.\n   *\n   * @param {Object} codecs\n   *        Codecs to switch to\n   */\n  ;\n\n  _proto.addOrChangeSourceBuffers = function addOrChangeSourceBuffers(codecs) {\n    var _this2 = this;\n\n    if (!codecs || typeof codecs !== 'object' || Object.keys(codecs).length === 0) {\n      throw new Error('Cannot addOrChangeSourceBuffers to undefined codecs');\n    }\n\n    Object.keys(codecs).forEach(function (type) {\n      var codec = codecs[type];\n\n      if (!_this2.ready()) {\n        return _this2.addSourceBuffer(type, codec);\n      }\n\n      if (_this2.canChangeType()) {\n        _this2.changeType(type, codec);\n      }\n    });\n  }\n  /**\n   * Queue an update to append an ArrayBuffer.\n   *\n   * @param {MediaObject} object containing audioBytes and/or videoBytes\n   * @param {Function} done the function to call when done\n   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\n   */\n  ;\n\n  _proto.appendBuffer = function appendBuffer(options, doneFn) {\n    var _this3 = this;\n\n    var segmentInfo = options.segmentInfo,\n        type = options.type,\n        bytes = options.bytes;\n    this.processedAppend_ = true;\n\n    if (type === 'audio' && this.videoBuffer && !this.videoAppendQueued_) {\n      this.delayedAudioAppendQueue_.push([options, doneFn]);\n      this.logger_(\"delayed audio append of \" + bytes.length + \" until video append\");\n      return;\n    }\n\n    pushQueue({\n      type: type,\n      sourceUpdater: this,\n      action: actions.appendBuffer(bytes, segmentInfo || {\n        mediaIndex: -1\n      }),\n      doneFn: doneFn,\n      name: 'appendBuffer'\n    });\n\n    if (type === 'video') {\n      this.videoAppendQueued_ = true;\n\n      if (!this.delayedAudioAppendQueue_.length) {\n        return;\n      }\n\n      var queue = this.delayedAudioAppendQueue_.slice();\n      this.logger_(\"queuing delayed audio \" + queue.length + \" appendBuffers\");\n      this.delayedAudioAppendQueue_.length = 0;\n      queue.forEach(function (que) {\n        _this3.appendBuffer.apply(_this3, que);\n      });\n    }\n  }\n  /**\n   * Get the audio buffer's buffered timerange.\n   *\n   * @return {TimeRange}\n   *         The audio buffer's buffered time range\n   */\n  ;\n\n  _proto.audioBuffered = function audioBuffered() {\n    // no media source/source buffer or it isn't in the media sources\n    // source buffer list\n    if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {\n      return videojs$1.createTimeRange();\n    }\n\n    return this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs$1.createTimeRange();\n  }\n  /**\n   * Get the video buffer's buffered timerange.\n   *\n   * @return {TimeRange}\n   *         The video buffer's buffered time range\n   */\n  ;\n\n  _proto.videoBuffered = function videoBuffered() {\n    // no media source/source buffer or it isn't in the media sources\n    // source buffer list\n    if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {\n      return videojs$1.createTimeRange();\n    }\n\n    return this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs$1.createTimeRange();\n  }\n  /**\n   * Get a combined video/audio buffer's buffered timerange.\n   *\n   * @return {TimeRange}\n   *         the combined time range\n   */\n  ;\n\n  _proto.buffered = function buffered() {\n    var video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;\n    var audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;\n\n    if (audio && !video) {\n      return this.audioBuffered();\n    }\n\n    if (video && !audio) {\n      return this.videoBuffered();\n    }\n\n    return bufferIntersection(this.audioBuffered(), this.videoBuffered());\n  }\n  /**\n   * Add a callback to the queue that will set duration on the mediaSource.\n   *\n   * @param {number} duration\n   *        The duration to set\n   *\n   * @param {Function} [doneFn]\n   *        function to run after duration has been set.\n   */\n  ;\n\n  _proto.setDuration = function setDuration(duration, doneFn) {\n    if (doneFn === void 0) {\n      doneFn = noop;\n    } // In order to set the duration on the media source, it's necessary to wait for all\n    // source buffers to no longer be updating. \"If the updating attribute equals true on\n    // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n    // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n\n\n    pushQueue({\n      type: 'mediaSource',\n      sourceUpdater: this,\n      action: actions.duration(duration),\n      name: 'duration',\n      doneFn: doneFn\n    });\n  }\n  /**\n   * Add a mediaSource endOfStream call to the queue\n   *\n   * @param {Error} [error]\n   *        Call endOfStream with an error\n   *\n   * @param {Function} [doneFn]\n   *        A function that should be called when the\n   *        endOfStream call has finished.\n   */\n  ;\n\n  _proto.endOfStream = function endOfStream(error, doneFn) {\n    if (error === void 0) {\n      error = null;\n    }\n\n    if (doneFn === void 0) {\n      doneFn = noop;\n    }\n\n    if (typeof error !== 'string') {\n      error = undefined;\n    } // In order to set the duration on the media source, it's necessary to wait for all\n    // source buffers to no longer be updating. \"If the updating attribute equals true on\n    // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n    // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n\n\n    pushQueue({\n      type: 'mediaSource',\n      sourceUpdater: this,\n      action: actions.endOfStream(error),\n      name: 'endOfStream',\n      doneFn: doneFn\n    });\n  }\n  /**\n   * Queue an update to remove a time range from the buffer.\n   *\n   * @param {number} start where to start the removal\n   * @param {number} end where to end the removal\n   * @param {Function} [done=noop] optional callback to be executed when the remove\n   * operation is complete\n   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n   */\n  ;\n\n  _proto.removeAudio = function removeAudio(start, end, done) {\n    if (done === void 0) {\n      done = noop;\n    }\n\n    if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {\n      done();\n      return;\n    }\n\n    pushQueue({\n      type: 'audio',\n      sourceUpdater: this,\n      action: actions.remove(start, end),\n      doneFn: done,\n      name: 'remove'\n    });\n  }\n  /**\n   * Queue an update to remove a time range from the buffer.\n   *\n   * @param {number} start where to start the removal\n   * @param {number} end where to end the removal\n   * @param {Function} [done=noop] optional callback to be executed when the remove\n   * operation is complete\n   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n   */\n  ;\n\n  _proto.removeVideo = function removeVideo(start, end, done) {\n    if (done === void 0) {\n      done = noop;\n    }\n\n    if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {\n      done();\n      return;\n    }\n\n    pushQueue({\n      type: 'video',\n      sourceUpdater: this,\n      action: actions.remove(start, end),\n      doneFn: done,\n      name: 'remove'\n    });\n  }\n  /**\n   * Whether the underlying sourceBuffer is updating or not\n   *\n   * @return {boolean} the updating status of the SourceBuffer\n   */\n  ;\n\n  _proto.updating = function updating() {\n    // the audio/video source buffer is updating\n    if (_updating('audio', this) || _updating('video', this)) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Set/get the timestampoffset on the audio SourceBuffer\n   *\n   * @return {number} the timestamp offset\n   */\n  ;\n\n  _proto.audioTimestampOffset = function audioTimestampOffset(offset) {\n    if (typeof offset !== 'undefined' && this.audioBuffer && // no point in updating if it's the same\n    this.audioTimestampOffset_ !== offset) {\n      pushQueue({\n        type: 'audio',\n        sourceUpdater: this,\n        action: actions.timestampOffset(offset),\n        name: 'timestampOffset'\n      });\n      this.audioTimestampOffset_ = offset;\n    }\n\n    return this.audioTimestampOffset_;\n  }\n  /**\n   * Set/get the timestampoffset on the video SourceBuffer\n   *\n   * @return {number} the timestamp offset\n   */\n  ;\n\n  _proto.videoTimestampOffset = function videoTimestampOffset(offset) {\n    if (typeof offset !== 'undefined' && this.videoBuffer && // no point in updating if it's the same\n    this.videoTimestampOffset !== offset) {\n      pushQueue({\n        type: 'video',\n        sourceUpdater: this,\n        action: actions.timestampOffset(offset),\n        name: 'timestampOffset'\n      });\n      this.videoTimestampOffset_ = offset;\n    }\n\n    return this.videoTimestampOffset_;\n  }\n  /**\n   * Add a function to the queue that will be called\n   * when it is its turn to run in the audio queue.\n   *\n   * @param {Function} callback\n   *        The callback to queue.\n   */\n  ;\n\n  _proto.audioQueueCallback = function audioQueueCallback(callback) {\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    pushQueue({\n      type: 'audio',\n      sourceUpdater: this,\n      action: actions.callback(callback),\n      name: 'callback'\n    });\n  }\n  /**\n   * Add a function to the queue that will be called\n   * when it is its turn to run in the video queue.\n   *\n   * @param {Function} callback\n   *        The callback to queue.\n   */\n  ;\n\n  _proto.videoQueueCallback = function videoQueueCallback(callback) {\n    if (!this.videoBuffer) {\n      return;\n    }\n\n    pushQueue({\n      type: 'video',\n      sourceUpdater: this,\n      action: actions.callback(callback),\n      name: 'callback'\n    });\n  }\n  /**\n   * dispose of the source updater and the underlying sourceBuffer\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    var _this4 = this;\n\n    this.trigger('dispose');\n    bufferTypes.forEach(function (type) {\n      _this4.abort(type);\n\n      if (_this4.canRemoveSourceBuffer()) {\n        _this4.removeSourceBuffer(type);\n      } else {\n        _this4[type + \"QueueCallback\"](function () {\n          return cleanupBuffer(type, _this4);\n        });\n      }\n    });\n    this.videoAppendQueued_ = false;\n    this.delayedAudioAppendQueue_.length = 0;\n\n    if (this.sourceopenListener_) {\n      this.mediaSource.removeEventListener('sourceopen', this.sourceopenListener_);\n    }\n\n    this.off();\n  };\n\n  return SourceUpdater;\n}(videojs$1.EventTarget);\n\nvar uint8ToUtf8 = function uint8ToUtf8(uintArray) {\n  return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));\n};\n\nvar VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(function (_char2) {\n  return _char2.charCodeAt(0);\n}));\n/**\n * An object that manages segment loading and appending.\n *\n * @class VTTSegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar VTTSegmentLoader = /*#__PURE__*/function (_SegmentLoader) {\n  _inheritsLoose(VTTSegmentLoader, _SegmentLoader);\n\n  function VTTSegmentLoader(settings, options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _SegmentLoader.call(this, settings, options) || this; // VTT can't handle partial data\n\n    _this.handlePartialData_ = false; // SegmentLoader requires a MediaSource be specified or it will throw an error;\n    // however, VTTSegmentLoader has no need of a media source, so delete the reference\n\n    _this.mediaSource_ = null;\n    _this.subtitlesTrack_ = null;\n    _this.loaderType_ = 'subtitle';\n    _this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks; // The VTT segment will have its own time mappings. Saving VTT segment timing info in\n    // the sync controller leads to improper behavior.\n\n    _this.shouldSaveSegmentTimingInfo_ = false;\n    return _this;\n  }\n\n  var _proto = VTTSegmentLoader.prototype;\n\n  _proto.createTransmuxer_ = function createTransmuxer_() {\n    // don't need to transmux any subtitles\n    return null;\n  }\n  /**\n   * Indicates which time ranges are buffered\n   *\n   * @return {TimeRange}\n   *         TimeRange object representing the current buffered ranges\n   */\n  ;\n\n  _proto.buffered_ = function buffered_() {\n    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues.length) {\n      return videojs$1.createTimeRanges();\n    }\n\n    var cues = this.subtitlesTrack_.cues;\n    var start = cues[0].startTime;\n    var end = cues[cues.length - 1].startTime;\n    return videojs$1.createTimeRanges([[start, end]]);\n  }\n  /**\n   * Gets and sets init segment for the provided map\n   *\n   * @param {Object} map\n   *        The map object representing the init segment to get or set\n   * @param {boolean=} set\n   *        If true, the init segment for the provided map should be saved\n   * @return {Object}\n   *         map object for desired init segment\n   */\n  ;\n\n  _proto.initSegmentForMap = function initSegmentForMap(map, set) {\n    if (set === void 0) {\n      set = false;\n    }\n\n    if (!map) {\n      return null;\n    }\n\n    var id = initSegmentId(map);\n    var storedMap = this.initSegments_[id];\n\n    if (set && !storedMap && map.bytes) {\n      // append WebVTT line terminators to the media initialization segment if it exists\n      // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n      // requires two or more WebVTT line terminators between the WebVTT header and the\n      // rest of the file\n      var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n      var combinedSegment = new Uint8Array(combinedByteLength);\n      combinedSegment.set(map.bytes);\n      combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n      this.initSegments_[id] = storedMap = {\n        resolvedUri: map.resolvedUri,\n        byterange: map.byterange,\n        bytes: combinedSegment\n      };\n    }\n\n    return storedMap || map;\n  }\n  /**\n   * Returns true if all configuration required for loading is present, otherwise false.\n   *\n   * @return {boolean} True if the all configuration is ready for loading\n   * @private\n   */\n  ;\n\n  _proto.couldBeginLoading_ = function couldBeginLoading_() {\n    return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n  }\n  /**\n   * Once all the starting parameters have been specified, begin\n   * operation. This method should only be invoked from the INIT\n   * state.\n   *\n   * @private\n   */\n  ;\n\n  _proto.init_ = function init_() {\n    this.state = 'READY';\n    this.resetEverything();\n    return this.monitorBuffer_();\n  }\n  /**\n   * Set a subtitle track on the segment loader to add subtitles to\n   *\n   * @param {TextTrack=} track\n   *        The text track to add loaded subtitles to\n   * @return {TextTrack}\n   *        Returns the subtitles track\n   */\n  ;\n\n  _proto.track = function track(_track) {\n    if (typeof _track === 'undefined') {\n      return this.subtitlesTrack_;\n    }\n\n    this.subtitlesTrack_ = _track; // if we were unpaused but waiting for a sourceUpdater, start\n    // buffering now\n\n    if (this.state === 'INIT' && this.couldBeginLoading_()) {\n      this.init_();\n    }\n\n    return this.subtitlesTrack_;\n  }\n  /**\n   * Remove any data in the source buffer between start and end times\n   *\n   * @param {number} start - the start time of the region to remove from the buffer\n   * @param {number} end - the end time of the region to remove from the buffer\n   */\n  ;\n\n  _proto.remove = function remove(start, end) {\n    removeCuesFromTrack(start, end, this.subtitlesTrack_);\n  }\n  /**\n   * fill the buffer with segements unless the sourceBuffers are\n   * currently updating\n   *\n   * Note: this function should only ever be called by monitorBuffer_\n   * and never directly\n   *\n   * @private\n   */\n  ;\n\n  _proto.fillBuffer_ = function fillBuffer_() {\n    var _this2 = this;\n\n    if (!this.syncPoint_) {\n      this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n    } // see if we need to begin loading immediately\n\n\n    var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n    segmentInfo = this.skipEmptySegments_(segmentInfo);\n\n    if (!segmentInfo) {\n      return;\n    }\n\n    if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n      // We don't have the timestamp offset that we need to sync subtitles.\n      // Rerun on a timestamp offset or user interaction.\n      var checkTimestampOffset = function checkTimestampOffset() {\n        _this2.state = 'READY';\n\n        if (!_this2.paused()) {\n          // if not paused, queue a buffer check as soon as possible\n          _this2.monitorBuffer_();\n        }\n      };\n\n      this.syncController_.one('timestampoffset', checkTimestampOffset);\n      this.state = 'WAITING_ON_TIMELINE';\n      return;\n    }\n\n    this.loadSegment_(segmentInfo);\n  }\n  /**\n   * Prevents the segment loader from requesting segments we know contain no subtitles\n   * by walking forward until we find the next segment that we don't know whether it is\n   * empty or not.\n   *\n   * @param {Object} segmentInfo\n   *        a segment info object that describes the current segment\n   * @return {Object}\n   *         a segment info object that describes the current segment\n   */\n  ;\n\n  _proto.skipEmptySegments_ = function skipEmptySegments_(segmentInfo) {\n    while (segmentInfo && segmentInfo.segment.empty) {\n      segmentInfo = this.generateSegmentInfo_(segmentInfo.playlist, segmentInfo.mediaIndex + 1, segmentInfo.startOfSegment + segmentInfo.duration, segmentInfo.isSyncRequest);\n    }\n\n    return segmentInfo;\n  };\n\n  _proto.stopForError = function stopForError(error) {\n    this.error(error);\n    this.state = 'READY';\n    this.pause();\n    this.trigger('error');\n  }\n  /**\n   * append a decrypted segement to the SourceBuffer through a SourceUpdater\n   *\n   * @private\n   */\n  ;\n\n  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {\n    var _this3 = this;\n\n    if (!this.subtitlesTrack_) {\n      this.state = 'READY';\n      return;\n    }\n\n    this.saveTransferStats_(simpleSegment.stats); // the request was aborted\n\n    if (!this.pendingSegment_) {\n      this.state = 'READY';\n      this.mediaRequestsAborted += 1;\n      return;\n    }\n\n    if (error) {\n      if (error.code === REQUEST_ERRORS.TIMEOUT) {\n        this.handleTimeout_();\n      }\n\n      if (error.code === REQUEST_ERRORS.ABORTED) {\n        this.mediaRequestsAborted += 1;\n      } else {\n        this.mediaRequestsErrored += 1;\n      }\n\n      this.stopForError(error);\n      return;\n    } // although the VTT segment loader bandwidth isn't really used, it's good to\n    // maintain functionality between segment loaders\n\n\n    this.saveBandwidthRelatedStats_(simpleSegment.stats);\n    this.state = 'APPENDING'; // used for tests\n\n    this.trigger('appending');\n    var segmentInfo = this.pendingSegment_;\n    var segment = segmentInfo.segment;\n\n    if (segment.map) {\n      segment.map.bytes = simpleSegment.map.bytes;\n    }\n\n    segmentInfo.bytes = simpleSegment.bytes; // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n\n    if (typeof window$1.WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {\n      var loadHandler;\n\n      var errorHandler = function errorHandler() {\n        _this3.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);\n\n        _this3.stopForError({\n          message: 'Error loading vtt.js'\n        });\n\n        return;\n      };\n\n      loadHandler = function loadHandler() {\n        _this3.subtitlesTrack_.tech_.off('vttjserror', errorHandler);\n\n        _this3.segmentRequestFinished_(error, simpleSegment, result);\n      };\n\n      this.state = 'WAITING_ON_VTTJS';\n      this.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);\n      this.subtitlesTrack_.tech_.one('vttjserror', errorHandler);\n      return;\n    }\n\n    segment.requested = true;\n\n    try {\n      this.parseVTTCues_(segmentInfo);\n    } catch (e) {\n      this.stopForError({\n        message: e.message\n      });\n      return;\n    }\n\n    this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n\n    if (segmentInfo.cues.length) {\n      segmentInfo.timingInfo = {\n        start: segmentInfo.cues[0].startTime,\n        end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime\n      };\n    } else {\n      segmentInfo.timingInfo = {\n        start: segmentInfo.startOfSegment,\n        end: segmentInfo.startOfSegment + segmentInfo.duration\n      };\n    }\n\n    if (segmentInfo.isSyncRequest) {\n      this.trigger('syncinfoupdate');\n      this.pendingSegment_ = null;\n      this.state = 'READY';\n      return;\n    }\n\n    segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n    this.mediaSecondsLoaded += segment.duration;\n    segmentInfo.cues.forEach(function (cue) {\n      // remove any overlapping cues to prevent doubling\n      _this3.remove(cue.startTime, cue.endTime);\n\n      _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new window$1.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);\n    });\n    this.handleAppendsDone_();\n  };\n\n  _proto.handleData_ = function handleData_() {// noop as we shouldn't be getting video/audio data captions\n    // that we do not support here.\n  };\n\n  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_() {} // noop\n\n  /**\n   * Uses the WebVTT parser to parse the segment response\n   *\n   * @param {Object} segmentInfo\n   *        a segment info object that describes the current segment\n   * @private\n   */\n  ;\n\n  _proto.parseVTTCues_ = function parseVTTCues_(segmentInfo) {\n    var decoder;\n    var decodeBytesToString = false;\n\n    if (typeof window$1.TextDecoder === 'function') {\n      decoder = new window$1.TextDecoder('utf8');\n    } else {\n      decoder = window$1.WebVTT.StringDecoder();\n      decodeBytesToString = true;\n    }\n\n    var parser = new window$1.WebVTT.Parser(window$1, window$1.vttjs, decoder);\n    segmentInfo.cues = [];\n    segmentInfo.timestampmap = {\n      MPEGTS: 0,\n      LOCAL: 0\n    };\n    parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n\n    parser.ontimestampmap = function (map) {\n      segmentInfo.timestampmap = map;\n    };\n\n    parser.onparsingerror = function (error) {\n      videojs$1.log.warn('Error encountered when parsing cues: ' + error.message);\n    };\n\n    if (segmentInfo.segment.map) {\n      var mapData = segmentInfo.segment.map.bytes;\n\n      if (decodeBytesToString) {\n        mapData = uint8ToUtf8(mapData);\n      }\n\n      parser.parse(mapData);\n    }\n\n    var segmentData = segmentInfo.bytes;\n\n    if (decodeBytesToString) {\n      segmentData = uint8ToUtf8(segmentData);\n    }\n\n    parser.parse(segmentData);\n    parser.flush();\n  }\n  /**\n   * Updates the start and end times of any cues parsed by the WebVTT parser using\n   * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n   * from the SyncController\n   *\n   * @param {Object} segmentInfo\n   *        a segment info object that describes the current segment\n   * @param {Object} mappingObj\n   *        object containing a mapping from TS to media time\n   * @param {Object} playlist\n   *        the playlist object containing the segment\n   * @private\n   */\n  ;\n\n  _proto.updateTimeMapping_ = function updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n    var segment = segmentInfo.segment;\n\n    if (!mappingObj) {\n      // If the sync controller does not have a mapping of TS to Media Time for the\n      // timeline, then we don't have enough information to update the cue\n      // start/end times\n      return;\n    }\n\n    if (!segmentInfo.cues.length) {\n      // If there are no cues, we also do not have enough information to figure out\n      // segment timing. Mark that the segment contains no cues so we don't re-request\n      // an empty segment.\n      segment.empty = true;\n      return;\n    }\n\n    var timestampmap = segmentInfo.timestampmap;\n    var diff = timestampmap.MPEGTS / ONE_SECOND_IN_TS - timestampmap.LOCAL + mappingObj.mapping;\n    segmentInfo.cues.forEach(function (cue) {\n      // First convert cue time to TS time using the timestamp-map provided within the vtt\n      cue.startTime += diff;\n      cue.endTime += diff;\n    });\n\n    if (!playlist.syncInfo) {\n      var firstStart = segmentInfo.cues[0].startTime;\n      var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n      playlist.syncInfo = {\n        mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n        time: Math.min(firstStart, lastStart - segment.duration)\n      };\n    }\n  };\n\n  return VTTSegmentLoader;\n}(SegmentLoader);\n/**\n * @file ad-cue-tags.js\n */\n\n/**\n * Searches for an ad cue that overlaps with the given mediaTime\n */\n\n\nvar findAdCue = function findAdCue(track, mediaTime) {\n  var cues = track.cues;\n\n  for (var i = 0; i < cues.length; i++) {\n    var cue = cues[i];\n\n    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\n      return cue;\n    }\n  }\n\n  return null;\n};\n\nvar updateAdCues = function updateAdCues(media, track, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (!media.segments) {\n    return;\n  }\n\n  var mediaTime = offset;\n  var cue;\n\n  for (var i = 0; i < media.segments.length; i++) {\n    var segment = media.segments[i];\n\n    if (!cue) {\n      // Since the cues will span for at least the segment duration, adding a fudge\n      // factor of half segment duration will prevent duplicate cues from being\n      // created when timing info is not exact (e.g. cue start time initialized\n      // at 10.006677, but next call mediaTime is 10.003332 )\n      cue = findAdCue(track, mediaTime + segment.duration / 2);\n    }\n\n    if (cue) {\n      if ('cueIn' in segment) {\n        // Found a CUE-IN so end the cue\n        cue.endTime = mediaTime;\n        cue.adEndTime = mediaTime;\n        mediaTime += segment.duration;\n        cue = null;\n        continue;\n      }\n\n      if (mediaTime < cue.endTime) {\n        // Already processed this mediaTime for this cue\n        mediaTime += segment.duration;\n        continue;\n      } // otherwise extend cue until a CUE-IN is found\n\n\n      cue.endTime += segment.duration;\n    } else {\n      if ('cueOut' in segment) {\n        cue = new window$1.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\n        cue.adStartTime = mediaTime; // Assumes tag format to be\n        // #EXT-X-CUE-OUT:30\n\n        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\n        track.addCue(cue);\n      }\n\n      if ('cueOutCont' in segment) {\n        // Entered into the middle of an ad cue\n        // Assumes tag formate to be\n        // #EXT-X-CUE-OUT-CONT:10/30\n        var _segment$cueOutCont$s = segment.cueOutCont.split('/').map(parseFloat),\n            adOffset = _segment$cueOutCont$s[0],\n            adTotal = _segment$cueOutCont$s[1];\n\n        cue = new window$1.VTTCue(mediaTime, mediaTime + segment.duration, '');\n        cue.adStartTime = mediaTime - adOffset;\n        cue.adEndTime = cue.adStartTime + adTotal;\n        track.addCue(cue);\n      }\n    }\n\n    mediaTime += segment.duration;\n  }\n};\n\nvar syncPointStrategies = [// Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n//                the equivalence display-time 0 === segment-index 0\n{\n  name: 'VOD',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (duration !== Infinity) {\n      var syncPoint = {\n        time: 0,\n        segmentIndex: 0\n      };\n      return syncPoint;\n    }\n\n    return null;\n  }\n}, // Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n{\n  name: 'ProgramDateTime',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (!syncController.datetimeToDisplayTime) {\n      return null;\n    }\n\n    var segments = playlist.segments || [];\n    var syncPoint = null;\n    var lastDistance = null;\n    currentTime = currentTime || 0;\n\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (segment.dateTimeObject) {\n        var segmentTime = segment.dateTimeObject.getTime() / 1000;\n        var segmentStart = segmentTime + syncController.datetimeToDisplayTime;\n        var distance = Math.abs(currentTime - segmentStart); // Once the distance begins to increase, or if distance is 0, we have passed\n        // currentTime and can stop looking for better candidates\n\n        if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {\n          break;\n        }\n\n        lastDistance = distance;\n        syncPoint = {\n          time: segmentStart,\n          segmentIndex: i\n        };\n      }\n    }\n\n    return syncPoint;\n  }\n}, // Stategy \"Segment\": We have a known time mapping for a timeline and a\n//                    segment in the current timeline with timing data\n{\n  name: 'Segment',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var segments = playlist.segments || [];\n    var syncPoint = null;\n    var lastDistance = null;\n    currentTime = currentTime || 0;\n\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (segment.timeline === currentTimeline && typeof segment.start !== 'undefined') {\n        var distance = Math.abs(currentTime - segment.start); // Once the distance begins to increase, we have passed\n        // currentTime and can stop looking for better candidates\n\n        if (lastDistance !== null && lastDistance < distance) {\n          break;\n        }\n\n        if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n          lastDistance = distance;\n          syncPoint = {\n            time: segment.start,\n            segmentIndex: i\n          };\n        }\n      }\n    }\n\n    return syncPoint;\n  }\n}, // Stategy \"Discontinuity\": We have a discontinuity with a known\n//                          display-time\n{\n  name: 'Discontinuity',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var syncPoint = null;\n    currentTime = currentTime || 0;\n\n    if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n      var lastDistance = null;\n\n      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n        var segmentIndex = playlist.discontinuityStarts[i];\n        var discontinuity = playlist.discontinuitySequence + i + 1;\n        var discontinuitySync = syncController.discontinuities[discontinuity];\n\n        if (discontinuitySync) {\n          var distance = Math.abs(currentTime - discontinuitySync.time); // Once the distance begins to increase, we have passed\n          // currentTime and can stop looking for better candidates\n\n          if (lastDistance !== null && lastDistance < distance) {\n            break;\n          }\n\n          if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n            lastDistance = distance;\n            syncPoint = {\n              time: discontinuitySync.time,\n              segmentIndex: segmentIndex\n            };\n          }\n        }\n      }\n    }\n\n    return syncPoint;\n  }\n}, // Stategy \"Playlist\": We have a playlist with a known mapping of\n//                     segment index to display time\n{\n  name: 'Playlist',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (playlist.syncInfo) {\n      var syncPoint = {\n        time: playlist.syncInfo.time,\n        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence\n      };\n      return syncPoint;\n    }\n\n    return null;\n  }\n}];\n\nvar SyncController = /*#__PURE__*/function (_videojs$EventTarget) {\n  _inheritsLoose(SyncController, _videojs$EventTarget);\n\n  function SyncController(options) {\n    var _this;\n\n    _this = _videojs$EventTarget.call(this) || this; // ...for synching across variants\n\n    _this.timelines = [];\n    _this.discontinuities = [];\n    _this.datetimeToDisplayTime = null;\n    _this.logger_ = logger('SyncController');\n    return _this;\n  }\n  /**\n   * Find a sync-point for the playlist specified\n   *\n   * A sync-point is defined as a known mapping from display-time to\n   * a segment-index in the current playlist.\n   *\n   * @param {Playlist} playlist\n   *        The playlist that needs a sync-point\n   * @param {number} duration\n   *        Duration of the MediaSource (Infinite if playing a live source)\n   * @param {number} currentTimeline\n   *        The last timeline from which a segment was loaded\n   * @return {Object}\n   *          A sync-point object\n   */\n\n\n  var _proto = SyncController.prototype;\n\n  _proto.getSyncPoint = function getSyncPoint(playlist, duration, currentTimeline, currentTime) {\n    var syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);\n\n    if (!syncPoints.length) {\n      // Signal that we need to attempt to get a sync-point manually\n      // by fetching a segment in the playlist and constructing\n      // a sync-point from that information\n      return null;\n    } // Now find the sync-point that is closest to the currentTime because\n    // that should result in the most accurate guess about which segment\n    // to fetch\n\n\n    return this.selectSyncPoint_(syncPoints, {\n      key: 'time',\n      value: currentTime\n    });\n  }\n  /**\n   * Calculate the amount of time that has expired off the playlist during playback\n   *\n   * @param {Playlist} playlist\n   *        Playlist object to calculate expired from\n   * @param {number} duration\n   *        Duration of the MediaSource (Infinity if playling a live source)\n   * @return {number|null}\n   *          The amount of time that has expired off the playlist during playback. Null\n   *          if no sync-points for the playlist can be found.\n   */\n  ;\n\n  _proto.getExpiredTime = function getExpiredTime(playlist, duration) {\n    if (!playlist || !playlist.segments) {\n      return null;\n    }\n\n    var syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0); // Without sync-points, there is not enough information to determine the expired time\n\n    if (!syncPoints.length) {\n      return null;\n    }\n\n    var syncPoint = this.selectSyncPoint_(syncPoints, {\n      key: 'segmentIndex',\n      value: 0\n    }); // If the sync-point is beyond the start of the playlist, we want to subtract the\n    // duration from index 0 to syncPoint.segmentIndex instead of adding.\n\n    if (syncPoint.segmentIndex > 0) {\n      syncPoint.time *= -1;\n    }\n\n    return Math.abs(syncPoint.time + sumDurations(playlist, syncPoint.segmentIndex, 0));\n  }\n  /**\n   * Runs each sync-point strategy and returns a list of sync-points returned by the\n   * strategies\n   *\n   * @private\n   * @param {Playlist} playlist\n   *        The playlist that needs a sync-point\n   * @param {number} duration\n   *        Duration of the MediaSource (Infinity if playing a live source)\n   * @param {number} currentTimeline\n   *        The last timeline from which a segment was loaded\n   * @return {Array}\n   *          A list of sync-point objects\n   */\n  ;\n\n  _proto.runStrategies_ = function runStrategies_(playlist, duration, currentTimeline, currentTime) {\n    var syncPoints = []; // Try to find a sync-point in by utilizing various strategies...\n\n    for (var i = 0; i < syncPointStrategies.length; i++) {\n      var strategy = syncPointStrategies[i];\n      var syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);\n\n      if (syncPoint) {\n        syncPoint.strategy = strategy.name;\n        syncPoints.push({\n          strategy: strategy.name,\n          syncPoint: syncPoint\n        });\n      }\n    }\n\n    return syncPoints;\n  }\n  /**\n   * Selects the sync-point nearest the specified target\n   *\n   * @private\n   * @param {Array} syncPoints\n   *        List of sync-points to select from\n   * @param {Object} target\n   *        Object specifying the property and value we are targeting\n   * @param {string} target.key\n   *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n   * @param {number} target.value\n   *        The value to target for the specified key.\n   * @return {Object}\n   *          The sync-point nearest the target\n   */\n  ;\n\n  _proto.selectSyncPoint_ = function selectSyncPoint_(syncPoints, target) {\n    var bestSyncPoint = syncPoints[0].syncPoint;\n    var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n    var bestStrategy = syncPoints[0].strategy;\n\n    for (var i = 1; i < syncPoints.length; i++) {\n      var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n\n      if (newDistance < bestDistance) {\n        bestDistance = newDistance;\n        bestSyncPoint = syncPoints[i].syncPoint;\n        bestStrategy = syncPoints[i].strategy;\n      }\n    }\n\n    this.logger_(\"syncPoint for [\" + target.key + \": \" + target.value + \"] chosen with strategy\" + (\" [\" + bestStrategy + \"]: [time:\" + bestSyncPoint.time + \",\") + (\" segmentIndex:\" + bestSyncPoint.segmentIndex + \"]\"));\n    return bestSyncPoint;\n  }\n  /**\n   * Save any meta-data present on the segments when segments leave\n   * the live window to the playlist to allow for synchronization at the\n   * playlist level later.\n   *\n   * @param {Playlist} oldPlaylist - The previous active playlist\n   * @param {Playlist} newPlaylist - The updated and most current playlist\n   */\n  ;\n\n  _proto.saveExpiredSegmentInfo = function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence; // When a segment expires from the playlist and it has a start time\n    // save that information as a possible sync-point reference in future\n\n    for (var i = mediaSequenceDiff - 1; i >= 0; i--) {\n      var lastRemovedSegment = oldPlaylist.segments[i];\n\n      if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n        newPlaylist.syncInfo = {\n          mediaSequence: oldPlaylist.mediaSequence + i,\n          time: lastRemovedSegment.start\n        };\n        this.logger_(\"playlist refresh sync: [time:\" + newPlaylist.syncInfo.time + \",\" + (\" mediaSequence: \" + newPlaylist.syncInfo.mediaSequence + \"]\"));\n        this.trigger('syncinfoupdate');\n        break;\n      }\n    }\n  }\n  /**\n   * Save the mapping from playlist's ProgramDateTime to display. This should\n   * only ever happen once at the start of playback.\n   *\n   * @param {Playlist} playlist - The currently active playlist\n   */\n  ;\n\n  _proto.setDateTimeMapping = function setDateTimeMapping(playlist) {\n    if (!this.datetimeToDisplayTime && playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {\n      var playlistTimestamp = playlist.segments[0].dateTimeObject.getTime() / 1000;\n      this.datetimeToDisplayTime = -playlistTimestamp;\n    }\n  }\n  /**\n   * Calculates and saves timeline mappings, playlist sync info, and segment timing values\n   * based on the latest timing information.\n   *\n   * @param {Object} options\n   *        Options object\n   * @param {SegmentInfo} options.segmentInfo\n   *        The current active request information\n   * @param {boolean} options.shouldSaveTimelineMapping\n   *        If there's a timeline change, determines if the timeline mapping should be\n   *        saved in timelines.\n   */\n  ;\n\n  _proto.saveSegmentTimingInfo = function saveSegmentTimingInfo(_ref) {\n    var segmentInfo = _ref.segmentInfo,\n        shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping;\n    var didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);\n\n    if (didCalculateSegmentTimeMapping) {\n      this.saveDiscontinuitySyncInfo_(segmentInfo); // If the playlist does not have sync information yet, record that information\n      // now with segment timing information\n\n      if (!segmentInfo.playlist.syncInfo) {\n        segmentInfo.playlist.syncInfo = {\n          mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,\n          time: segmentInfo.segment.start\n        };\n      }\n    }\n  };\n\n  _proto.timestampOffsetForTimeline = function timestampOffsetForTimeline(timeline) {\n    if (typeof this.timelines[timeline] === 'undefined') {\n      return null;\n    }\n\n    return this.timelines[timeline].time;\n  };\n\n  _proto.mappingForTimeline = function mappingForTimeline(timeline) {\n    if (typeof this.timelines[timeline] === 'undefined') {\n      return null;\n    }\n\n    return this.timelines[timeline].mapping;\n  }\n  /**\n   * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n   * save that display time to the segment.\n   *\n   * @private\n   * @param {SegmentInfo} segmentInfo\n   *        The current active request information\n   * @param {Object} timingInfo\n   *        The start and end time of the current segment in \"media time\"\n   * @param {boolean} shouldSaveTimelineMapping\n   *        If there's a timeline change, determines if the timeline mapping should be\n   *        saved in timelines.\n   * @return {boolean}\n   *          Returns false if segment time mapping could not be calculated\n   */\n  ;\n\n  _proto.calculateSegmentTimeMapping_ = function calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {\n    var segment = segmentInfo.segment;\n    var mappingObj = this.timelines[segmentInfo.timeline];\n\n    if (segmentInfo.timestampOffset !== null) {\n      mappingObj = {\n        time: segmentInfo.startOfSegment,\n        mapping: segmentInfo.startOfSegment - timingInfo.start\n      };\n\n      if (shouldSaveTimelineMapping) {\n        this.timelines[segmentInfo.timeline] = mappingObj;\n        this.trigger('timestampoffset');\n        this.logger_(\"time mapping for timeline \" + segmentInfo.timeline + \": \" + (\"[time: \" + mappingObj.time + \"] [mapping: \" + mappingObj.mapping + \"]\"));\n      }\n\n      segment.start = segmentInfo.startOfSegment;\n      segment.end = timingInfo.end + mappingObj.mapping;\n    } else if (mappingObj) {\n      segment.start = timingInfo.start + mappingObj.mapping;\n      segment.end = timingInfo.end + mappingObj.mapping;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Each time we have discontinuity in the playlist, attempt to calculate the location\n   * in display of the start of the discontinuity and save that. We also save an accuracy\n   * value so that we save values with the most accuracy (closest to 0.)\n   *\n   * @private\n   * @param {SegmentInfo} segmentInfo - The current active request information\n   */\n  ;\n\n  _proto.saveDiscontinuitySyncInfo_ = function saveDiscontinuitySyncInfo_(segmentInfo) {\n    var playlist = segmentInfo.playlist;\n    var segment = segmentInfo.segment; // If the current segment is a discontinuity then we know exactly where\n    // the start of the range and it's accuracy is 0 (greater accuracy values\n    // mean more approximation)\n\n    if (segment.discontinuity) {\n      this.discontinuities[segment.timeline] = {\n        time: segment.start,\n        accuracy: 0\n      };\n    } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n      // Search for future discontinuities that we can provide better timing\n      // information for and save that information for sync purposes\n      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n        var segmentIndex = playlist.discontinuityStarts[i];\n        var discontinuity = playlist.discontinuitySequence + i + 1;\n        var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n        var accuracy = Math.abs(mediaIndexDiff);\n\n        if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n          var time = void 0;\n\n          if (mediaIndexDiff < 0) {\n            time = segment.start - sumDurations(playlist, segmentInfo.mediaIndex, segmentIndex);\n          } else {\n            time = segment.end + sumDurations(playlist, segmentInfo.mediaIndex + 1, segmentIndex);\n          }\n\n          this.discontinuities[discontinuity] = {\n            time: time,\n            accuracy: accuracy\n          };\n        }\n      }\n    }\n  };\n\n  _proto.dispose = function dispose() {\n    this.trigger('dispose');\n    this.off();\n  };\n\n  return SyncController;\n}(videojs$1.EventTarget);\n/**\n * The TimelineChangeController acts as a source for segment loaders to listen for and\n * keep track of latest and pending timeline changes. This is useful to ensure proper\n * sync, as each loader may need to make a consideration for what timeline the other\n * loader is on before making changes which could impact the other loader's media.\n *\n * @class TimelineChangeController\n * @extends videojs.EventTarget\n */\n\n\nvar TimelineChangeController = /*#__PURE__*/function (_videojs$EventTarget) {\n  _inheritsLoose(TimelineChangeController, _videojs$EventTarget);\n\n  function TimelineChangeController() {\n    var _this;\n\n    _this = _videojs$EventTarget.call(this) || this;\n    _this.pendingTimelineChanges_ = {};\n    _this.lastTimelineChanges_ = {};\n    return _this;\n  }\n\n  var _proto = TimelineChangeController.prototype;\n\n  _proto.clearPendingTimelineChange = function clearPendingTimelineChange(type) {\n    this.pendingTimelineChanges_[type] = null;\n    this.trigger('pendingtimelinechange');\n  };\n\n  _proto.pendingTimelineChange = function pendingTimelineChange(_ref) {\n    var type = _ref.type,\n        from = _ref.from,\n        to = _ref.to;\n\n    if (typeof from === 'number' && typeof to === 'number') {\n      this.pendingTimelineChanges_[type] = {\n        type: type,\n        from: from,\n        to: to\n      };\n      this.trigger('pendingtimelinechange');\n    }\n\n    return this.pendingTimelineChanges_[type];\n  };\n\n  _proto.lastTimelineChange = function lastTimelineChange(_ref2) {\n    var type = _ref2.type,\n        from = _ref2.from,\n        to = _ref2.to;\n\n    if (typeof from === 'number' && typeof to === 'number') {\n      this.lastTimelineChanges_[type] = {\n        type: type,\n        from: from,\n        to: to\n      };\n      delete this.pendingTimelineChanges_[type];\n      this.trigger('timelinechange');\n    }\n\n    return this.lastTimelineChanges_[type];\n  };\n\n  _proto.dispose = function dispose() {\n    this.trigger('dispose');\n    this.pendingTimelineChanges_ = {};\n    this.lastTimelineChanges_ = {};\n    this.off();\n  };\n\n  return TimelineChangeController;\n}(videojs$1.EventTarget);\n\nvar Decrypter = new shimWorker(\"./decrypter-worker.worker.js\", function (window, document) {\n  var self = this;\n  /*! @name @videojs/http-streaming @version 2.2.4 @license Apache-2.0 */\n\n  var decrypterWorker = function () {\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n\n    var createClass = _createClass;\n\n    function _inheritsLoose(subClass, superClass) {\n      subClass.prototype = Object.create(superClass.prototype);\n      subClass.prototype.constructor = subClass;\n      subClass.__proto__ = superClass;\n    }\n\n    var inheritsLoose = _inheritsLoose;\n    /*! @name @videojs/vhs-utils @version 2.2.1 @license MIT */\n\n    /**\n     * @file stream.js\n     */\n\n    /**\n     * A lightweight readable stream implemention that handles event dispatching.\n     *\n     * @class Stream\n     */\n\n    var Stream = /*#__PURE__*/function () {\n      function Stream() {\n        this.listeners = {};\n      }\n      /**\n       * Add a listener for a specified event type.\n       *\n       * @param {string} type the event name\n       * @param {Function} listener the callback to be invoked when an event of\n       * the specified type occurs\n       */\n\n\n      var _proto = Stream.prototype;\n\n      _proto.on = function on(type, listener) {\n        if (!this.listeners[type]) {\n          this.listeners[type] = [];\n        }\n\n        this.listeners[type].push(listener);\n      }\n      /**\n       * Remove a listener for a specified event type.\n       *\n       * @param {string} type the event name\n       * @param {Function} listener  a function previously registered for this\n       * type of event through `on`\n       * @return {boolean} if we could turn it off or not\n       */\n      ;\n\n      _proto.off = function off(type, listener) {\n        if (!this.listeners[type]) {\n          return false;\n        }\n\n        var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n        // In Video.js we slice listener functions\n        // on trigger so that it does not mess up the order\n        // while we loop through.\n        //\n        // Here we slice on off so that the loop in trigger\n        // can continue using it's old reference to loop without\n        // messing up the order.\n\n        this.listeners[type] = this.listeners[type].slice(0);\n        this.listeners[type].splice(index, 1);\n        return index > -1;\n      }\n      /**\n       * Trigger an event of the specified type on this stream. Any additional\n       * arguments to this function are passed as parameters to event listeners.\n       *\n       * @param {string} type the event name\n       */\n      ;\n\n      _proto.trigger = function trigger(type) {\n        var callbacks = this.listeners[type];\n\n        if (!callbacks) {\n          return;\n        } // Slicing the arguments on every invocation of this method\n        // can add a significant amount of overhead. Avoid the\n        // intermediate object creation for the common case of a\n        // single callback argument\n\n\n        if (arguments.length === 2) {\n          var length = callbacks.length;\n\n          for (var i = 0; i < length; ++i) {\n            callbacks[i].call(this, arguments[1]);\n          }\n        } else {\n          var args = Array.prototype.slice.call(arguments, 1);\n          var _length = callbacks.length;\n\n          for (var _i = 0; _i < _length; ++_i) {\n            callbacks[_i].apply(this, args);\n          }\n        }\n      }\n      /**\n       * Destroys the stream and cleans up.\n       */\n      ;\n\n      _proto.dispose = function dispose() {\n        this.listeners = {};\n      }\n      /**\n       * Forwards all `data` events on this stream to the destination stream. The\n       * destination stream should provide a method `push` to receive the data\n       * events as they arrive.\n       *\n       * @param {Stream} destination the stream that will receive all `data` events\n       * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n       */\n      ;\n\n      _proto.pipe = function pipe(destination) {\n        this.on('data', function (data) {\n          destination.push(data);\n        });\n      };\n\n      return Stream;\n    }();\n\n    var stream = Stream;\n    /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */\n\n    /**\n     * Returns the subarray of a Uint8Array without PKCS#7 padding.\n     *\n     * @param padded {Uint8Array} unencrypted bytes that have been padded\n     * @return {Uint8Array} the unpadded bytes\n     * @see http://tools.ietf.org/html/rfc5652\n     */\n\n    function unpad(padded) {\n      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\n    }\n    /*! @name aes-decrypter @version 3.1.0 @license Apache-2.0 */\n\n    /**\n     * @file aes.js\n     *\n     * This file contains an adaptation of the AES decryption algorithm\n     * from the Standford Javascript Cryptography Library. That work is\n     * covered by the following copyright and permissions notice:\n     *\n     * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n     * All rights reserved.\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are\n     * met:\n     *\n     * 1. Redistributions of source code must retain the above copyright\n     *    notice, this list of conditions and the following disclaimer.\n     *\n     * 2. Redistributions in binary form must reproduce the above\n     *    copyright notice, this list of conditions and the following\n     *    disclaimer in the documentation and/or other materials provided\n     *    with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n     * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n     * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n     * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     *\n     * The views and conclusions contained in the software and documentation\n     * are those of the authors and should not be interpreted as representing\n     * official policies, either expressed or implied, of the authors.\n     */\n\n    /**\n     * Expand the S-box tables.\n     *\n     * @private\n     */\n\n\n    var precompute = function precompute() {\n      var tables = [[[], [], [], [], []], [[], [], [], [], []]];\n      var encTable = tables[0];\n      var decTable = tables[1];\n      var sbox = encTable[4];\n      var sboxInv = decTable[4];\n      var i;\n      var x;\n      var xInv;\n      var d = [];\n      var th = [];\n      var x2;\n      var x4;\n      var x8;\n      var s;\n      var tEnc;\n      var tDec; // Compute double and third tables\n\n      for (i = 0; i < 256; i++) {\n        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n      }\n\n      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n        // Compute sbox\n        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n        s = s >> 8 ^ s & 255 ^ 99;\n        sbox[x] = s;\n        sboxInv[s] = x; // Compute MixColumns\n\n        x8 = d[x4 = d[x2 = d[x]]];\n        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        tEnc = d[s] * 0x101 ^ s * 0x1010100;\n\n        for (i = 0; i < 4; i++) {\n          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n        }\n      } // Compactify. Considerable speedup on Firefox.\n\n\n      for (i = 0; i < 5; i++) {\n        encTable[i] = encTable[i].slice(0);\n        decTable[i] = decTable[i].slice(0);\n      }\n\n      return tables;\n    };\n\n    var aesTables = null;\n    /**\n     * Schedule out an AES key for both encryption and decryption. This\n     * is a low-level class. Use a cipher mode to do bulk encryption.\n     *\n     * @class AES\n     * @param key {Array} The key as an array of 4, 6 or 8 words.\n     */\n\n    var AES = /*#__PURE__*/function () {\n      function AES(key) {\n        /**\n        * The expanded S-box and inverse S-box tables. These will be computed\n        * on the client so that we don't have to send them down the wire.\n        *\n        * There are two tables, _tables[0] is for encryption and\n        * _tables[1] is for decryption.\n        *\n        * The first 4 sub-tables are the expanded S-box with MixColumns. The\n        * last (_tables[01][4]) is the S-box itself.\n        *\n        * @private\n        */\n        // if we have yet to precompute the S-box tables\n        // do so now\n        if (!aesTables) {\n          aesTables = precompute();\n        } // then make a copy of that object for use\n\n\n        this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\n        var i;\n        var j;\n        var tmp;\n        var sbox = this._tables[0][4];\n        var decTable = this._tables[1];\n        var keyLen = key.length;\n        var rcon = 1;\n\n        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n          throw new Error('Invalid aes key size');\n        }\n\n        var encKey = key.slice(0);\n        var decKey = [];\n        this._key = [encKey, decKey]; // schedule encryption keys\n\n        for (i = keyLen; i < 4 * keyLen + 28; i++) {\n          tmp = encKey[i - 1]; // apply sbox\n\n          if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255]; // shift rows and add rcon\n\n            if (i % keyLen === 0) {\n              tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n              rcon = rcon << 1 ^ (rcon >> 7) * 283;\n            }\n          }\n\n          encKey[i] = encKey[i - keyLen] ^ tmp;\n        } // schedule decryption keys\n\n\n        for (j = 0; i; j++, i--) {\n          tmp = encKey[j & 3 ? i : i - 4];\n\n          if (i <= 4 || j < 4) {\n            decKey[j] = tmp;\n          } else {\n            decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n          }\n        }\n      }\n      /**\n       * Decrypt 16 bytes, specified as four 32-bit words.\n       *\n       * @param {number} encrypted0 the first word to decrypt\n       * @param {number} encrypted1 the second word to decrypt\n       * @param {number} encrypted2 the third word to decrypt\n       * @param {number} encrypted3 the fourth word to decrypt\n       * @param {Int32Array} out the array to write the decrypted words\n       * into\n       * @param {number} offset the offset into the output array to start\n       * writing results\n       * @return {Array} The plaintext.\n       */\n\n\n      var _proto = AES.prototype;\n\n      _proto.decrypt = function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n        var key = this._key[1]; // state variables a,b,c,d are loaded with pre-whitened data\n\n        var a = encrypted0 ^ key[0];\n        var b = encrypted3 ^ key[1];\n        var c = encrypted2 ^ key[2];\n        var d = encrypted1 ^ key[3];\n        var a2;\n        var b2;\n        var c2; // key.length === 2 ?\n\n        var nInnerRounds = key.length / 4 - 2;\n        var i;\n        var kIndex = 4;\n        var table = this._tables[1]; // load up the tables\n\n        var table0 = table[0];\n        var table1 = table[1];\n        var table2 = table[2];\n        var table3 = table[3];\n        var sbox = table[4]; // Inner rounds. Cribbed from OpenSSL.\n\n        for (i = 0; i < nInnerRounds; i++) {\n          a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\n          b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n          c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n          d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n          kIndex += 4;\n          a = a2;\n          b = b2;\n          c = c2;\n        } // Last round.\n\n\n        for (i = 0; i < 4; i++) {\n          out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n          a2 = a;\n          a = b;\n          b = c;\n          c = d;\n          d = a2;\n        }\n      };\n\n      return AES;\n    }();\n    /**\n     * A wrapper around the Stream class to use setTimeout\n     * and run stream \"jobs\" Asynchronously\n     *\n     * @class AsyncStream\n     * @extends Stream\n     */\n\n\n    var AsyncStream = /*#__PURE__*/function (_Stream) {\n      inheritsLoose(AsyncStream, _Stream);\n\n      function AsyncStream() {\n        var _this;\n\n        _this = _Stream.call(this, stream) || this;\n        _this.jobs = [];\n        _this.delay = 1;\n        _this.timeout_ = null;\n        return _this;\n      }\n      /**\n       * process an async job\n       *\n       * @private\n       */\n\n\n      var _proto = AsyncStream.prototype;\n\n      _proto.processJob_ = function processJob_() {\n        this.jobs.shift()();\n\n        if (this.jobs.length) {\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n        } else {\n          this.timeout_ = null;\n        }\n      }\n      /**\n       * push a job into the stream\n       *\n       * @param {Function} job the job to push into the stream\n       */\n      ;\n\n      _proto.push = function push(job) {\n        this.jobs.push(job);\n\n        if (!this.timeout_) {\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n        }\n      };\n\n      return AsyncStream;\n    }(stream);\n    /**\n     * Convert network-order (big-endian) bytes into their little-endian\n     * representation.\n     */\n\n\n    var ntoh = function ntoh(word) {\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    };\n    /**\n     * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n     *\n     * @param {Uint8Array} encrypted the encrypted bytes\n     * @param {Uint32Array} key the bytes of the decryption key\n     * @param {Uint32Array} initVector the initialization vector (IV) to\n     * use for the first round of CBC.\n     * @return {Uint8Array} the decrypted bytes\n     *\n     * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n     * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n     * @see https://tools.ietf.org/html/rfc2315\n     */\n\n\n    var decrypt = function decrypt(encrypted, key, initVector) {\n      // word-level access to the encrypted bytes\n      var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\n      var decipher = new AES(Array.prototype.slice.call(key)); // byte and word-level access for the decrypted output\n\n      var decrypted = new Uint8Array(encrypted.byteLength);\n      var decrypted32 = new Int32Array(decrypted.buffer); // temporary variables for working with the IV, encrypted, and\n      // decrypted data\n\n      var init0;\n      var init1;\n      var init2;\n      var init3;\n      var encrypted0;\n      var encrypted1;\n      var encrypted2;\n      var encrypted3; // iteration variable\n\n      var wordIx; // pull out the words of the IV to ensure we don't modify the\n      // passed-in reference and easier access\n\n      init0 = initVector[0];\n      init1 = initVector[1];\n      init2 = initVector[2];\n      init3 = initVector[3]; // decrypt four word sequences, applying cipher-block chaining (CBC)\n      // to each decrypted block\n\n      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n        // convert big-endian (network order) words into little-endian\n        // (javascript order)\n        encrypted0 = ntoh(encrypted32[wordIx]);\n        encrypted1 = ntoh(encrypted32[wordIx + 1]);\n        encrypted2 = ntoh(encrypted32[wordIx + 2]);\n        encrypted3 = ntoh(encrypted32[wordIx + 3]); // decrypt the block\n\n        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx); // XOR with the IV, and restore network byte-order to obtain the\n        // plaintext\n\n        decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\n        decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\n        decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\n        decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3); // setup the IV for the next round\n\n        init0 = encrypted0;\n        init1 = encrypted1;\n        init2 = encrypted2;\n        init3 = encrypted3;\n      }\n\n      return decrypted;\n    };\n    /**\n     * The `Decrypter` class that manages decryption of AES\n     * data through `AsyncStream` objects and the `decrypt`\n     * function\n     *\n     * @param {Uint8Array} encrypted the encrypted bytes\n     * @param {Uint32Array} key the bytes of the decryption key\n     * @param {Uint32Array} initVector the initialization vector (IV) to\n     * @param {Function} done the function to run when done\n     * @class Decrypter\n     */\n\n\n    var Decrypter = /*#__PURE__*/function () {\n      function Decrypter(encrypted, key, initVector, done) {\n        var step = Decrypter.STEP;\n        var encrypted32 = new Int32Array(encrypted.buffer);\n        var decrypted = new Uint8Array(encrypted.byteLength);\n        var i = 0;\n        this.asyncStream_ = new AsyncStream(); // split up the encryption job and do the individual chunks asynchronously\n\n        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n\n        for (i = step; i < encrypted32.length; i += step) {\n          initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\n          this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n        } // invoke the done() callback when everything is finished\n\n\n        this.asyncStream_.push(function () {\n          // remove pkcs#7 padding from the decrypted bytes\n          done(null, unpad(decrypted));\n        });\n      }\n      /**\n       * a getter for step the maximum number of bytes to process at one time\n       *\n       * @return {number} the value of step 32000\n       */\n\n\n      var _proto = Decrypter.prototype;\n      /**\n       * @private\n       */\n\n      _proto.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {\n        return function () {\n          var bytes = decrypt(encrypted, key, initVector);\n          decrypted.set(bytes, encrypted.byteOffset);\n        };\n      };\n\n      createClass(Decrypter, null, [{\n        key: \"STEP\",\n        get: function get() {\n          // 4 * 8000;\n          return 32000;\n        }\n      }]);\n      return Decrypter;\n    }();\n    /**\n     * @file bin-utils.js\n     */\n\n    /**\n     * Creates an object for sending to a web worker modifying properties that are TypedArrays\n     * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n     *\n     * @param {Object} message\n     *        Object of properties and values to send to the web worker\n     * @return {Object}\n     *         Modified message with TypedArray values expanded\n     * @function createTransferableMessage\n     */\n\n\n    var createTransferableMessage = function createTransferableMessage(message) {\n      var transferable = {};\n      Object.keys(message).forEach(function (key) {\n        var value = message[key];\n\n        if (ArrayBuffer.isView(value)) {\n          transferable[key] = {\n            bytes: value.buffer,\n            byteOffset: value.byteOffset,\n            byteLength: value.byteLength\n          };\n        } else {\n          transferable[key] = value;\n        }\n      });\n      return transferable;\n    };\n    /* global self */\n\n    /**\n     * Our web worker interface so that things can talk to aes-decrypter\n     * that will be running in a web worker. the scope is passed to this by\n     * webworkify.\n     *\n     * @param {Object} self\n     *        the scope for the web worker\n     */\n\n\n    var DecrypterWorker = function DecrypterWorker(self) {\n      self.onmessage = function (event) {\n        var data = event.data;\n        var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);\n        var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);\n        var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);\n        /* eslint-disable no-new, handle-callback-err */\n\n        new Decrypter(encrypted, key, iv, function (err, bytes) {\n          self.postMessage(createTransferableMessage({\n            source: data.source,\n            decrypted: bytes\n          }), [bytes.buffer]);\n        });\n        /* eslint-enable */\n      };\n    };\n\n    var decrypterWorker = new DecrypterWorker(self);\n    return decrypterWorker;\n  }();\n});\n/**\n * Convert the properties of an HLS track into an audioTrackKind.\n *\n * @private\n */\n\nvar audioTrackKind_ = function audioTrackKind_(properties) {\n  var kind = properties[\"default\"] ? 'main' : 'alternative';\n\n  if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n    kind = 'main-desc';\n  }\n\n  return kind;\n};\n/**\n * Pause provided segment loader and playlist loader if active\n *\n * @param {SegmentLoader} segmentLoader\n *        SegmentLoader to pause\n * @param {Object} mediaType\n *        Active media type\n * @function stopLoaders\n */\n\n\nvar stopLoaders = function stopLoaders(segmentLoader, mediaType) {\n  segmentLoader.abort();\n  segmentLoader.pause();\n\n  if (mediaType && mediaType.activePlaylistLoader) {\n    mediaType.activePlaylistLoader.pause();\n    mediaType.activePlaylistLoader = null;\n  }\n};\n/**\n * Start loading provided segment loader and playlist loader\n *\n * @param {PlaylistLoader} playlistLoader\n *        PlaylistLoader to start loading\n * @param {Object} mediaType\n *        Active media type\n * @function startLoaders\n */\n\n\nvar startLoaders = function startLoaders(playlistLoader, mediaType) {\n  // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n  // playlist loader\n  mediaType.activePlaylistLoader = playlistLoader;\n  playlistLoader.load();\n};\n/**\n * Returns a function to be called when the media group changes. It performs a\n * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n * change of group is merely a rendition switch of the same content at another encoding,\n * rather than a change of content, such as switching audio from English to Spanish.\n *\n * @param {string} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a non-destructive resync of SegmentLoader when the active media\n *         group changes.\n * @function onGroupChanged\n */\n\n\nvar onGroupChanged = function onGroupChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoad = settings.segmentLoaders,\n        segmentLoader = _settings$segmentLoad[type],\n        mainSegmentLoader = _settings$segmentLoad.main,\n        mediaType = settings.mediaTypes[type];\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active\n      return;\n    }\n\n    if (!activeGroup.playlistLoader) {\n      if (previousActiveLoader) {\n        // The previous group had a playlist loader but the new active group does not\n        // this means we are switching from demuxed to muxed audio. In this case we want to\n        // do a destructive reset of the main segment loader and not restart the audio\n        // loaders.\n        mainSegmentLoader.resetEverything();\n      }\n\n      return;\n    } // Non-destructive resync\n\n\n    segmentLoader.resyncLoader();\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\nvar onGroupChanging = function onGroupChanging(type, settings) {\n  return function () {\n    var segmentLoader = settings.segmentLoaders[type];\n    segmentLoader.abort();\n    segmentLoader.pause();\n  };\n};\n/**\n * Returns a function to be called when the media track changes. It performs a\n * destructive reset of the SegmentLoader to ensure we start loading as close to\n * currentTime as possible.\n *\n * @param {string} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a destructive reset of SegmentLoader when the active media\n *         track changes.\n * @function onTrackChanged\n */\n\n\nvar onTrackChanged = function onTrackChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoad2 = settings.segmentLoaders,\n        segmentLoader = _settings$segmentLoad2[type],\n        mainSegmentLoader = _settings$segmentLoad2.main,\n        mediaType = settings.mediaTypes[type];\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active so we do not want to restart loaders\n      return;\n    }\n\n    if (type === 'AUDIO') {\n      if (!activeGroup.playlistLoader) {\n        // when switching from demuxed audio/video to muxed audio/video (noted by no\n        // playlist loader for the audio group), we want to do a destructive reset of the\n        // main segment loader and not restart the audio loaders\n        mainSegmentLoader.setAudio(true); // don't have to worry about disabling the audio of the audio segment loader since\n        // it should be stopped\n\n        mainSegmentLoader.resetEverything();\n        return;\n      } // although the segment loader is an audio segment loader, call the setAudio\n      // function to ensure it is prepared to re-append the init segment (or handle other\n      // config changes)\n\n\n      segmentLoader.setAudio(true);\n      mainSegmentLoader.setAudio(false);\n    }\n\n    if (previousActiveLoader === activeGroup.playlistLoader) {\n      // Nothing has actually changed. This can happen because track change events can fire\n      // multiple times for a \"single\" change. One for enabling the new active track, and\n      // one for disabling the track that was active\n      startLoaders(activeGroup.playlistLoader, mediaType);\n      return;\n    }\n\n    if (segmentLoader.track) {\n      // For WebVTT, set the new text track in the segmentloader\n      segmentLoader.track(activeTrack);\n    } // destructive reset\n\n\n    segmentLoader.resetEverything();\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\nvar onError = {\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning (or error if the playlist is blacklisted) to\n   *         console and switches back to default audio track.\n   * @function onError.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type],\n          mediaType = settings.mediaTypes[type],\n          blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;\n      stopLoaders(segmentLoader, mediaType); // switch back to default audio track\n\n      var activeTrack = mediaType.activeTrack();\n      var activeGroup = mediaType.activeGroup();\n      var id = (activeGroup.filter(function (group) {\n        return group[\"default\"];\n      })[0] || activeGroup[0]).id;\n      var defaultTrack = mediaType.tracks[id];\n\n      if (activeTrack === defaultTrack) {\n        // Default track encountered an error. All we can do now is blacklist the current\n        // rendition and hope another will switch audio groups\n        blacklistCurrentPlaylist({\n          message: 'Problem encountered loading the default audio track.'\n        });\n        return;\n      }\n\n      videojs$1.log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n\n      for (var trackId in mediaType.tracks) {\n        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n      }\n\n      mediaType.onTrackChanged();\n    };\n  },\n\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning to console and disables the active subtitle track\n   * @function onError.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type],\n          mediaType = settings.mediaTypes[type];\n      videojs$1.log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n      stopLoaders(segmentLoader, mediaType);\n      var track = mediaType.activeTrack();\n\n      if (track) {\n        track.mode = 'disabled';\n      }\n\n      mediaType.onTrackChanged();\n    };\n  }\n};\nvar setupListeners = {\n  /**\n   * Setup event listeners for audio playlist loader\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.AUDIO\n   */\n  AUDIO: function AUDIO(type, playlistLoader, settings) {\n    if (!playlistLoader) {\n      // no playlist loader means audio will be muxed with the video\n      return;\n    }\n\n    var tech = settings.tech,\n        requestOptions = settings.requestOptions,\n        segmentLoader = settings.segmentLoaders[type];\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n      segmentLoader.playlist(media, requestOptions); // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('error', onError[type](type, settings));\n  },\n\n  /**\n   * Setup event listeners for subtitle playlist loader\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, playlistLoader, settings) {\n    var tech = settings.tech,\n        requestOptions = settings.requestOptions,\n        segmentLoader = settings.segmentLoaders[type],\n        mediaType = settings.mediaTypes[type];\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n      segmentLoader.playlist(media, requestOptions);\n      segmentLoader.track(mediaType.activeTrack()); // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('error', onError[type](type, settings));\n  }\n};\nvar initialize = {\n  /**\n   * Setup PlaylistLoaders and AudioTracks for the audio groups\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.AUDIO\n   */\n  'AUDIO': function AUDIO(type, settings) {\n    var vhs = settings.vhs,\n        sourceType = settings.sourceType,\n        segmentLoader = settings.segmentLoaders[type],\n        requestOptions = settings.requestOptions,\n        _settings$master = settings.master,\n        mediaGroups = _settings$master.mediaGroups,\n        playlists = _settings$master.playlists,\n        _settings$mediaTypes$ = settings.mediaTypes[type],\n        groups = _settings$mediaTypes$.groups,\n        tracks = _settings$mediaTypes$.tracks,\n        masterPlaylistLoader = settings.masterPlaylistLoader; // force a default if we have none\n\n    if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {\n      mediaGroups[type] = {\n        main: {\n          \"default\": {\n            \"default\": true\n          }\n        }\n      };\n    }\n\n    var _loop = function _loop(groupId) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      } // List of playlists that have an AUDIO attribute value matching the current\n      // group ID\n\n\n      var groupPlaylists = playlists.filter(function (playlist) {\n        return playlist.attributes[type] === groupId;\n      });\n\n      var _loop2 = function _loop2(variantLabel) {\n        var properties = mediaGroups[type][groupId][variantLabel]; // List of playlists for the current group ID that have a matching uri with\n        // this alternate audio variant\n\n        var matchingPlaylists = groupPlaylists.filter(function (playlist) {\n          return playlist.resolvedUri === properties.resolvedUri;\n        });\n\n        if (matchingPlaylists.length) {\n          // If there is a playlist that has the same uri as this audio variant, assume\n          // that the playlist is audio only. We delete the resolvedUri property here\n          // to prevent a playlist loader from being created so that we don't have\n          // both the main and audio segment loaders loading the same audio segments\n          // from the same playlist.\n          delete properties.resolvedUri;\n        }\n\n        var playlistLoader = void 0; // if vhs-json was provided as the source, and the media playlist was resolved,\n        // use the resolved media playlist object\n\n        if (sourceType === 'vhs-json' && properties.playlists) {\n          playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);\n        } else if (properties.resolvedUri) {\n          playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);\n        } else if (properties.playlists && sourceType === 'dash') {\n          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);\n        } else {\n          // no resolvedUri means the audio is muxed with the video when using this\n          // audio track\n          playlistLoader = null;\n        }\n\n        properties = videojs$1.mergeOptions({\n          id: variantLabel,\n          playlistLoader: playlistLoader\n        }, properties);\n        setupListeners[type](type, properties.playlistLoader, settings);\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = new videojs$1.AudioTrack({\n            id: variantLabel,\n            kind: audioTrackKind_(properties),\n            enabled: false,\n            language: properties.language,\n            \"default\": properties[\"default\"],\n            label: variantLabel\n          });\n          tracks[variantLabel] = track;\n        }\n      };\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        _loop2(variantLabel);\n      }\n    };\n\n    for (var groupId in mediaGroups[type]) {\n      _loop(groupId);\n    } // setup single error event handler for the segment loader\n\n\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n\n  /**\n   * Setup PlaylistLoaders and TextTracks for the subtitle groups\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.SUBTITLES\n   */\n  'SUBTITLES': function SUBTITLES(type, settings) {\n    var tech = settings.tech,\n        vhs = settings.vhs,\n        sourceType = settings.sourceType,\n        segmentLoader = settings.segmentLoaders[type],\n        requestOptions = settings.requestOptions,\n        mediaGroups = settings.master.mediaGroups,\n        _settings$mediaTypes$2 = settings.mediaTypes[type],\n        groups = _settings$mediaTypes$2.groups,\n        tracks = _settings$mediaTypes$2.tracks,\n        masterPlaylistLoader = settings.masterPlaylistLoader;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        if (mediaGroups[type][groupId][variantLabel].forced) {\n          // Subtitle playlists with the forced attribute are not selectable in Safari.\n          // According to Apple's HLS Authoring Specification:\n          //   If content has forced subtitles and regular subtitles in a given language,\n          //   the regular subtitles track in that language MUST contain both the forced\n          //   subtitles and the regular subtitles for that language.\n          // Because of this requirement and that Safari does not add forced subtitles,\n          // forced subtitles are skipped here to maintain consistent experience across\n          // all platforms\n          continue;\n        }\n\n        var properties = mediaGroups[type][groupId][variantLabel];\n        var playlistLoader = void 0;\n\n        if (sourceType === 'hls') {\n          playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);\n        } else if (sourceType === 'dash') {\n          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);\n        } else if (sourceType === 'vhs-json') {\n          playlistLoader = new PlaylistLoader( // if the vhs-json object included the media playlist, use the media playlist\n          // as provided, otherwise use the resolved URI to load the playlist\n          properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);\n        }\n\n        properties = videojs$1.mergeOptions({\n          id: variantLabel,\n          playlistLoader: playlistLoader\n        }, properties);\n        setupListeners[type](type, properties.playlistLoader, settings);\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: variantLabel,\n            kind: 'subtitles',\n            \"default\": properties[\"default\"] && properties.autoselect,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n          tracks[variantLabel] = track;\n        }\n      }\n    } // setup single error event handler for the segment loader\n\n\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n\n  /**\n   * Setup TextTracks for the closed-caption groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize['CLOSED-CAPTIONS']\n   */\n  'CLOSED-CAPTIONS': function CLOSEDCAPTIONS(type, settings) {\n    var tech = settings.tech,\n        mediaGroups = settings.master.mediaGroups,\n        _settings$mediaTypes$3 = settings.mediaTypes[type],\n        groups = _settings$mediaTypes$3.groups,\n        tracks = _settings$mediaTypes$3.tracks;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel]; // We only support CEA608 captions for now, so ignore anything that\n        // doesn't use a CCx INSTREAM-ID\n\n        if (!properties.instreamId.match(/CC\\d/)) {\n          continue;\n        } // No PlaylistLoader is required for Closed-Captions because the captions are\n        // embedded within the video stream\n\n\n        groups[groupId].push(videojs$1.mergeOptions({\n          id: variantLabel\n        }, properties));\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: properties.instreamId,\n            kind: 'captions',\n            \"default\": properties[\"default\"] && properties.autoselect,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n  }\n};\n/**\n * Returns a function used to get the active group of the provided type\n *\n * @param {string} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Function that returns the active media group for the provided type. Takes an\n *         optional parameter {TextTrack} track. If no track is provided, a list of all\n *         variants in the group, otherwise the variant corresponding to the provided\n *         track is returned.\n * @function activeGroup\n */\n\nvar activeGroup = function activeGroup(type, settings) {\n  return function (track) {\n    var masterPlaylistLoader = settings.masterPlaylistLoader,\n        groups = settings.mediaTypes[type].groups;\n    var media = masterPlaylistLoader.media();\n\n    if (!media) {\n      return null;\n    }\n\n    var variants = null;\n\n    if (media.attributes[type]) {\n      variants = groups[media.attributes[type]];\n    }\n\n    variants = variants || groups.main;\n\n    if (typeof track === 'undefined') {\n      return variants;\n    }\n\n    if (track === null) {\n      // An active track was specified so a corresponding group is expected. track === null\n      // means no track is currently active so there is no corresponding group\n      return null;\n    }\n\n    return variants.filter(function (props) {\n      return props.id === track.id;\n    })[0] || null;\n  };\n};\n\nvar activeTrack = {\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].enabled) {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  },\n\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].mode === 'showing' || tracks[id].mode === 'hidden') {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  }\n};\n/**\n * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n * Closed-Captions) specified in the master manifest.\n *\n * @param {Object} settings\n *        Object containing required information for setting up the media groups\n * @param {Tech} settings.tech\n *        The tech of the player\n * @param {Object} settings.requestOptions\n *        XHR request options used by the segment loaders\n * @param {PlaylistLoader} settings.masterPlaylistLoader\n *        PlaylistLoader for the master source\n * @param {VhsHandler} settings.vhs\n *        VHS SourceHandler\n * @param {Object} settings.master\n *        The parsed master manifest\n * @param {Object} settings.mediaTypes\n *        Object to store the loaders, tracks, and utility methods for each media type\n * @param {Function} settings.blacklistCurrentPlaylist\n *        Blacklists the current rendition and forces a rendition switch.\n * @function setupMediaGroups\n */\n\nvar setupMediaGroups = function setupMediaGroups(settings) {\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    initialize[type](type, settings);\n  });\n  var mediaTypes = settings.mediaTypes,\n      masterPlaylistLoader = settings.masterPlaylistLoader,\n      tech = settings.tech,\n      vhs = settings.vhs; // setup active group and track getters and change event handlers\n\n  ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n    mediaTypes[type].activeGroup = activeGroup(type, settings);\n    mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n    mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n    mediaTypes[type].onGroupChanging = onGroupChanging(type, settings);\n    mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n  }); // DO NOT enable the default subtitle or caption track.\n  // DO enable the default audio track\n\n  var audioGroup = mediaTypes.AUDIO.activeGroup();\n\n  if (audioGroup) {\n    var groupId = (audioGroup.filter(function (group) {\n      return group[\"default\"];\n    })[0] || audioGroup[0]).id;\n    mediaTypes.AUDIO.tracks[groupId].enabled = true;\n    mediaTypes.AUDIO.onTrackChanged();\n  }\n\n  masterPlaylistLoader.on('mediachange', function () {\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n      return mediaTypes[type].onGroupChanged();\n    });\n  });\n  masterPlaylistLoader.on('mediachanging', function () {\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n      return mediaTypes[type].onGroupChanging();\n    });\n  }); // custom audio track change event handler for usage event\n\n  var onAudioTrackChanged = function onAudioTrackChanged() {\n    mediaTypes.AUDIO.onTrackChanged();\n    tech.trigger({\n      type: 'usage',\n      name: 'vhs-audio-change'\n    });\n    tech.trigger({\n      type: 'usage',\n      name: 'hls-audio-change'\n    });\n  };\n\n  tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n  tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n  vhs.on('dispose', function () {\n    tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n    tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n  }); // clear existing audio tracks and add the ones we just created\n\n  tech.clearTracks('audio');\n\n  for (var id in mediaTypes.AUDIO.tracks) {\n    tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n  }\n};\n/**\n * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n * media type\n *\n * @return {Object}\n *         Object to store the loaders, tracks, and utility methods for each media type\n * @function createMediaTypes\n */\n\n\nvar createMediaTypes = function createMediaTypes() {\n  var mediaTypes = {};\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    mediaTypes[type] = {\n      groups: {},\n      tracks: {},\n      activePlaylistLoader: null,\n      activeGroup: noop,\n      activeTrack: noop,\n      onGroupChanged: noop,\n      onTrackChanged: noop\n    };\n  });\n  return mediaTypes;\n};\n\nvar ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;\nvar Vhs; // SegmentLoader stats that need to have each loader's\n// values summed to calculate the final value\n\nvar loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred'];\n\nvar sumLoaderStat = function sumLoaderStat(stat) {\n  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n};\n\nvar shouldSwitchToMedia = function shouldSwitchToMedia(_ref) {\n  var currentPlaylist = _ref.currentPlaylist,\n      nextPlaylist = _ref.nextPlaylist,\n      forwardBuffer = _ref.forwardBuffer,\n      bufferLowWaterLine = _ref.bufferLowWaterLine,\n      duration = _ref.duration,\n      log = _ref.log; // we have no other playlist to switch to\n\n  if (!nextPlaylist) {\n    videojs$1.log.warn('We received no playlist to switch to. Please check your stream.');\n    return false;\n  } // If the playlist is live, then we want to not take low water line into account.\n  // This is because in LIVE, the player plays 3 segments from the end of the\n  // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n  // in those segments, a viewer will never experience a rendition upswitch.\n\n\n  if (!currentPlaylist.endList) {\n    return true;\n  } // For the same reason as LIVE, we ignore the low water line when the VOD\n  // duration is below the max potential low water line\n\n\n  if (duration < Config.MAX_BUFFER_LOW_WATER_LINE) {\n    return true;\n  } // we want to switch down to lower resolutions quickly to continue playback, but\n\n\n  if (nextPlaylist.attributes.BANDWIDTH < currentPlaylist.attributes.BANDWIDTH) {\n    return true;\n  } // ensure we have some buffer before we switch up to prevent us running out of\n  // buffer while loading a higher rendition.\n\n\n  if (forwardBuffer >= bufferLowWaterLine) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * the master playlist controller controller all interactons\n * between playlists and segmentloaders. At this time this mainly\n * involves a master playlist and a series of audio playlists\n * if they are available\n *\n * @class MasterPlaylistController\n * @extends videojs.EventTarget\n */\n\n\nvar MasterPlaylistController = /*#__PURE__*/function (_videojs$EventTarget) {\n  _inheritsLoose(MasterPlaylistController, _videojs$EventTarget);\n\n  function MasterPlaylistController(options) {\n    var _this;\n\n    _this = _videojs$EventTarget.call(this) || this;\n    var src = options.src,\n        handleManifestRedirects = options.handleManifestRedirects,\n        withCredentials = options.withCredentials,\n        tech = options.tech,\n        bandwidth = options.bandwidth,\n        externVhs = options.externVhs,\n        useCueTags = options.useCueTags,\n        blacklistDuration = options.blacklistDuration,\n        enableLowInitialPlaylist = options.enableLowInitialPlaylist,\n        sourceType = options.sourceType,\n        cacheEncryptionKeys = options.cacheEncryptionKeys,\n        handlePartialData = options.handlePartialData;\n\n    if (!src) {\n      throw new Error('A non-empty playlist URL or JSON manifest string is required');\n    }\n\n    Vhs = externVhs;\n    _this.withCredentials = withCredentials;\n    _this.tech_ = tech;\n    _this.vhs_ = tech.vhs;\n    _this.sourceType_ = sourceType;\n    _this.useCueTags_ = useCueTags;\n    _this.blacklistDuration = blacklistDuration;\n    _this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n\n    if (_this.useCueTags_) {\n      _this.cueTagsTrack_ = _this.tech_.addTextTrack('metadata', 'ad-cues');\n      _this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n    }\n\n    _this.requestOptions_ = {\n      withCredentials: withCredentials,\n      handleManifestRedirects: handleManifestRedirects,\n      timeout: null\n    };\n\n    _this.on('error', _this.pauseLoading);\n\n    _this.mediaTypes_ = createMediaTypes();\n    _this.mediaSource = new window$1.MediaSource();\n    _this.handleDurationChange_ = _this.handleDurationChange_.bind(_assertThisInitialized(_this));\n    _this.handleSourceOpen_ = _this.handleSourceOpen_.bind(_assertThisInitialized(_this));\n    _this.handleSourceEnded_ = _this.handleSourceEnded_.bind(_assertThisInitialized(_this));\n\n    _this.mediaSource.addEventListener('durationchange', _this.handleDurationChange_); // load the media source into the player\n\n\n    _this.mediaSource.addEventListener('sourceopen', _this.handleSourceOpen_);\n\n    _this.mediaSource.addEventListener('sourceended', _this.handleSourceEnded_); // we don't have to handle sourceclose since dispose will handle termination of\n    // everything, and the MediaSource should not be detached without a proper disposal\n\n\n    _this.seekable_ = videojs$1.createTimeRanges();\n    _this.hasPlayed_ = false;\n    _this.syncController_ = new SyncController(options);\n    _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'segment-metadata'\n    }, false).track;\n    _this.decrypter_ = new Decrypter();\n    _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource);\n    _this.inbandTextTracks_ = {};\n    _this.timelineChangeController_ = new TimelineChangeController();\n    var segmentLoaderSettings = {\n      vhs: _this.vhs_,\n      mediaSource: _this.mediaSource,\n      currentTime: _this.tech_.currentTime.bind(_this.tech_),\n      seekable: function seekable() {\n        return _this.seekable();\n      },\n      seeking: function seeking() {\n        return _this.tech_.seeking();\n      },\n      duration: function duration() {\n        return _this.duration();\n      },\n      hasPlayed: function hasPlayed() {\n        return _this.hasPlayed_;\n      },\n      goalBufferLength: function goalBufferLength() {\n        return _this.goalBufferLength();\n      },\n      bandwidth: bandwidth,\n      syncController: _this.syncController_,\n      decrypter: _this.decrypter_,\n      sourceType: _this.sourceType_,\n      inbandTextTracks: _this.inbandTextTracks_,\n      cacheEncryptionKeys: cacheEncryptionKeys,\n      handlePartialData: handlePartialData,\n      sourceUpdater: _this.sourceUpdater_,\n      timelineChangeController: _this.timelineChangeController_\n    }; // The source type check not only determines whether a special DASH playlist loader\n    // should be used, but also covers the case where the provided src is a vhs-json\n    // manifest object (instead of a URL). In the case of vhs-json, the default\n    // PlaylistLoader should be used.\n\n    _this.masterPlaylistLoader_ = _this.sourceType_ === 'dash' ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader(src, _this.vhs_, _this.requestOptions_);\n\n    _this.setupMasterPlaylistLoaderListeners_(); // setup segment loaders\n    // combined audio/video or just video when alternate audio track is selected\n\n\n    _this.mainSegmentLoader_ = new SegmentLoader(videojs$1.mergeOptions(segmentLoaderSettings, {\n      segmentMetadataTrack: _this.segmentMetadataTrack_,\n      loaderType: 'main'\n    }), options); // alternate audio track\n\n    _this.audioSegmentLoader_ = new SegmentLoader(videojs$1.mergeOptions(segmentLoaderSettings, {\n      loaderType: 'audio'\n    }), options);\n    _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs$1.mergeOptions(segmentLoaderSettings, {\n      loaderType: 'vtt',\n      featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks\n    }), options);\n\n    _this.setupSegmentLoaderListeners_(); // Create SegmentLoader stat-getters\n    // mediaRequests_\n    // mediaRequestsAborted_\n    // mediaRequestsTimedout_\n    // mediaRequestsErrored_\n    // mediaTransferDuration_\n    // mediaBytesTransferred_\n\n\n    loaderStats.forEach(function (stat) {\n      _this[stat + '_'] = sumLoaderStat.bind(_assertThisInitialized(_this), stat);\n    });\n    _this.logger_ = logger('MPC');\n    _this.triggeredFmp4Usage = false;\n\n    _this.masterPlaylistLoader_.load();\n\n    return _this;\n  }\n  /**\n   * Register event handlers on the master playlist loader. A helper\n   * function for construction time.\n   *\n   * @private\n   */\n\n\n  var _proto = MasterPlaylistController.prototype;\n\n  _proto.setupMasterPlaylistLoaderListeners_ = function setupMasterPlaylistLoaderListeners_() {\n    var _this2 = this;\n\n    this.masterPlaylistLoader_.on('loadedmetadata', function () {\n      var media = _this2.masterPlaylistLoader_.media();\n\n      var requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n      // timeout the request.\n\n      if (isLowestEnabledRendition(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n        _this2.requestOptions_.timeout = 0;\n      } else {\n        _this2.requestOptions_.timeout = requestTimeout;\n      } // if this isn't a live video and preload permits, start\n      // downloading segments\n\n\n      if (media.endList && _this2.tech_.preload() !== 'none') {\n        _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n\n        _this2.mainSegmentLoader_.load();\n      }\n\n      setupMediaGroups({\n        sourceType: _this2.sourceType_,\n        segmentLoaders: {\n          AUDIO: _this2.audioSegmentLoader_,\n          SUBTITLES: _this2.subtitleSegmentLoader_,\n          main: _this2.mainSegmentLoader_\n        },\n        tech: _this2.tech_,\n        requestOptions: _this2.requestOptions_,\n        masterPlaylistLoader: _this2.masterPlaylistLoader_,\n        vhs: _this2.vhs_,\n        master: _this2.master(),\n        mediaTypes: _this2.mediaTypes_,\n        blacklistCurrentPlaylist: _this2.blacklistCurrentPlaylist.bind(_this2)\n      });\n\n      _this2.triggerPresenceUsage_(_this2.master(), media);\n\n      _this2.setupFirstPlay();\n\n      if (!_this2.mediaTypes_.AUDIO.activePlaylistLoader || _this2.mediaTypes_.AUDIO.activePlaylistLoader.media()) {\n        _this2.trigger('selectedinitialmedia');\n      } else {\n        // We must wait for the active audio playlist loader to\n        // finish setting up before triggering this event so the\n        // representations API and EME setup is correct\n        _this2.mediaTypes_.AUDIO.activePlaylistLoader.one('loadedmetadata', function () {\n          _this2.trigger('selectedinitialmedia');\n        });\n      }\n    });\n    this.masterPlaylistLoader_.on('loadedplaylist', function () {\n      var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n\n      if (!updatedPlaylist) {\n        // exclude any variants that are not supported by the browser before selecting\n        // an initial media as the playlist selectors do not consider browser support\n        _this2.excludeUnsupportedVariants_();\n\n        var selectedMedia;\n\n        if (_this2.enableLowInitialPlaylist) {\n          selectedMedia = _this2.selectInitialPlaylist();\n        }\n\n        if (!selectedMedia) {\n          selectedMedia = _this2.selectPlaylist();\n        }\n\n        _this2.initialMedia_ = selectedMedia;\n\n        _this2.masterPlaylistLoader_.media(_this2.initialMedia_); // Under the standard case where a source URL is provided, loadedplaylist will\n        // fire again since the playlist will be requested. In the case of vhs-json\n        // (where the manifest object is provided as the source), when the media\n        // playlist's `segments` list is already available, a media playlist won't be\n        // requested, and loadedplaylist won't fire again, so the playlist handler must be\n        // called on its own here.\n\n\n        var haveJsonSource = _this2.sourceType_ === 'vhs-json' && _this2.initialMedia_.segments;\n\n        if (!haveJsonSource) {\n          return;\n        }\n\n        updatedPlaylist = _this2.initialMedia_;\n      }\n\n      _this2.handleUpdatedMediaPlaylist(updatedPlaylist);\n    });\n    this.masterPlaylistLoader_.on('error', function () {\n      _this2.blacklistCurrentPlaylist(_this2.masterPlaylistLoader_.error);\n    });\n    this.masterPlaylistLoader_.on('mediachanging', function () {\n      _this2.mainSegmentLoader_.abort();\n\n      _this2.mainSegmentLoader_.pause();\n    });\n    this.masterPlaylistLoader_.on('mediachange', function () {\n      var media = _this2.masterPlaylistLoader_.media();\n\n      var requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n      // timeout the request.\n\n      if (isLowestEnabledRendition(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n        _this2.requestOptions_.timeout = 0;\n      } else {\n        _this2.requestOptions_.timeout = requestTimeout;\n      } // TODO: Create a new event on the PlaylistLoader that signals\n      // that the segments have changed in some way and use that to\n      // update the SegmentLoader instead of doing it twice here and\n      // on `loadedplaylist`\n\n\n      _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n\n      _this2.mainSegmentLoader_.load();\n\n      _this2.tech_.trigger({\n        type: 'mediachange',\n        bubbles: true\n      });\n    });\n    this.masterPlaylistLoader_.on('playlistunchanged', function () {\n      var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n\n      var playlistOutdated = _this2.stuckAtPlaylistEnd_(updatedPlaylist);\n\n      if (playlistOutdated) {\n        // Playlist has stopped updating and we're stuck at its end. Try to\n        // blacklist it and switch to another playlist in the hope that that\n        // one is updating (and give the player a chance to re-adjust to the\n        // safe live point).\n        _this2.blacklistCurrentPlaylist({\n          message: 'Playlist no longer updating.'\n        }); // useful for monitoring QoS\n\n\n        _this2.tech_.trigger('playliststuck');\n      }\n    });\n    this.masterPlaylistLoader_.on('renditiondisabled', function () {\n      _this2.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-rendition-disabled'\n      });\n\n      _this2.tech_.trigger({\n        type: 'usage',\n        name: 'hls-rendition-disabled'\n      });\n    });\n    this.masterPlaylistLoader_.on('renditionenabled', function () {\n      _this2.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-rendition-enabled'\n      });\n\n      _this2.tech_.trigger({\n        type: 'usage',\n        name: 'hls-rendition-enabled'\n      });\n    });\n  }\n  /**\n   * Given an updated media playlist (whether it was loaded for the first time, or\n   * refreshed for live playlists), update any relevant properties and state to reflect\n   * changes in the media that should be accounted for (e.g., cues and duration).\n   *\n   * @param {Object} updatedPlaylist the updated media playlist object\n   *\n   * @private\n   */\n  ;\n\n  _proto.handleUpdatedMediaPlaylist = function handleUpdatedMediaPlaylist(updatedPlaylist) {\n    if (this.useCueTags_) {\n      this.updateAdCues_(updatedPlaylist);\n    } // TODO: Create a new event on the PlaylistLoader that signals\n    // that the segments have changed in some way and use that to\n    // update the SegmentLoader instead of doing it twice here and\n    // on `mediachange`\n\n\n    this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);\n    this.updateDuration(!updatedPlaylist.endList); // If the player isn't paused, ensure that the segment loader is running,\n    // as it is possible that it was temporarily stopped while waiting for\n    // a playlist (e.g., in case the playlist errored and we re-requested it).\n\n    if (!this.tech_.paused()) {\n      this.mainSegmentLoader_.load();\n\n      if (this.audioSegmentLoader_) {\n        this.audioSegmentLoader_.load();\n      }\n    }\n  }\n  /**\n   * A helper function for triggerring presence usage events once per source\n   *\n   * @private\n   */\n  ;\n\n  _proto.triggerPresenceUsage_ = function triggerPresenceUsage_(master, media) {\n    var mediaGroups = master.mediaGroups || {};\n    var defaultDemuxed = true;\n    var audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n\n    for (var mediaGroup in mediaGroups.AUDIO) {\n      for (var label in mediaGroups.AUDIO[mediaGroup]) {\n        var properties = mediaGroups.AUDIO[mediaGroup][label];\n\n        if (!properties.uri) {\n          defaultDemuxed = false;\n        }\n      }\n    }\n\n    if (defaultDemuxed) {\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-demuxed'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-demuxed'\n      });\n    }\n\n    if (Object.keys(mediaGroups.SUBTITLES).length) {\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-webvtt'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-webvtt'\n      });\n    }\n\n    if (Vhs.Playlist.isAes(media)) {\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-aes'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-aes'\n      });\n    }\n\n    if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-alternate-audio'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-alternate-audio'\n      });\n    }\n\n    if (this.useCueTags_) {\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-playlist-cue-tags'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-playlist-cue-tags'\n      });\n    }\n  }\n  /**\n   * Register event handlers on the segment loaders. A helper function\n   * for construction time.\n   *\n   * @private\n   */\n  ;\n\n  _proto.setupSegmentLoaderListeners_ = function setupSegmentLoaderListeners_() {\n    var _this3 = this;\n\n    this.mainSegmentLoader_.on('bandwidthupdate', function () {\n      var nextPlaylist = _this3.selectPlaylist();\n\n      var currentPlaylist = _this3.masterPlaylistLoader_.media();\n\n      var buffered = _this3.tech_.buffered();\n\n      var forwardBuffer = buffered.length ? buffered.end(buffered.length - 1) - _this3.tech_.currentTime() : 0;\n\n      var bufferLowWaterLine = _this3.bufferLowWaterLine();\n\n      if (shouldSwitchToMedia({\n        currentPlaylist: currentPlaylist,\n        nextPlaylist: nextPlaylist,\n        forwardBuffer: forwardBuffer,\n        bufferLowWaterLine: bufferLowWaterLine,\n        duration: _this3.duration(),\n        log: _this3.logger_\n      })) {\n        _this3.masterPlaylistLoader_.media(nextPlaylist);\n      }\n\n      _this3.tech_.trigger('bandwidthupdate');\n    });\n    this.mainSegmentLoader_.on('progress', function () {\n      _this3.trigger('progress');\n    });\n    this.mainSegmentLoader_.on('error', function () {\n      _this3.blacklistCurrentPlaylist(_this3.mainSegmentLoader_.error());\n    });\n    this.mainSegmentLoader_.on('appenderror', function () {\n      _this3.error = _this3.mainSegmentLoader_.error_;\n\n      _this3.trigger('error');\n    });\n    this.mainSegmentLoader_.on('syncinfoupdate', function () {\n      _this3.onSyncInfoUpdate_();\n    });\n    this.mainSegmentLoader_.on('timestampoffset', function () {\n      _this3.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-timestamp-offset'\n      });\n\n      _this3.tech_.trigger({\n        type: 'usage',\n        name: 'hls-timestamp-offset'\n      });\n    });\n    this.audioSegmentLoader_.on('syncinfoupdate', function () {\n      _this3.onSyncInfoUpdate_();\n    });\n    this.audioSegmentLoader_.on('appenderror', function () {\n      _this3.error = _this3.audioSegmentLoader_.error_;\n\n      _this3.trigger('error');\n    });\n    this.mainSegmentLoader_.on('ended', function () {\n      _this3.logger_('main segment loader ended');\n\n      _this3.onEndOfStream();\n    });\n    this.mainSegmentLoader_.on('earlyabort', function () {\n      _this3.blacklistCurrentPlaylist({\n        message: 'Aborted early because there isn\\'t enough bandwidth to complete the ' + 'request without rebuffering.'\n      }, ABORT_EARLY_BLACKLIST_SECONDS);\n    });\n\n    var updateCodecs = function updateCodecs() {\n      if (!_this3.sourceUpdater_.ready()) {\n        return _this3.tryToCreateSourceBuffers_();\n      }\n\n      var codecs = _this3.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n\n      if (!codecs) {\n        return;\n      }\n\n      _this3.sourceUpdater_.addOrChangeSourceBuffers(codecs);\n    };\n\n    this.mainSegmentLoader_.on('trackinfo', updateCodecs);\n    this.audioSegmentLoader_.on('trackinfo', updateCodecs);\n    this.mainSegmentLoader_.on('fmp4', function () {\n      if (!_this3.triggeredFmp4Usage) {\n        _this3.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-fmp4'\n        });\n\n        _this3.tech_.trigger({\n          type: 'usage',\n          name: 'hls-fmp4'\n        });\n\n        _this3.triggeredFmp4Usage = true;\n      }\n    });\n    this.audioSegmentLoader_.on('fmp4', function () {\n      if (!_this3.triggeredFmp4Usage) {\n        _this3.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-fmp4'\n        });\n\n        _this3.tech_.trigger({\n          type: 'usage',\n          name: 'hls-fmp4'\n        });\n\n        _this3.triggeredFmp4Usage = true;\n      }\n    });\n    this.audioSegmentLoader_.on('ended', function () {\n      _this3.logger_('audioSegmentLoader ended');\n\n      _this3.onEndOfStream();\n    });\n  };\n\n  _proto.mediaSecondsLoaded_ = function mediaSecondsLoaded_() {\n    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n  }\n  /**\n   * Call load on our SegmentLoaders\n   */\n  ;\n\n  _proto.load = function load() {\n    this.mainSegmentLoader_.load();\n\n    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n      this.audioSegmentLoader_.load();\n    }\n\n    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n      this.subtitleSegmentLoader_.load();\n    }\n  }\n  /**\n   * Re-tune playback quality level for the current player\n   * conditions without performing destructive actions, like\n   * removing already buffered content\n   *\n   * @private\n   */\n  ;\n\n  _proto.smoothQualityChange_ = function smoothQualityChange_(media) {\n    if (media === void 0) {\n      media = this.selectPlaylist();\n    }\n\n    if (media === this.masterPlaylistLoader_.media()) {\n      return;\n    }\n\n    this.masterPlaylistLoader_.media(media);\n    this.mainSegmentLoader_.resetLoader(); // don't need to reset audio as it is reset when media changes\n  }\n  /**\n   * Re-tune playback quality level for the current player\n   * conditions. This method will perform destructive actions like removing\n   * already buffered content in order to readjust the currently active\n   * playlist quickly. This is good for manual quality changes\n   *\n   * @private\n   */\n  ;\n\n  _proto.fastQualityChange_ = function fastQualityChange_(media) {\n    var _this4 = this;\n\n    if (media === void 0) {\n      media = this.selectPlaylist();\n    }\n\n    if (media === this.masterPlaylistLoader_.media()) {\n      return;\n    }\n\n    this.masterPlaylistLoader_.media(media); // Delete all buffered data to allow an immediate quality switch, then seek to give\n    // the browser a kick to remove any cached frames from the previous rendtion (.04 seconds\n    // ahead is roughly the minimum that will accomplish this across a variety of content\n    // in IE and Edge, but seeking in place is sufficient on all other browsers)\n    // Edge/IE bug: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14600375/\n    // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=651904\n\n    this.mainSegmentLoader_.resetEverything(function () {\n      // Since this is not a typical seek, we avoid the seekTo method which can cause segments\n      // from the previously enabled rendition to load before the new playlist has finished loading\n      if (videojs$1.browser.IE_VERSION || videojs$1.browser.IS_EDGE) {\n        _this4.tech_.setCurrentTime(_this4.tech_.currentTime() + 0.04);\n      } else {\n        _this4.tech_.setCurrentTime(_this4.tech_.currentTime());\n      }\n    }); // don't need to reset audio as it is reset when media changes\n  }\n  /**\n   * Begin playback.\n   */\n  ;\n\n  _proto.play = function play() {\n    if (this.setupFirstPlay()) {\n      return;\n    }\n\n    if (this.tech_.ended()) {\n      this.tech_.setCurrentTime(0);\n    }\n\n    if (this.hasPlayed_) {\n      this.load();\n    }\n\n    var seekable = this.tech_.seekable(); // if the viewer has paused and we fell out of the live window,\n    // seek forward to the live point\n\n    if (this.tech_.duration() === Infinity) {\n      if (this.tech_.currentTime() < seekable.start(0)) {\n        return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\n      }\n    }\n  }\n  /**\n   * Seek to the latest media position if this is a live video and the\n   * player and video are loaded and initialized.\n   */\n  ;\n\n  _proto.setupFirstPlay = function setupFirstPlay() {\n    var _this5 = this;\n\n    var media = this.masterPlaylistLoader_.media(); // Check that everything is ready to begin buffering for the first call to play\n    //  If 1) there is no active media\n    //     2) the player is paused\n    //     3) the first play has already been setup\n    // then exit early\n\n    if (!media || this.tech_.paused() || this.hasPlayed_) {\n      return false;\n    } // when the video is a live stream\n\n\n    if (!media.endList) {\n      var seekable = this.seekable();\n\n      if (!seekable.length) {\n        // without a seekable range, the player cannot seek to begin buffering at the live\n        // point\n        return false;\n      }\n\n      if (videojs$1.browser.IE_VERSION && this.tech_.readyState() === 0) {\n        // IE11 throws an InvalidStateError if you try to set currentTime while the\n        // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\n        this.tech_.one('loadedmetadata', function () {\n          _this5.trigger('firstplay');\n\n          _this5.tech_.setCurrentTime(seekable.end(0));\n\n          _this5.hasPlayed_ = true;\n        });\n        return false;\n      } // trigger firstplay to inform the source handler to ignore the next seek event\n\n\n      this.trigger('firstplay'); // seek to the live point\n\n      this.tech_.setCurrentTime(seekable.end(0));\n    }\n\n    this.hasPlayed_ = true; // we can begin loading now that everything is ready\n\n    this.load();\n    return true;\n  }\n  /**\n   * handle the sourceopen event on the MediaSource\n   *\n   * @private\n   */\n  ;\n\n  _proto.handleSourceOpen_ = function handleSourceOpen_() {\n    // Only attempt to create the source buffer if none already exist.\n    // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n    // after `endOfStream` has been called (in response to a seek for instance)\n    this.tryToCreateSourceBuffers_(); // if autoplay is enabled, begin playback. This is duplicative of\n    // code in video.js but is required because play() must be invoked\n    // *after* the media source has opened.\n\n    if (this.tech_.autoplay()) {\n      var playPromise = this.tech_.play(); // Catch/silence error when a pause interrupts a play request\n      // on browsers which return a promise\n\n      if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n        playPromise.then(null, function (e) {});\n      }\n    }\n\n    this.trigger('sourceopen');\n  }\n  /**\n   * handle the sourceended event on the MediaSource\n   *\n   * @private\n   */\n  ;\n\n  _proto.handleSourceEnded_ = function handleSourceEnded_() {\n    if (!this.inbandTextTracks_.metadataTrack_) {\n      return;\n    }\n\n    var cues = this.inbandTextTracks_.metadataTrack_.cues;\n\n    if (!cues || !cues.length) {\n      return;\n    }\n\n    var duration = this.duration();\n    cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === Infinity ? Number.MAX_VALUE : duration;\n  }\n  /**\n   * handle the durationchange event on the MediaSource\n   *\n   * @private\n   */\n  ;\n\n  _proto.handleDurationChange_ = function handleDurationChange_() {\n    this.tech_.trigger('durationchange');\n  }\n  /**\n   * Calls endOfStream on the media source when all active stream types have called\n   * endOfStream\n   *\n   * @param {string} streamType\n   *        Stream type of the segment loader that called endOfStream\n   * @private\n   */\n  ;\n\n  _proto.onEndOfStream = function onEndOfStream() {\n    var isEndOfStream = this.mainSegmentLoader_.ended_;\n\n    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n      // if the audio playlist loader exists, then alternate audio is active\n      if (!this.mainSegmentLoader_.currentMediaInfo_ || this.mainSegmentLoader_.currentMediaInfo_.hasVideo) {\n        // if we do not know if the main segment loader contains video yet or if we\n        // definitively know the main segment loader contains video, then we need to wait\n        // for both main and audio segment loaders to call endOfStream\n        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n      } else {\n        // otherwise just rely on the audio loader\n        isEndOfStream = this.audioSegmentLoader_.ended_;\n      }\n    }\n\n    if (!isEndOfStream) {\n      return;\n    }\n\n    this.sourceUpdater_.endOfStream();\n  }\n  /**\n   * Check if a playlist has stopped being updated\n   *\n   * @param {Object} playlist the media playlist object\n   * @return {boolean} whether the playlist has stopped being updated or not\n   */\n  ;\n\n  _proto.stuckAtPlaylistEnd_ = function stuckAtPlaylistEnd_(playlist) {\n    var seekable = this.seekable();\n\n    if (!seekable.length) {\n      // playlist doesn't have enough information to determine whether we are stuck\n      return false;\n    }\n\n    var expired = this.syncController_.getExpiredTime(playlist, this.duration());\n\n    if (expired === null) {\n      return false;\n    } // does not use the safe live end to calculate playlist end, since we\n    // don't want to say we are stuck while there is still content\n\n\n    var absolutePlaylistEnd = Vhs.Playlist.playlistEnd(playlist, expired);\n    var currentTime = this.tech_.currentTime();\n    var buffered = this.tech_.buffered();\n\n    if (!buffered.length) {\n      // return true if the playhead reached the absolute end of the playlist\n      return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;\n    }\n\n    var bufferedEnd = buffered.end(buffered.length - 1); // return true if there is too little buffer left and buffer has reached absolute\n    // end of playlist\n\n    return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;\n  }\n  /**\n   * Blacklists a playlist when an error occurs for a set amount of time\n   * making it unavailable for selection by the rendition selection algorithm\n   * and then forces a new playlist (rendition) selection.\n   *\n   * @param {Object=} error an optional error that may include the playlist\n   * to blacklist\n   * @param {number=} blacklistDuration an optional number of seconds to blacklist the\n   * playlist\n   */\n  ;\n\n  _proto.blacklistCurrentPlaylist = function blacklistCurrentPlaylist(error, blacklistDuration) {\n    if (error === void 0) {\n      error = {};\n    } // If the `error` was generated by the playlist loader, it will contain\n    // the playlist we were trying to load (but failed) and that should be\n    // blacklisted instead of the currently selected playlist which is likely\n    // out-of-date in this scenario\n\n\n    var currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\n    blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration; // If there is no current playlist, then an error occurred while we were\n    // trying to load the master OR while we were disposing of the tech\n\n    if (!currentPlaylist) {\n      this.error = error;\n\n      if (this.mediaSource.readyState !== 'open') {\n        this.trigger('error');\n      } else {\n        this.sourceUpdater_.endOfStream('network');\n      }\n\n      return;\n    }\n\n    var playlists = this.masterPlaylistLoader_.master.playlists;\n    var enabledPlaylists = playlists.filter(isEnabled);\n    var isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === currentPlaylist; // Don't blacklist the only playlist unless it was blacklisted\n    // forever\n\n    if (playlists.length === 1 && blacklistDuration !== Infinity) {\n      videojs$1.log.warn(\"Problem encountered with playlist \" + currentPlaylist.id + \". \" + 'Trying again since it is the only playlist.');\n      this.tech_.trigger('retryplaylist');\n      return this.masterPlaylistLoader_.load(isFinalRendition);\n    }\n\n    if (isFinalRendition) {\n      // Since we're on the final non-blacklisted playlist, and we're about to blacklist\n      // it, instead of erring the player or retrying this playlist, clear out the current\n      // blacklist. This allows other playlists to be attempted in case any have been\n      // fixed.\n      var reincluded = false;\n      playlists.forEach(function (playlist) {\n        // skip current playlist which is about to be blacklisted\n        if (playlist === currentPlaylist) {\n          return;\n        }\n\n        var excludeUntil = playlist.excludeUntil; // a playlist cannot be reincluded if it wasn't excluded to begin with.\n\n        if (typeof excludeUntil !== 'undefined' && excludeUntil !== Infinity) {\n          reincluded = true;\n          delete playlist.excludeUntil;\n        }\n      });\n\n      if (reincluded) {\n        videojs$1.log.warn('Removing other playlists from the exclusion list because the last ' + 'rendition is about to be excluded.'); // Technically we are retrying a playlist, in that we are simply retrying a previous\n        // playlist. This is needed for users relying on the retryplaylist event to catch a\n        // case where the player might be stuck and looping through \"dead\" playlists.\n\n        this.tech_.trigger('retryplaylist');\n      }\n    } // Blacklist this playlist\n\n\n    currentPlaylist.excludeUntil = Date.now() + blacklistDuration * 1000;\n    this.tech_.trigger('blacklistplaylist');\n    this.tech_.trigger({\n      type: 'usage',\n      name: 'vhs-rendition-blacklisted'\n    });\n    this.tech_.trigger({\n      type: 'usage',\n      name: 'hls-rendition-blacklisted'\n    }); // TODO: should we select a new playlist if this blacklist wasn't for the currentPlaylist?\n    // Would be something like media().id !=== currentPlaylist.id and we  would need something\n    // like `pendingMedia` in playlist loaders to check against that too. This will prevent us\n    // from loading a new playlist on any blacklist.\n    // Select a new playlist\n\n    var nextPlaylist = this.selectPlaylist();\n\n    if (!nextPlaylist) {\n      this.error = 'Playback cannot continue. No available working or supported playlists.';\n      this.trigger('error');\n      return;\n    }\n\n    var logFn = error.internal ? this.logger_ : videojs$1.log.warn;\n    var errorMessage = error.message ? ' ' + error.message : '';\n    logFn((error.internal ? 'Internal problem' : 'Problem') + \" encountered with playlist \" + currentPlaylist.id + \".\" + (errorMessage + \" Switching to playlist \" + nextPlaylist.id + \".\")); // if audio group changed reset audio loaders\n\n    if (nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO) {\n      this.delegateLoaders_('audio', ['abort', 'pause']);\n    } // if subtitle group changed reset subtitle loaders\n\n\n    if (nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES) {\n      this.delegateLoaders_('subtitle', ['abort', 'pause']);\n    }\n\n    this.delegateLoaders_('main', ['abort', 'pause']);\n    return this.masterPlaylistLoader_.media(nextPlaylist, isFinalRendition);\n  }\n  /**\n   * Pause all segment/playlist loaders\n   */\n  ;\n\n  _proto.pauseLoading = function pauseLoading() {\n    this.delegateLoaders_('all', ['abort', 'pause']);\n  }\n  /**\n   * Call a set of functions in order on playlist loaders, segment loaders,\n   * or both types of loaders.\n   *\n   * @param {string} filter\n   *        Filter loaders that should call fnNames using a string. Can be:\n   *        * all - run on all loaders\n   *        * audio - run on all audio loaders\n   *        * subtitle - run on all subtitle loaders\n   *        * main - run on the main/master loaders\n   *\n   * @param {Array|string} fnNames\n   *        A string or array of function names to call.\n   */\n  ;\n\n  _proto.delegateLoaders_ = function delegateLoaders_(filter, fnNames) {\n    var _this6 = this;\n\n    var loaders = [];\n    var dontFilterPlaylist = filter === 'all';\n\n    if (dontFilterPlaylist || filter === 'main') {\n      loaders.push(this.masterPlaylistLoader_);\n    }\n\n    var mediaTypes = [];\n\n    if (dontFilterPlaylist || filter === 'audio') {\n      mediaTypes.push('AUDIO');\n    }\n\n    if (dontFilterPlaylist || filter === 'subtitle') {\n      mediaTypes.push('CLOSED-CAPTIONS');\n      mediaTypes.push('SUBTITLES');\n    }\n\n    mediaTypes.forEach(function (mediaType) {\n      var loader = _this6.mediaTypes_[mediaType] && _this6.mediaTypes_[mediaType].activePlaylistLoader;\n\n      if (loader) {\n        loaders.push(loader);\n      }\n    });\n    ['main', 'audio', 'subtitle'].forEach(function (name) {\n      var loader = _this6[name + \"SegmentLoader_\"];\n\n      if (loader && (filter === name || filter === 'all')) {\n        loaders.push(loader);\n      }\n    });\n    loaders.forEach(function (loader) {\n      return fnNames.forEach(function (fnName) {\n        if (typeof loader[fnName] === 'function') {\n          loader[fnName]();\n        }\n      });\n    });\n  }\n  /**\n   * set the current time on all segment loaders\n   *\n   * @param {TimeRange} currentTime the current time to set\n   * @return {TimeRange} the current time\n   */\n  ;\n\n  _proto.setCurrentTime = function setCurrentTime(currentTime) {\n    var buffered = findRange(this.tech_.buffered(), currentTime);\n\n    if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\n      // return immediately if the metadata is not ready yet\n      return 0;\n    } // it's clearly an edge-case but don't thrown an error if asked to\n    // seek within an empty playlist\n\n\n    if (!this.masterPlaylistLoader_.media().segments) {\n      return 0;\n    } // if the seek location is already buffered, continue buffering as usual\n\n\n    if (buffered && buffered.length) {\n      return currentTime;\n    } // cancel outstanding requests so we begin buffering at the new\n    // location\n\n\n    this.mainSegmentLoader_.resetEverything();\n    this.mainSegmentLoader_.abort();\n\n    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n      this.audioSegmentLoader_.resetEverything();\n      this.audioSegmentLoader_.abort();\n    }\n\n    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n      this.subtitleSegmentLoader_.resetEverything();\n      this.subtitleSegmentLoader_.abort();\n    } // start segment loader loading in case they are paused\n\n\n    this.load();\n  }\n  /**\n   * get the current duration\n   *\n   * @return {TimeRange} the duration\n   */\n  ;\n\n  _proto.duration = function duration() {\n    if (!this.masterPlaylistLoader_) {\n      return 0;\n    }\n\n    var media = this.masterPlaylistLoader_.media();\n\n    if (!media) {\n      // no playlists loaded yet, so can't determine a duration\n      return 0;\n    } // Don't rely on the media source for duration in the case of a live playlist since\n    // setting the native MediaSource's duration to infinity ends up with consequences to\n    // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n    //\n    // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n    // however, few browsers have support for setLiveSeekableRange()\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n    //\n    // Until a time when the duration of the media source can be set to infinity, and a\n    // seekable range specified across browsers, just return Infinity.\n\n\n    if (!media.endList) {\n      return Infinity;\n    } // Since this is a VOD video, it is safe to rely on the media source's duration (if\n    // available). If it's not available, fall back to a playlist-calculated estimate.\n\n\n    if (this.mediaSource) {\n      return this.mediaSource.duration;\n    }\n\n    return Vhs.Playlist.duration(media);\n  }\n  /**\n   * check the seekable range\n   *\n   * @return {TimeRange} the seekable range\n   */\n  ;\n\n  _proto.seekable = function seekable() {\n    return this.seekable_;\n  };\n\n  _proto.onSyncInfoUpdate_ = function onSyncInfoUpdate_() {\n    var audioSeekable;\n\n    if (!this.masterPlaylistLoader_) {\n      return;\n    }\n\n    var media = this.masterPlaylistLoader_.media();\n\n    if (!media) {\n      return;\n    }\n\n    var expired = this.syncController_.getExpiredTime(media, this.duration());\n\n    if (expired === null) {\n      // not enough information to update seekable\n      return;\n    }\n\n    var suggestedPresentationDelay = this.masterPlaylistLoader_.master.suggestedPresentationDelay;\n    var mainSeekable = Vhs.Playlist.seekable(media, expired, suggestedPresentationDelay);\n\n    if (mainSeekable.length === 0) {\n      return;\n    }\n\n    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n      media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n      expired = this.syncController_.getExpiredTime(media, this.duration());\n\n      if (expired === null) {\n        return;\n      }\n\n      audioSeekable = Vhs.Playlist.seekable(media, expired, suggestedPresentationDelay);\n\n      if (audioSeekable.length === 0) {\n        return;\n      }\n    }\n\n    var oldEnd;\n    var oldStart;\n\n    if (this.seekable_ && this.seekable_.length) {\n      oldEnd = this.seekable_.end(0);\n      oldStart = this.seekable_.start(0);\n    }\n\n    if (!audioSeekable) {\n      // seekable has been calculated based on buffering video data so it\n      // can be returned directly\n      this.seekable_ = mainSeekable;\n    } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n      // seekables are pretty far off, rely on main\n      this.seekable_ = mainSeekable;\n    } else {\n      this.seekable_ = videojs$1.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n    } // seekable is the same as last time\n\n\n    if (this.seekable_ && this.seekable_.length) {\n      if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {\n        return;\n      }\n    }\n\n    this.logger_(\"seekable updated [\" + printableRange(this.seekable_) + \"]\");\n    this.tech_.trigger('seekablechanged');\n  }\n  /**\n   * Update the player duration\n   */\n  ;\n\n  _proto.updateDuration = function updateDuration(isLive) {\n    if (this.updateDuration_) {\n      this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n      this.updateDuration_ = null;\n    }\n\n    if (this.mediaSource.readyState !== 'open') {\n      this.updateDuration_ = this.updateDuration.bind(this, isLive);\n      this.mediaSource.addEventListener('sourceopen', this.updateDuration_);\n      return;\n    }\n\n    if (isLive) {\n      var seekable = this.seekable();\n\n      if (!seekable.length) {\n        return;\n      } // Even in the case of a live playlist, the native MediaSource's duration should not\n      // be set to Infinity (even though this would be expected for a live playlist), since\n      // setting the native MediaSource's duration to infinity ends up with consequences to\n      // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n      //\n      // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n      // however, few browsers have support for setLiveSeekableRange()\n      // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n      //\n      // Until a time when the duration of the media source can be set to infinity, and a\n      // seekable range specified across browsers, the duration should be greater than or\n      // equal to the last possible seekable value.\n      // MediaSource duration starts as NaN\n      // It is possible (and probable) that this case will never be reached for many\n      // sources, since the MediaSource reports duration as the highest value without\n      // accounting for timestamp offset. For example, if the timestamp offset is -100 and\n      // we buffered times 0 to 100 with real times of 100 to 200, even though current\n      // time will be between 0 and 100, the native media source may report the duration\n      // as 200. However, since we report duration separate from the media source (as\n      // Infinity), and as long as the native media source duration value is greater than\n      // our reported seekable range, seeks will work as expected. The large number as\n      // duration for live is actually a strategy used by some players to work around the\n      // issue of live seekable ranges cited above.\n\n\n      if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) {\n        this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));\n      }\n\n      return;\n    }\n\n    var buffered = this.tech_.buffered();\n    var duration = Vhs.Playlist.duration(this.masterPlaylistLoader_.media());\n\n    if (buffered.length > 0) {\n      duration = Math.max(duration, buffered.end(buffered.length - 1));\n    }\n\n    if (this.mediaSource.duration !== duration) {\n      this.sourceUpdater_.setDuration(duration);\n    }\n  }\n  /**\n   * dispose of the MasterPlaylistController and everything\n   * that it controls\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    var _this7 = this;\n\n    this.trigger('dispose');\n    this.decrypter_.terminate();\n    this.masterPlaylistLoader_.dispose();\n    this.mainSegmentLoader_.dispose();\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n      var groups = _this7.mediaTypes_[type].groups;\n\n      for (var id in groups) {\n        groups[id].forEach(function (group) {\n          if (group.playlistLoader) {\n            group.playlistLoader.dispose();\n          }\n        });\n      }\n    });\n    this.audioSegmentLoader_.dispose();\n    this.subtitleSegmentLoader_.dispose();\n    this.sourceUpdater_.dispose();\n    this.timelineChangeController_.dispose();\n\n    if (this.updateDuration_) {\n      this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n    }\n\n    this.mediaSource.removeEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\n\n    this.mediaSource.removeEventListener('sourceopen', this.handleSourceOpen_);\n    this.mediaSource.removeEventListener('sourceended', this.handleSourceEnded_);\n    this.off();\n  }\n  /**\n   * return the master playlist object if we have one\n   *\n   * @return {Object} the master playlist object that we parsed\n   */\n  ;\n\n  _proto.master = function master() {\n    return this.masterPlaylistLoader_.master;\n  }\n  /**\n   * return the currently selected playlist\n   *\n   * @return {Object} the currently selected playlist object that we parsed\n   */\n  ;\n\n  _proto.media = function media() {\n    // playlist loader will not return media if it has not been fully loaded\n    return this.masterPlaylistLoader_.media() || this.initialMedia_;\n  };\n\n  _proto.areMediaTypesKnown_ = function areMediaTypesKnown_() {\n    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader; // one or both loaders has not loaded sufficently to get codecs\n\n    if (!this.mainSegmentLoader_.currentMediaInfo_ || usingAudioLoader && !this.audioSegmentLoader_.currentMediaInfo_) {\n      return false;\n    }\n\n    return true;\n  };\n\n  _proto.getCodecsOrExclude_ = function getCodecsOrExclude_() {\n    var _this8 = this;\n\n    var media = {\n      main: this.mainSegmentLoader_.currentMediaInfo_ || {},\n      audio: this.audioSegmentLoader_.currentMediaInfo_ || {}\n    }; // set \"main\" media equal to video\n\n    media.video = media.main;\n    var playlistCodecs = codecsForPlaylist(this.master(), this.media());\n    var codecs = {};\n    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\n\n    if (media.main.hasVideo) {\n      codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;\n    }\n\n    if (media.main.isMuxed) {\n      codecs.video += \",\" + (playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC);\n    }\n\n    if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {\n      codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC; // set audio isFmp4 so we use the correct \"supports\" function below\n\n      media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;\n    } // no codecs, no playback.\n\n\n    if (!codecs.audio && !codecs.video) {\n      this.blacklistCurrentPlaylist({\n        playlist: this.media(),\n        message: 'Could not determine codecs for playlist.',\n        blacklistDuration: Infinity\n      });\n      return;\n    } // fmp4 relies on browser support, while ts relies on muxer support\n\n\n    var supportFunction = function supportFunction(isFmp4, codec) {\n      return isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);\n    };\n\n    var unsupportedCodecs = {};\n    var unsupportedAudio;\n    ['video', 'audio'].forEach(function (type) {\n      if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {\n        var supporter = media[type].isFmp4 ? 'browser' : 'muxer';\n        unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];\n        unsupportedCodecs[supporter].push(codecs[type]);\n\n        if (type === 'audio') {\n          unsupportedAudio = supporter;\n        }\n      }\n    });\n\n    if (usingAudioLoader && unsupportedAudio && this.media().attributes.AUDIO) {\n      var audioGroup = this.media().attributes.AUDIO;\n      this.master().playlists.forEach(function (variant) {\n        var variantAudioGroup = variant.attributes && variant.attributes.AUDIO;\n\n        if (variantAudioGroup === audioGroup && variant !== _this8.media()) {\n          variant.excludeUntil = Infinity;\n        }\n      });\n      this.logger_(\"excluding audio group \" + audioGroup + \" as \" + unsupportedAudio + \" does not support codec(s): \\\"\" + codecs.audio + \"\\\"\");\n    } // if we have any unsupported codecs blacklist this playlist.\n\n\n    if (Object.keys(unsupportedCodecs).length) {\n      var message = Object.keys(unsupportedCodecs).reduce(function (acc, supporter) {\n        if (acc) {\n          acc += ', ';\n        }\n\n        acc += supporter + \" does not support codec(s): \\\"\" + unsupportedCodecs[supporter].join(',') + \"\\\"\";\n        return acc;\n      }, '') + '.';\n      this.blacklistCurrentPlaylist({\n        playlist: this.media(),\n        internal: true,\n        message: message,\n        blacklistDuration: Infinity\n      });\n      return;\n    } // check if codec switching is happening\n\n\n    if (this.sourceUpdater_.ready() && !this.sourceUpdater_.canChangeType()) {\n      var switchMessages = [];\n      ['video', 'audio'].forEach(function (type) {\n        var newCodec = (parseCodecs(_this8.sourceUpdater_.codecs[type] || '')[type] || {}).type;\n        var oldCodec = (parseCodecs(codecs[type] || '')[type] || {}).type;\n\n        if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {\n          switchMessages.push(\"\\\"\" + _this8.sourceUpdater_.codecs[type] + \"\\\" -> \\\"\" + codecs[type] + \"\\\"\");\n        }\n      });\n\n      if (switchMessages.length) {\n        this.blacklistCurrentPlaylist({\n          playlist: this.media(),\n          message: \"Codec switching not supported: \" + switchMessages.join(', ') + \".\",\n          blacklistDuration: Infinity,\n          internal: true\n        });\n        return;\n      }\n    } // TODO: when using the muxer shouldn't we just return\n    // the codecs that the muxer outputs?\n\n\n    return codecs;\n  }\n  /**\n   * Create source buffers and exlude any incompatible renditions.\n   *\n   * @private\n   */\n  ;\n\n  _proto.tryToCreateSourceBuffers_ = function tryToCreateSourceBuffers_() {\n    // media source is not ready yet or sourceBuffers are already\n    // created.\n    if (this.mediaSource.readyState !== 'open' || this.sourceUpdater_.ready()) {\n      return;\n    }\n\n    if (!this.areMediaTypesKnown_()) {\n      return;\n    }\n\n    var codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n    if (!codecs) {\n      return;\n    }\n\n    this.sourceUpdater_.createSourceBuffers(codecs);\n    var codecString = [codecs.video, codecs.audio].filter(Boolean).join(',');\n    this.excludeIncompatibleVariants_(codecString);\n  }\n  /**\n   * Excludes playlists with codecs that are unsupported by the muxer and browser.\n   */\n  ;\n\n  _proto.excludeUnsupportedVariants_ = function excludeUnsupportedVariants_() {\n    var _this9 = this;\n\n    this.master().playlists.forEach(function (variant) {\n      var codecs = codecsForPlaylist(_this9.master, variant);\n\n      if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {\n        variant.excludeUntil = Infinity;\n      }\n\n      if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {\n        variant.excludeUntil = Infinity;\n      }\n    });\n  }\n  /**\n   * Blacklist playlists that are known to be codec or\n   * stream-incompatible with the SourceBuffer configuration. For\n   * instance, Media Source Extensions would cause the video element to\n   * stall waiting for video data if you switched from a variant with\n   * video and audio to an audio-only one.\n   *\n   * @param {Object} media a media playlist compatible with the current\n   * set of SourceBuffers. Variants in the current master playlist that\n   * do not appear to have compatible codec or stream configurations\n   * will be excluded from the default playlist selection algorithm\n   * indefinitely.\n   * @private\n   */\n  ;\n\n  _proto.excludeIncompatibleVariants_ = function excludeIncompatibleVariants_(codecString) {\n    var _this10 = this;\n\n    var codecs = parseCodecs(codecString);\n    var codecCount = Object.keys(codecs).length;\n    this.master().playlists.forEach(function (variant) {\n      // skip variants that are already blacklisted forever\n      if (variant.excludeUntil === Infinity) {\n        return;\n      }\n      /* TODO: Decide whether two codecs should be assumed here.\n       * Right now, for playlists that don't specify codecs, VHS assumes\n       * that there are two (one for audio and one for video).\n       * Although this is often the case, this may lead to broken behavior\n       * if the playlist only has one codec. It may be better in the future\n       * to decide at time of segment download how many tracks there are and\n       * determine the proper codecs. This will come at a cost of potentially\n       * more bandwidth, but will be a more robust approach than the assumption here.\n       */\n\n\n      var variantCodecs = {};\n      var variantCodecCount = 2;\n      var blacklistReasons = []; // get codecs from the playlist for this variant\n\n      var variantCodecStrings = codecsForPlaylist(_this10.masterPlaylistLoader_.master, variant);\n\n      if (variantCodecStrings.audio || variantCodecStrings.video) {\n        var variantCodecString = [variantCodecStrings.video, variantCodecStrings.audio].filter(Boolean).join(',');\n        variantCodecs = parseCodecs(variantCodecString);\n        variantCodecCount = Object.keys(variantCodecs).length;\n      } // TODO: we can support this by removing the\n      // old media source and creating a new one, but it will take some work.\n      // The number of streams cannot change\n\n\n      if (variantCodecCount !== codecCount) {\n        blacklistReasons.push(\"codec count \\\"\" + variantCodecCount + \"\\\" !== \\\"\" + codecCount + \"\\\"\");\n        variant.excludeUntil = Infinity;\n      } // only exclude playlists by codec change, if codecs cannot switch\n      // during playback.\n\n\n      if (!_this10.sourceUpdater_.canChangeType()) {\n        // the video codec cannot change\n        if (variantCodecs.video && codecs.video && variantCodecs.video.type.toLowerCase() !== codecs.video.type.toLowerCase()) {\n          blacklistReasons.push(\"video codec \\\"\" + variantCodecs.video.type + \"\\\" !== \\\"\" + codecs.video.type + \"\\\"\");\n          variant.excludeUntil = Infinity;\n        } // the audio codec cannot change\n\n\n        if (variantCodecs.audio && codecs.audio && variantCodecs.audio.type.toLowerCase() !== codecs.audio.type.toLowerCase()) {\n          variant.excludeUntil = Infinity;\n          blacklistReasons.push(\"audio codec \\\"\" + variantCodecs.audio.type + \"\\\" !== \\\"\" + codecs.audio.type + \"\\\"\");\n        }\n      }\n\n      if (blacklistReasons.length) {\n        _this10.logger_(\"blacklisting \" + variant.id + \": \" + blacklistReasons.join(' && '));\n      }\n    });\n  };\n\n  _proto.updateAdCues_ = function updateAdCues_(media) {\n    var offset = 0;\n    var seekable = this.seekable();\n\n    if (seekable.length) {\n      offset = seekable.start(0);\n    }\n\n    updateAdCues(media, this.cueTagsTrack_, offset);\n  }\n  /**\n   * Calculates the desired forward buffer length based on current time\n   *\n   * @return {number} Desired forward buffer length in seconds\n   */\n  ;\n\n  _proto.goalBufferLength = function goalBufferLength() {\n    var currentTime = this.tech_.currentTime();\n    var initial = Config.GOAL_BUFFER_LENGTH;\n    var rate = Config.GOAL_BUFFER_LENGTH_RATE;\n    var max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);\n    return Math.min(initial + currentTime * rate, max);\n  }\n  /**\n   * Calculates the desired buffer low water line based on current time\n   *\n   * @return {number} Desired buffer low water line in seconds\n   */\n  ;\n\n  _proto.bufferLowWaterLine = function bufferLowWaterLine() {\n    var currentTime = this.tech_.currentTime();\n    var initial = Config.BUFFER_LOW_WATER_LINE;\n    var rate = Config.BUFFER_LOW_WATER_LINE_RATE;\n    var max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);\n    return Math.min(initial + currentTime * rate, max);\n  };\n\n  return MasterPlaylistController;\n}(videojs$1.EventTarget);\n/**\n * Returns a function that acts as the Enable/disable playlist function.\n *\n * @param {PlaylistLoader} loader - The master playlist loader\n * @param {string} playlistID - id of the playlist\n * @param {Function} changePlaylistFn - A function to be called after a\n * playlist's enabled-state has been changed. Will NOT be called if a\n * playlist's enabled-state is unchanged\n * @param {boolean=} enable - Value to set the playlist enabled-state to\n * or if undefined returns the current enabled-state for the playlist\n * @return {Function} Function for setting/getting enabled\n */\n\n\nvar enableFunction = function enableFunction(loader, playlistID, changePlaylistFn) {\n  return function (enable) {\n    var playlist = loader.master.playlists[playlistID];\n    var incompatible = isIncompatible(playlist);\n    var currentlyEnabled = isEnabled(playlist);\n\n    if (typeof enable === 'undefined') {\n      return currentlyEnabled;\n    }\n\n    if (enable) {\n      delete playlist.disabled;\n    } else {\n      playlist.disabled = true;\n    }\n\n    if (enable !== currentlyEnabled && !incompatible) {\n      // Ensure the outside world knows about our changes\n      changePlaylistFn();\n\n      if (enable) {\n        loader.trigger('renditionenabled');\n      } else {\n        loader.trigger('renditiondisabled');\n      }\n    }\n\n    return enable;\n  };\n};\n/**\n * The representation object encapsulates the publicly visible information\n * in a media playlist along with a setter/getter-type function (enabled)\n * for changing the enabled-state of a particular playlist entry\n *\n * @class Representation\n */\n\n\nvar Representation = function Representation(vhsHandler, playlist, id) {\n  var mpc = vhsHandler.masterPlaylistController_,\n      smoothQualityChange = vhsHandler.options_.smoothQualityChange; // Get a reference to a bound version of the quality change function\n\n  var changeType = smoothQualityChange ? 'smooth' : 'fast';\n  var qualityChangeFunction = mpc[changeType + \"QualityChange_\"].bind(mpc); // some playlist attributes are optional\n\n  if (playlist.attributes.RESOLUTION) {\n    var resolution = playlist.attributes.RESOLUTION;\n    this.width = resolution.width;\n    this.height = resolution.height;\n  }\n\n  this.bandwidth = playlist.attributes.BANDWIDTH;\n  this.codecs = codecsForPlaylist(mpc.master(), playlist);\n  this.playlist = playlist; // The id is simply the ordinality of the media playlist\n  // within the master playlist\n\n  this.id = id; // Partially-apply the enableFunction to create a playlist-\n  // specific variant\n\n  this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);\n};\n/**\n * A mixin function that adds the `representations` api to an instance\n * of the VhsHandler class\n *\n * @param {VhsHandler} vhsHandler - An instance of VhsHandler to add the\n * representation API into\n */\n\n\nvar renditionSelectionMixin = function renditionSelectionMixin(vhsHandler) {\n  var playlists = vhsHandler.playlists; // Add a single API-specific function to the VhsHandler instance\n\n  vhsHandler.representations = function () {\n    if (!playlists || !playlists.master || !playlists.master.playlists) {\n      return [];\n    }\n\n    return playlists.master.playlists.filter(function (media) {\n      return !isIncompatible(media);\n    }).map(function (e, i) {\n      return new Representation(vhsHandler, e, e.id);\n    });\n  };\n};\n/**\n * @file playback-watcher.js\n *\n * Playback starts, and now my watch begins. It shall not end until my death. I shall\n * take no wait, hold no uncleared timeouts, father no bad seeks. I shall wear no crowns\n * and win no glory. I shall live and die at my post. I am the corrector of the underflow.\n * I am the watcher of gaps. I am the shield that guards the realms of seekable. I pledge\n * my life and honor to the Playback Watch, for this Player and all the Players to come.\n */\n\n\nvar timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\n/**\n * Returns whether or not the current time should be considered close to buffered content,\n * taking into consideration whether there's enough buffered content for proper playback.\n *\n * @param {Object} options\n *        Options object\n * @param {TimeRange} options.buffered\n *        Current buffer\n * @param {number} options.targetDuration\n *        The active playlist's target duration\n * @param {number} options.currentTime\n *        The current time of the player\n * @return {boolean}\n *         Whether the current time should be considered close to the buffer\n */\n\nvar closeToBufferedContent = function closeToBufferedContent(_ref) {\n  var buffered = _ref.buffered,\n      targetDuration = _ref.targetDuration,\n      currentTime = _ref.currentTime;\n\n  if (!buffered.length) {\n    return false;\n  } // At least two to three segments worth of content should be buffered before there's a\n  // full enough buffer to consider taking any actions.\n\n\n  if (buffered.end(0) - buffered.start(0) < targetDuration * 2) {\n    return false;\n  } // It's possible that, on seek, a remove hasn't completed and the buffered range is\n  // somewhere past the current time. In that event, don't consider the buffered content\n  // close.\n\n\n  if (currentTime > buffered.start(0)) {\n    return false;\n  } // Since target duration generally represents the max (or close to max) duration of a\n  // segment, if the buffer is within a segment of the current time, the gap probably\n  // won't be closed, and current time should be considered close to buffered content.\n\n\n  return buffered.start(0) - currentTime < targetDuration;\n};\n/**\n * @class PlaybackWatcher\n */\n\n\nvar PlaybackWatcher = /*#__PURE__*/function () {\n  /**\n   * Represents an PlaybackWatcher object.\n   *\n   * @class\n   * @param {Object} options an object that includes the tech and settings\n   */\n  function PlaybackWatcher(options) {\n    var _this = this;\n\n    this.masterPlaylistController_ = options.masterPlaylistController;\n    this.tech_ = options.tech;\n    this.seekable = options.seekable;\n    this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;\n    this.media = options.media;\n    this.consecutiveUpdates = 0;\n    this.lastRecordedTime = null;\n    this.timer_ = null;\n    this.checkCurrentTimeTimeout_ = null;\n    this.logger_ = logger('PlaybackWatcher');\n    this.logger_('initialize');\n\n    var canPlayHandler = function canPlayHandler() {\n      return _this.monitorCurrentTime_();\n    };\n\n    var waitingHandler = function waitingHandler() {\n      return _this.techWaiting_();\n    };\n\n    var cancelTimerHandler = function cancelTimerHandler() {\n      return _this.cancelTimer_();\n    };\n\n    var fixesBadSeeksHandler = function fixesBadSeeksHandler() {\n      return _this.fixesBadSeeks_();\n    };\n\n    var mpc = this.masterPlaylistController_;\n    var loaderTypes = ['main', 'subtitle', 'audio'];\n    var loaderChecks = {};\n    loaderTypes.forEach(function (type) {\n      loaderChecks[type] = {\n        reset: function reset() {\n          return _this.resetSegmentDownloads_(type);\n        },\n        updateend: function updateend() {\n          return _this.checkSegmentDownloads_(type);\n        }\n      };\n      mpc[type + \"SegmentLoader_\"].on('appendsdone', loaderChecks[type].updateend); // If a rendition switch happens during a playback stall where the buffer\n      // isn't changing we want to reset. We cannot assume that the new rendition\n      // will also be stalled, until after new appends.\n\n      mpc[type + \"SegmentLoader_\"].on('playlistupdate', loaderChecks[type].reset); // Playback stalls should not be detected right after seeking.\n      // This prevents one segment playlists (single vtt or single segment content)\n      // from being detected as stalling. As the buffer will not change in those cases, since\n      // the buffer is the entire video duration.\n\n      _this.tech_.on(['seeked', 'seeking'], loaderChecks[type].reset);\n    });\n    this.tech_.on('seekablechanged', fixesBadSeeksHandler);\n    this.tech_.on('waiting', waitingHandler);\n    this.tech_.on(timerCancelEvents, cancelTimerHandler);\n    this.tech_.on('canplay', canPlayHandler); // Define the dispose function to clean up our events\n\n    this.dispose = function () {\n      _this.logger_('dispose');\n\n      _this.tech_.off('seekablechanged', fixesBadSeeksHandler);\n\n      _this.tech_.off('waiting', waitingHandler);\n\n      _this.tech_.off(timerCancelEvents, cancelTimerHandler);\n\n      _this.tech_.off('canplay', canPlayHandler);\n\n      loaderTypes.forEach(function (type) {\n        mpc[type + \"SegmentLoader_\"].off('appendsdone', loaderChecks[type].updateend);\n        mpc[type + \"SegmentLoader_\"].off('playlistupdate', loaderChecks[type].reset);\n\n        _this.tech_.off(['seeked', 'seeking'], loaderChecks[type].reset);\n      });\n\n      if (_this.checkCurrentTimeTimeout_) {\n        window$1.clearTimeout(_this.checkCurrentTimeTimeout_);\n      }\n\n      _this.cancelTimer_();\n    };\n  }\n  /**\n   * Periodically check current time to see if playback stopped\n   *\n   * @private\n   */\n\n\n  var _proto = PlaybackWatcher.prototype;\n\n  _proto.monitorCurrentTime_ = function monitorCurrentTime_() {\n    this.checkCurrentTime_();\n\n    if (this.checkCurrentTimeTimeout_) {\n      window$1.clearTimeout(this.checkCurrentTimeTimeout_);\n    } // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n\n\n    this.checkCurrentTimeTimeout_ = window$1.setTimeout(this.monitorCurrentTime_.bind(this), 250);\n  }\n  /**\n   * Reset stalled download stats for a specific type of loader\n   *\n   * @param {string} type\n   *        The segment loader type to check.\n   *\n   * @listens SegmentLoader#playlistupdate\n   * @listens Tech#seeking\n   * @listens Tech#seeked\n   */\n  ;\n\n  _proto.resetSegmentDownloads_ = function resetSegmentDownloads_(type) {\n    var loader = this.masterPlaylistController_[type + \"SegmentLoader_\"];\n\n    if (this[type + \"StalledDownloads_\"] > 0) {\n      this.logger_(\"resetting possible stalled download count for \" + type + \" loader\");\n    }\n\n    this[type + \"StalledDownloads_\"] = 0;\n    this[type + \"Buffered_\"] = loader.buffered_();\n  }\n  /**\n   * Checks on every segment `appendsdone` to see\n   * if segment appends are making progress. If they are not\n   * and we are still downloading bytes. We blacklist the playlist.\n   *\n   * @param {string} type\n   *        The segment loader type to check.\n   *\n   * @listens SegmentLoader#appendsdone\n   */\n  ;\n\n  _proto.checkSegmentDownloads_ = function checkSegmentDownloads_(type) {\n    var mpc = this.masterPlaylistController_;\n    var loader = mpc[type + \"SegmentLoader_\"];\n    var buffered = loader.buffered_();\n    var isBufferedDifferent = isRangeDifferent(this[type + \"Buffered_\"], buffered);\n    this[type + \"Buffered_\"] = buffered; // if another watcher is going to fix the issue or\n    // the buffered value for this loader changed\n    // appends are working\n\n    if (isBufferedDifferent) {\n      this.resetSegmentDownloads_(type);\n      return;\n    }\n\n    this[type + \"StalledDownloads_\"]++;\n    this.logger_(\"found #\" + this[type + \"StalledDownloads_\"] + \" \" + type + \" appends that did not increase buffer (possible stalled download)\", {\n      playlistId: loader.playlist_ && loader.playlist_.id,\n      buffered: timeRangesToArray(buffered)\n    }); // after 10 possibly stalled appends with no reset, exclude\n\n    if (this[type + \"StalledDownloads_\"] < 10) {\n      return;\n    }\n\n    this.logger_(type + \" loader stalled download exclusion\");\n    this.resetSegmentDownloads_(type);\n    this.tech_.trigger({\n      type: 'usage',\n      name: \"vhs-\" + type + \"-download-exclusion\"\n    });\n\n    if (type === 'subtitle') {\n      return;\n    } // TODO: should we exclude audio tracks rather than main tracks\n    // when type is audio?\n\n\n    mpc.blacklistCurrentPlaylist({\n      message: \"Excessive \" + type + \" segment downloading detected.\"\n    }, Infinity);\n  }\n  /**\n   * The purpose of this function is to emulate the \"waiting\" event on\n   * browsers that do not emit it when they are waiting for more\n   * data to continue playback\n   *\n   * @private\n   */\n  ;\n\n  _proto.checkCurrentTime_ = function checkCurrentTime_() {\n    if (this.tech_.seeking() && this.fixesBadSeeks_()) {\n      this.consecutiveUpdates = 0;\n      this.lastRecordedTime = this.tech_.currentTime();\n      return;\n    }\n\n    if (this.tech_.paused() || this.tech_.seeking()) {\n      return;\n    }\n\n    var currentTime = this.tech_.currentTime();\n    var buffered = this.tech_.buffered();\n\n    if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {\n      // If current time is at the end of the final buffered region, then any playback\n      // stall is most likely caused by buffering in a low bandwidth environment. The tech\n      // should fire a `waiting` event in this scenario, but due to browser and tech\n      // inconsistencies. Calling `techWaiting_` here allows us to simulate\n      // responding to a native `waiting` event when the tech fails to emit one.\n      return this.techWaiting_();\n    }\n\n    if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {\n      this.consecutiveUpdates++;\n      this.waiting_();\n    } else if (currentTime === this.lastRecordedTime) {\n      this.consecutiveUpdates++;\n    } else {\n      this.consecutiveUpdates = 0;\n      this.lastRecordedTime = currentTime;\n    }\n  }\n  /**\n   * Cancels any pending timers and resets the 'timeupdate' mechanism\n   * designed to detect that we are stalled\n   *\n   * @private\n   */\n  ;\n\n  _proto.cancelTimer_ = function cancelTimer_() {\n    this.consecutiveUpdates = 0;\n\n    if (this.timer_) {\n      this.logger_('cancelTimer_');\n      clearTimeout(this.timer_);\n    }\n\n    this.timer_ = null;\n  }\n  /**\n   * Fixes situations where there's a bad seek\n   *\n   * @return {boolean} whether an action was taken to fix the seek\n   * @private\n   */\n  ;\n\n  _proto.fixesBadSeeks_ = function fixesBadSeeks_() {\n    var seeking = this.tech_.seeking();\n\n    if (!seeking) {\n      return false;\n    }\n\n    var seekable = this.seekable();\n    var currentTime = this.tech_.currentTime();\n    var isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);\n    var seekTo;\n\n    if (isAfterSeekableRange) {\n      var seekableEnd = seekable.end(seekable.length - 1); // sync to live point (if VOD, our seekable was updated and we're simply adjusting)\n\n      seekTo = seekableEnd;\n    }\n\n    if (this.beforeSeekableWindow_(seekable, currentTime)) {\n      var seekableStart = seekable.start(0); // sync to the beginning of the live window\n      // provide a buffer of .1 seconds to handle rounding/imprecise numbers\n\n      seekTo = seekableStart + ( // if the playlist is too short and the seekable range is an exact time (can\n      // happen in live with a 3 segment playlist), then don't use a time delta\n      seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);\n    }\n\n    if (typeof seekTo !== 'undefined') {\n      this.logger_(\"Trying to seek outside of seekable at time \" + currentTime + \" with \" + (\"seekable range \" + printableRange(seekable) + \". Seeking to \") + (seekTo + \".\"));\n      this.tech_.setCurrentTime(seekTo);\n      return true;\n    }\n\n    var buffered = this.tech_.buffered();\n\n    if (closeToBufferedContent({\n      buffered: buffered,\n      targetDuration: this.media().targetDuration,\n      currentTime: currentTime\n    })) {\n      seekTo = buffered.start(0) + SAFE_TIME_DELTA;\n      this.logger_(\"Buffered region starts (\" + buffered.start(0) + \") \" + (\" just beyond seek point (\" + currentTime + \"). Seeking to \" + seekTo + \".\"));\n      this.tech_.setCurrentTime(seekTo);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Handler for situations when we determine the player is waiting.\n   *\n   * @private\n   */\n  ;\n\n  _proto.waiting_ = function waiting_() {\n    if (this.techWaiting_()) {\n      return;\n    } // All tech waiting checks failed. Use last resort correction\n\n\n    var currentTime = this.tech_.currentTime();\n    var buffered = this.tech_.buffered();\n    var currentRange = findRange(buffered, currentTime); // Sometimes the player can stall for unknown reasons within a contiguous buffered\n    // region with no indication that anything is amiss (seen in Firefox). Seeking to\n    // currentTime is usually enough to kickstart the player. This checks that the player\n    // is currently within a buffered region before attempting a corrective seek.\n    // Chrome does not appear to continue `timeupdate` events after a `waiting` event\n    // until there is ~ 3 seconds of forward buffer available. PlaybackWatcher should also\n    // make sure there is ~3 seconds of forward buffer before taking any corrective action\n    // to avoid triggering an `unknownwaiting` event when the network is slow.\n\n    if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {\n      this.cancelTimer_();\n      this.tech_.setCurrentTime(currentTime);\n      this.logger_(\"Stopped at \" + currentTime + \" while inside a buffered region \" + (\"[\" + currentRange.start(0) + \" -> \" + currentRange.end(0) + \"]. Attempting to resume \") + 'playback by seeking to the current time.'); // unknown waiting corrections may be useful for monitoring QoS\n\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-unknown-waiting'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-unknown-waiting'\n      });\n      return;\n    }\n  }\n  /**\n   * Handler for situations when the tech fires a `waiting` event\n   *\n   * @return {boolean}\n   *         True if an action (or none) was needed to correct the waiting. False if no\n   *         checks passed\n   * @private\n   */\n  ;\n\n  _proto.techWaiting_ = function techWaiting_() {\n    var seekable = this.seekable();\n    var currentTime = this.tech_.currentTime();\n\n    if (this.tech_.seeking() && this.fixesBadSeeks_()) {\n      // Tech is seeking or bad seek fixed, no action needed\n      return true;\n    }\n\n    if (this.tech_.seeking() || this.timer_ !== null) {\n      // Tech is seeking or already waiting on another action, no action needed\n      return true;\n    }\n\n    if (this.beforeSeekableWindow_(seekable, currentTime)) {\n      var livePoint = seekable.end(seekable.length - 1);\n      this.logger_(\"Fell out of live window at time \" + currentTime + \". Seeking to \" + (\"live point (seekable end) \" + livePoint));\n      this.cancelTimer_();\n      this.tech_.setCurrentTime(livePoint); // live window resyncs may be useful for monitoring QoS\n\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-live-resync'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-live-resync'\n      });\n      return true;\n    }\n\n    var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_;\n    var buffered = this.tech_.buffered();\n    var videoUnderflow = this.videoUnderflow_({\n      audioBuffered: sourceUpdater.audioBuffered(),\n      videoBuffered: sourceUpdater.videoBuffered(),\n      currentTime: currentTime\n    });\n\n    if (videoUnderflow) {\n      // Even though the video underflowed and was stuck in a gap, the audio overplayed\n      // the gap, leading currentTime into a buffered range. Seeking to currentTime\n      // allows the video to catch up to the audio position without losing any audio\n      // (only suffering ~3 seconds of frozen video and a pause in audio playback).\n      this.cancelTimer_();\n      this.tech_.setCurrentTime(currentTime); // video underflow may be useful for monitoring QoS\n\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-video-underflow'\n      });\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-video-underflow'\n      });\n      return true;\n    }\n\n    var nextRange = findNextRange(buffered, currentTime); // check for gap\n\n    if (nextRange.length > 0) {\n      var difference = nextRange.start(0) - currentTime;\n      this.logger_(\"Stopped at \" + currentTime + \", setting timer for \" + difference + \", seeking \" + (\"to \" + nextRange.start(0)));\n      this.cancelTimer_();\n      this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1000, currentTime);\n      return true;\n    } // All checks failed. Returning false to indicate failure to correct waiting\n\n\n    return false;\n  };\n\n  _proto.afterSeekableWindow_ = function afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {\n    if (allowSeeksWithinUnsafeLiveWindow === void 0) {\n      allowSeeksWithinUnsafeLiveWindow = false;\n    }\n\n    if (!seekable.length) {\n      // we can't make a solid case if there's no seekable, default to false\n      return false;\n    }\n\n    var allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;\n    var isLive = !playlist.endList;\n\n    if (isLive && allowSeeksWithinUnsafeLiveWindow) {\n      allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;\n    }\n\n    if (currentTime > allowedEnd) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.beforeSeekableWindow_ = function beforeSeekableWindow_(seekable, currentTime) {\n    if (seekable.length && // can't fall before 0 and 0 seekable start identifies VOD stream\n    seekable.start(0) > 0 && currentTime < seekable.start(0) - SAFE_TIME_DELTA) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.videoUnderflow_ = function videoUnderflow_(_ref2) {\n    var videoBuffered = _ref2.videoBuffered,\n        audioBuffered = _ref2.audioBuffered,\n        currentTime = _ref2.currentTime; // audio only content will not have video underflow :)\n\n    if (!videoBuffered) {\n      return;\n    }\n\n    var gap; // find a gap in demuxed content.\n\n    if (videoBuffered.length && audioBuffered.length) {\n      // in Chrome audio will continue to play for ~3s when we run out of video\n      // so we have to check that the video buffer did have some buffer in the\n      // past.\n      var lastVideoRange = findRange(videoBuffered, currentTime - 3);\n      var videoRange = findRange(videoBuffered, currentTime);\n      var audioRange = findRange(audioBuffered, currentTime);\n\n      if (audioRange.length && !videoRange.length && lastVideoRange.length) {\n        gap = {\n          start: lastVideoRange.end(0),\n          end: audioRange.end(0)\n        };\n      } // find a gap in muxed content.\n\n    } else {\n      var nextRange = findNextRange(videoBuffered, currentTime); // Even if there is no available next range, there is still a possibility we are\n      // stuck in a gap due to video underflow.\n\n      if (!nextRange.length) {\n        gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);\n      }\n    }\n\n    if (gap) {\n      this.logger_(\"Encountered a gap in video from \" + gap.start + \" to \" + gap.end + \". \" + (\"Seeking to current time \" + currentTime));\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Timer callback. If playback still has not proceeded, then we seek\n   * to the start of the next buffered region.\n   *\n   * @private\n   */\n  ;\n\n  _proto.skipTheGap_ = function skipTheGap_(scheduledCurrentTime) {\n    var buffered = this.tech_.buffered();\n    var currentTime = this.tech_.currentTime();\n    var nextRange = findNextRange(buffered, currentTime);\n    this.cancelTimer_();\n\n    if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\n      return;\n    }\n\n    this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0)); // only seek if we still have not played\n\n    this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);\n    this.tech_.trigger({\n      type: 'usage',\n      name: 'vhs-gap-skip'\n    });\n    this.tech_.trigger({\n      type: 'usage',\n      name: 'hls-gap-skip'\n    });\n  };\n\n  _proto.gapFromVideoUnderflow_ = function gapFromVideoUnderflow_(buffered, currentTime) {\n    // At least in Chrome, if there is a gap in the video buffer, the audio will continue\n    // playing for ~3 seconds after the video gap starts. This is done to account for\n    // video buffer underflow/underrun (note that this is not done when there is audio\n    // buffer underflow/underrun -- in that case the video will stop as soon as it\n    // encounters the gap, as audio stalls are more noticeable/jarring to a user than\n    // video stalls). The player's time will reflect the playthrough of audio, so the\n    // time will appear as if we are in a buffered region, even if we are stuck in a\n    // \"gap.\"\n    //\n    // Example:\n    // video buffer:   0 => 10.1, 10.2 => 20\n    // audio buffer:   0 => 20\n    // overall buffer: 0 => 10.1, 10.2 => 20\n    // current time: 13\n    //\n    // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\n    // however, the audio continued playing until it reached ~3 seconds past the gap\n    // (13 seconds), at which point it stops as well. Since current time is past the\n    // gap, findNextRange will return no ranges.\n    //\n    // To check for this issue, we see if there is a gap that starts somewhere within\n    // a 3 second range (3 seconds +/- 1 second) back from our current time.\n    var gaps = findGaps(buffered);\n\n    for (var i = 0; i < gaps.length; i++) {\n      var start = gaps.start(i);\n      var end = gaps.end(i); // gap is starts no more than 4 seconds back\n\n      if (currentTime - start < 4 && currentTime - start > 2) {\n        return {\n          start: start,\n          end: end\n        };\n      }\n    }\n\n    return null;\n  };\n\n  return PlaybackWatcher;\n}();\n\nvar defaultOptions = {\n  errorInterval: 30,\n  getSource: function getSource(next) {\n    var tech = this.tech({\n      IWillNotUseThisInPlugins: true\n    });\n    var sourceObj = tech.currentSource_ || this.currentSource();\n    return next(sourceObj);\n  }\n};\n/**\n * Main entry point for the plugin\n *\n * @param {Player} player a reference to a videojs Player instance\n * @param {Object} [options] an object with plugin options\n * @private\n */\n\nvar initPlugin = function initPlugin(player, options) {\n  var lastCalled = 0;\n  var seekTo = 0;\n  var localOptions = videojs$1.mergeOptions(defaultOptions, options);\n  player.ready(function () {\n    player.trigger({\n      type: 'usage',\n      name: 'vhs-error-reload-initialized'\n    });\n    player.trigger({\n      type: 'usage',\n      name: 'hls-error-reload-initialized'\n    });\n  });\n  /**\n   * Player modifications to perform that must wait until `loadedmetadata`\n   * has been triggered\n   *\n   * @private\n   */\n\n  var loadedMetadataHandler = function loadedMetadataHandler() {\n    if (seekTo) {\n      player.currentTime(seekTo);\n    }\n  };\n  /**\n   * Set the source on the player element, play, and seek if necessary\n   *\n   * @param {Object} sourceObj An object specifying the source url and mime-type to play\n   * @private\n   */\n\n\n  var setSource = function setSource(sourceObj) {\n    if (sourceObj === null || sourceObj === undefined) {\n      return;\n    }\n\n    seekTo = player.duration() !== Infinity && player.currentTime() || 0;\n    player.one('loadedmetadata', loadedMetadataHandler);\n    player.src(sourceObj);\n    player.trigger({\n      type: 'usage',\n      name: 'vhs-error-reload'\n    });\n    player.trigger({\n      type: 'usage',\n      name: 'hls-error-reload'\n    });\n    player.play();\n  };\n  /**\n   * Attempt to get a source from either the built-in getSource function\n   * or a custom function provided via the options\n   *\n   * @private\n   */\n\n\n  var errorHandler = function errorHandler() {\n    // Do not attempt to reload the source if a source-reload occurred before\n    // 'errorInterval' time has elapsed since the last source-reload\n    if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {\n      player.trigger({\n        type: 'usage',\n        name: 'vhs-error-reload-canceled'\n      });\n      player.trigger({\n        type: 'usage',\n        name: 'hls-error-reload-canceled'\n      });\n      return;\n    }\n\n    if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {\n      videojs$1.log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');\n      return;\n    }\n\n    lastCalled = Date.now();\n    return localOptions.getSource.call(player, setSource);\n  };\n  /**\n   * Unbind any event handlers that were bound by the plugin\n   *\n   * @private\n   */\n\n\n  var cleanupEvents = function cleanupEvents() {\n    player.off('loadedmetadata', loadedMetadataHandler);\n    player.off('error', errorHandler);\n    player.off('dispose', cleanupEvents);\n  };\n  /**\n   * Cleanup before re-initializing the plugin\n   *\n   * @param {Object} [newOptions] an object with plugin options\n   * @private\n   */\n\n\n  var reinitPlugin = function reinitPlugin(newOptions) {\n    cleanupEvents();\n    initPlugin(player, newOptions);\n  };\n\n  player.on('error', errorHandler);\n  player.on('dispose', cleanupEvents); // Overwrite the plugin function so that we can correctly cleanup before\n  // initializing the plugin\n\n  player.reloadSourceOnError = reinitPlugin;\n};\n/**\n * Reload the source when an error is detected as long as there\n * wasn't an error previously within the last 30 seconds\n *\n * @param {Object} [options] an object with plugin options\n */\n\n\nvar reloadSourceOnError = function reloadSourceOnError(options) {\n  initPlugin(this, options);\n}; // keep these at the bottom they are replaced at build time\n// because webpack and rollup without plugins do not support json\n// and we do not want to break our users\n\n\nvar vhsVersion = '2.2.4';\nvar muxVersion = '5.6.7';\nvar mpdVersion = '0.14.0';\nvar m3u8Version = '4.5.0';\nvar aesVersion = '3.1.0';\nvar Vhs$1 = {\n  PlaylistLoader: PlaylistLoader,\n  Playlist: Playlist,\n  utils: utils,\n  STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,\n  INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,\n  comparePlaylistBandwidth: comparePlaylistBandwidth,\n  comparePlaylistResolution: comparePlaylistResolution,\n  xhr: xhrFactory()\n}; // Define getter/setters for config properties\n\n['GOAL_BUFFER_LENGTH', 'MAX_GOAL_BUFFER_LENGTH', 'BACK_BUFFER_LENGTH', 'GOAL_BUFFER_LENGTH_RATE', 'BUFFER_LOW_WATER_LINE', 'MAX_BUFFER_LOW_WATER_LINE', 'BUFFER_LOW_WATER_LINE_RATE', 'BANDWIDTH_VARIANCE'].forEach(function (prop) {\n  Object.defineProperty(Vhs$1, prop, {\n    get: function get() {\n      videojs$1.log.warn(\"using Vhs.\" + prop + \" is UNSAFE be sure you know what you are doing\");\n      return Config[prop];\n    },\n    set: function set(value) {\n      videojs$1.log.warn(\"using Vhs.\" + prop + \" is UNSAFE be sure you know what you are doing\");\n\n      if (typeof value !== 'number' || value < 0) {\n        videojs$1.log.warn(\"value of Vhs.\" + prop + \" must be greater than or equal to 0\");\n        return;\n      }\n\n      Config[prop] = value;\n    }\n  });\n});\nvar LOCAL_STORAGE_KEY$1 = 'videojs-vhs';\n/**\n * Updates the selectedIndex of the QualityLevelList when a mediachange happens in vhs.\n *\n * @param {QualityLevelList} qualityLevels The QualityLevelList to update.\n * @param {PlaylistLoader} playlistLoader PlaylistLoader containing the new media info.\n * @function handleVhsMediaChange\n */\n\nvar handleVhsMediaChange = function handleVhsMediaChange(qualityLevels, playlistLoader) {\n  var newPlaylist = playlistLoader.media();\n  var selectedIndex = -1;\n\n  for (var i = 0; i < qualityLevels.length; i++) {\n    if (qualityLevels[i].id === newPlaylist.id) {\n      selectedIndex = i;\n      break;\n    }\n  }\n\n  qualityLevels.selectedIndex_ = selectedIndex;\n  qualityLevels.trigger({\n    selectedIndex: selectedIndex,\n    type: 'change'\n  });\n};\n/**\n * Adds quality levels to list once playlist metadata is available\n *\n * @param {QualityLevelList} qualityLevels The QualityLevelList to attach events to.\n * @param {Object} vhs Vhs object to listen to for media events.\n * @function handleVhsLoadedMetadata\n */\n\n\nvar handleVhsLoadedMetadata = function handleVhsLoadedMetadata(qualityLevels, vhs) {\n  vhs.representations().forEach(function (rep) {\n    qualityLevels.addQualityLevel(rep);\n  });\n  handleVhsMediaChange(qualityLevels, vhs.playlists);\n}; // HLS is a source handler, not a tech. Make sure attempts to use it\n// as one do not cause exceptions.\n\n\nVhs$1.canPlaySource = function () {\n  return videojs$1.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n};\n\nvar emeKeySystems = function emeKeySystems(keySystemOptions, videoPlaylist, audioPlaylist) {\n  if (!keySystemOptions) {\n    return keySystemOptions;\n  }\n\n  var codecs = {\n    video: videoPlaylist && videoPlaylist.attributes && videoPlaylist.attributes.CODECS,\n    audio: audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS\n  };\n\n  if (!codecs.audio && codecs.video && codecs.video.split(',').length > 1) {\n    codecs.video.split(',').forEach(function (codec) {\n      codec = codec.trim();\n\n      if (isAudioCodec(codec)) {\n        codecs.audio = codec;\n      } else if (isVideoCodec(codec)) {\n        codecs.video = codec;\n      }\n    });\n  }\n\n  var videoContentType = codecs.video ? \"video/mp4;codecs=\\\"\" + codecs.video + \"\\\"\" : null;\n  var audioContentType = codecs.audio ? \"audio/mp4;codecs=\\\"\" + codecs.audio + \"\\\"\" : null; // upsert the content types based on the selected playlist\n\n  var keySystemContentTypes = {};\n\n  for (var keySystem in keySystemOptions) {\n    keySystemContentTypes[keySystem] = {\n      audioContentType: audioContentType,\n      videoContentType: videoContentType\n    };\n\n    if (videoPlaylist.contentProtection && videoPlaylist.contentProtection[keySystem] && videoPlaylist.contentProtection[keySystem].pssh) {\n      keySystemContentTypes[keySystem].pssh = videoPlaylist.contentProtection[keySystem].pssh;\n    } // videojs-contrib-eme accepts the option of specifying: 'com.some.cdm': 'url'\n    // so we need to prevent overwriting the URL entirely\n\n\n    if (typeof keySystemOptions[keySystem] === 'string') {\n      keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];\n    }\n  }\n\n  return videojs$1.mergeOptions(keySystemOptions, keySystemContentTypes);\n};\n/**\n * @typedef {Object} KeySystems\n *\n * keySystems configuration for https://github.com/videojs/videojs-contrib-eme\n * Note: not all options are listed here.\n *\n * @property {Uint8Array} [pssh]\n *           Protection System Specific Header\n */\n\n/**\n * Goes through all the playlists and collects an array of KeySystems options objects\n * containing each playlist's keySystems and their pssh values, if available.\n *\n * @param {Object[]} playlists\n *        The playlists to look through\n * @param {string[]} keySystems\n *        The keySystems to collect pssh values for\n *\n * @return {KeySystems[]}\n *         An array of KeySystems objects containing available key systems and their\n *         pssh values\n */\n\n\nvar getAllPsshKeySystemsOptions = function getAllPsshKeySystemsOptions(playlists, keySystems) {\n  return playlists.reduce(function (keySystemsArr, playlist) {\n    if (!playlist.contentProtection) {\n      return keySystemsArr;\n    }\n\n    var keySystemsOptions = keySystems.reduce(function (keySystemsObj, keySystem) {\n      var keySystemOptions = playlist.contentProtection[keySystem];\n\n      if (keySystemOptions && keySystemOptions.pssh) {\n        keySystemsObj[keySystem] = {\n          pssh: keySystemOptions.pssh\n        };\n      }\n\n      return keySystemsObj;\n    }, {});\n\n    if (Object.keys(keySystemsOptions).length) {\n      keySystemsArr.push(keySystemsOptions);\n    }\n\n    return keySystemsArr;\n  }, []);\n};\n/**\n * If the [eme](https://github.com/videojs/videojs-contrib-eme) plugin is available, and\n * there are keySystems on the source, sets up source options to prepare the source for\n * eme and tries to initialize it early via eme's initializeMediaKeys API (if available).\n *\n * @param {Object} player\n *        The player instance\n * @param {Object[]} sourceKeySystems\n *        The key systems options from the player source\n * @param {Object} media\n *        The active media playlist\n * @param {Object} [audioMedia]\n *        The active audio media playlist (optional)\n * @param {Object[]} mainPlaylists\n *        The playlists found on the master playlist object\n */\n\n\nvar setupEmeOptions = function setupEmeOptions(_ref) {\n  var player = _ref.player,\n      sourceKeySystems = _ref.sourceKeySystems,\n      media = _ref.media,\n      audioMedia = _ref.audioMedia,\n      mainPlaylists = _ref.mainPlaylists;\n  var sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);\n\n  if (!sourceOptions) {\n    return;\n  }\n\n  player.currentSource().keySystems = sourceOptions; // eme handles the rest of the setup, so if it is missing\n  // do nothing.\n\n  if (sourceOptions && !player.eme) {\n    videojs$1.log.warn('DRM encrypted source cannot be decrypted without a DRM plugin');\n    return;\n  } // works around https://bugs.chromium.org/p/chromium/issues/detail?id=895449\n  // in non-IE11 browsers. In IE11 this is too early to initialize media keys\n\n\n  if (videojs$1.browser.IE_VERSION === 11 || !player.eme.initializeMediaKeys) {\n    return;\n  } // TODO should all audio PSSH values be initialized for DRM?\n  //\n  // All unique video rendition pssh values are initialized for DRM, but here only\n  // the initial audio playlist license is initialized. In theory, an encrypted\n  // event should be fired if the user switches to an alternative audio playlist\n  // where a license is required, but this case hasn't yet been tested. In addition, there\n  // may be many alternate audio playlists unlikely to be used (e.g., multiple different\n  // languages).\n\n\n  var playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;\n  var keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems)); // Since PSSH values are interpreted as initData, EME will dedupe any duplicates. The\n  // only place where it should not be deduped is for ms-prefixed APIs, but the early\n  // return for IE11 above, and the existence of modern EME APIs in addition to\n  // ms-prefixed APIs on Edge should prevent this from being a concern.\n  // initializeMediaKeys also won't use the webkit-prefixed APIs.\n\n  keySystemsOptionsArr.forEach(function (keySystemsOptions) {\n    player.eme.initializeMediaKeys({\n      keySystems: keySystemsOptions\n    });\n  });\n};\n\nvar getVhsLocalStorage = function getVhsLocalStorage() {\n  if (!window$1.localStorage) {\n    return null;\n  }\n\n  var storedObject = window$1.localStorage.getItem(LOCAL_STORAGE_KEY$1);\n\n  if (!storedObject) {\n    return null;\n  }\n\n  try {\n    return JSON.parse(storedObject);\n  } catch (e) {\n    // someone may have tampered with the value\n    return null;\n  }\n};\n\nvar updateVhsLocalStorage = function updateVhsLocalStorage(options) {\n  if (!window$1.localStorage) {\n    return false;\n  }\n\n  var objectToStore = getVhsLocalStorage();\n  objectToStore = objectToStore ? videojs$1.mergeOptions(objectToStore, options) : options;\n\n  try {\n    window$1.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(objectToStore));\n  } catch (e) {\n    // Throws if storage is full (e.g., always on iOS 5+ Safari private mode, where\n    // storage is set to 0).\n    // https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem#Exceptions\n    // No need to perform any operation.\n    return false;\n  }\n\n  return objectToStore;\n};\n/**\n * Parses VHS-supported media types from data URIs. See\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n * for information on data URIs.\n *\n * @param {string} dataUri\n *        The data URI\n *\n * @return {string|Object}\n *         The parsed object/string, or the original string if no supported media type\n *         was found\n */\n\n\nvar expandDataUri = function expandDataUri(dataUri) {\n  if (dataUri.toLowerCase().indexOf('data:application/vnd.videojs.vhs+json,') === 0) {\n    return JSON.parse(dataUri.substring(dataUri.indexOf(',') + 1));\n  } // no known case for this data URI, return the string as-is\n\n\n  return dataUri;\n};\n/**\n * Whether the browser has built-in HLS support.\n */\n\n\nVhs$1.supportsNativeHls = function () {\n  if (!document || !document.createElement) {\n    return false;\n  }\n\n  var video = document.createElement('video'); // native HLS is definitely not supported if HTML5 video isn't\n\n  if (!videojs$1.getTech('Html5').isSupported()) {\n    return false;\n  } // HLS manifests can go by many mime-types\n\n\n  var canPlay = [// Apple santioned\n  'application/vnd.apple.mpegurl', // Apple sanctioned for backwards compatibility\n  'audio/mpegurl', // Very common\n  'audio/x-mpegurl', // Very common\n  'application/x-mpegurl', // Included for completeness\n  'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\n  return canPlay.some(function (canItPlay) {\n    return /maybe|probably/i.test(video.canPlayType(canItPlay));\n  });\n}();\n\nVhs$1.supportsNativeDash = function () {\n  if (!document || !document.createElement || !videojs$1.getTech('Html5').isSupported()) {\n    return false;\n  }\n\n  return /maybe|probably/i.test(document.createElement('video').canPlayType('application/dash+xml'));\n}();\n\nVhs$1.supportsTypeNatively = function (type) {\n  if (type === 'hls') {\n    return Vhs$1.supportsNativeHls;\n  }\n\n  if (type === 'dash') {\n    return Vhs$1.supportsNativeDash;\n  }\n\n  return false;\n};\n/**\n * HLS is a source handler, not a tech. Make sure attempts to use it\n * as one do not cause exceptions.\n */\n\n\nVhs$1.isSupported = function () {\n  return videojs$1.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n};\n\nvar Component$1 = videojs$1.getComponent('Component');\n/**\n * The Vhs Handler object, where we orchestrate all of the parts\n * of HLS to interact with video.js\n *\n * @class VhsHandler\n * @extends videojs.Component\n * @param {Object} source the soruce object\n * @param {Tech} tech the parent tech object\n * @param {Object} options optional and required options\n */\n\nvar VhsHandler = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(VhsHandler, _Component);\n\n  function VhsHandler(source, tech, options) {\n    var _this;\n\n    _this = _Component.call(this, tech, videojs$1.mergeOptions(options.hls, options.vhs)) || this;\n\n    if (options.hls && Object.keys(options.hls).length) {\n      videojs$1.log.warn('Using hls options is deprecated. Use vhs instead.');\n    } // tech.player() is deprecated but setup a reference to HLS for\n    // backwards-compatibility\n\n\n    if (tech.options_ && tech.options_.playerId) {\n      var _player = videojs$1(tech.options_.playerId);\n\n      if (!_player.hasOwnProperty('hls')) {\n        Object.defineProperty(_player, 'hls', {\n          get: function get() {\n            videojs$1.log.warn('player.hls is deprecated. Use player.tech().vhs instead.');\n            tech.trigger({\n              type: 'usage',\n              name: 'hls-player-access'\n            });\n            return _assertThisInitialized(_this);\n          },\n          configurable: true\n        });\n      }\n\n      if (!_player.hasOwnProperty('vhs')) {\n        Object.defineProperty(_player, 'vhs', {\n          get: function get() {\n            videojs$1.log.warn('player.vhs is deprecated. Use player.tech().vhs instead.');\n            tech.trigger({\n              type: 'usage',\n              name: 'vhs-player-access'\n            });\n            return _assertThisInitialized(_this);\n          },\n          configurable: true\n        });\n      }\n\n      if (!_player.hasOwnProperty('dash')) {\n        Object.defineProperty(_player, 'dash', {\n          get: function get() {\n            videojs$1.log.warn('player.dash is deprecated. Use player.tech().vhs instead.');\n            return _assertThisInitialized(_this);\n          },\n          configurable: true\n        });\n      }\n\n      _this.player_ = _player;\n    }\n\n    _this.tech_ = tech;\n    _this.source_ = source;\n    _this.stats = {};\n    _this.ignoreNextSeekingEvent_ = false;\n\n    _this.setOptions_();\n\n    if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {\n      tech.overrideNativeAudioTracks(true);\n      tech.overrideNativeVideoTracks(true);\n    } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {\n      // overriding native HLS only works if audio tracks have been emulated\n      // error early if we're misconfigured\n      throw new Error('Overriding native HLS requires emulated tracks. ' + 'See https://git.io/vMpjB');\n    } // listen for fullscreenchange events for this player so that we\n    // can adjust our quality selection quickly\n\n\n    _this.on(document, ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], function (event) {\n      var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n\n      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {\n        _this.masterPlaylistController_.smoothQualityChange_();\n      }\n    });\n\n    _this.on(_this.tech_, 'seeking', function () {\n      if (this.ignoreNextSeekingEvent_) {\n        this.ignoreNextSeekingEvent_ = false;\n        return;\n      }\n\n      this.setCurrentTime(this.tech_.currentTime());\n    });\n\n    _this.on(_this.tech_, 'error', function () {\n      // verify that the error was real and we are loaded\n      // enough to have mpc loaded.\n      if (this.tech_.error() && this.masterPlaylistController_) {\n        this.masterPlaylistController_.pauseLoading();\n      }\n    });\n\n    _this.on(_this.tech_, 'play', _this.play);\n\n    return _this;\n  }\n\n  var _proto = VhsHandler.prototype;\n\n  _proto.setOptions_ = function setOptions_() {\n    var _this2 = this; // defaults\n\n\n    this.options_.withCredentials = this.options_.withCredentials || false;\n    this.options_.handleManifestRedirects = this.options_.handleManifestRedirects === false ? false : true;\n    this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;\n    this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;\n    this.options_.smoothQualityChange = this.options_.smoothQualityChange || false;\n    this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== 'undefined' ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;\n    this.options_.customTagParsers = this.options_.customTagParsers || [];\n    this.options_.customTagMappers = this.options_.customTagMappers || [];\n    this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;\n    this.options_.handlePartialData = this.options_.handlePartialData || false;\n\n    if (typeof this.options_.blacklistDuration !== 'number') {\n      this.options_.blacklistDuration = 5 * 60;\n    }\n\n    if (typeof this.options_.bandwidth !== 'number') {\n      if (this.options_.useBandwidthFromLocalStorage) {\n        var storedObject = getVhsLocalStorage();\n\n        if (storedObject && storedObject.bandwidth) {\n          this.options_.bandwidth = storedObject.bandwidth;\n          this.tech_.trigger({\n            type: 'usage',\n            name: 'vhs-bandwidth-from-local-storage'\n          });\n          this.tech_.trigger({\n            type: 'usage',\n            name: 'hls-bandwidth-from-local-storage'\n          });\n        }\n\n        if (storedObject && storedObject.throughput) {\n          this.options_.throughput = storedObject.throughput;\n          this.tech_.trigger({\n            type: 'usage',\n            name: 'vhs-throughput-from-local-storage'\n          });\n          this.tech_.trigger({\n            type: 'usage',\n            name: 'hls-throughput-from-local-storage'\n          });\n        }\n      }\n    } // if bandwidth was not set by options or pulled from local storage, start playlist\n    // selection at a reasonable bandwidth\n\n\n    if (typeof this.options_.bandwidth !== 'number') {\n      this.options_.bandwidth = Config.INITIAL_BANDWIDTH;\n    } // If the bandwidth number is unchanged from the initial setting\n    // then this takes precedence over the enableLowInitialPlaylist option\n\n\n    this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH; // grab options passed to player.src\n\n    ['withCredentials', 'useDevicePixelRatio', 'limitRenditionByPlayerDimensions', 'bandwidth', 'smoothQualityChange', 'customTagParsers', 'customTagMappers', 'handleManifestRedirects', 'cacheEncryptionKeys', 'handlePartialData'].forEach(function (option) {\n      if (typeof _this2.source_[option] !== 'undefined') {\n        _this2.options_[option] = _this2.source_[option];\n      }\n    });\n    this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;\n    this.useDevicePixelRatio = this.options_.useDevicePixelRatio;\n  }\n  /**\n   * called when player.src gets called, handle a new source\n   *\n   * @param {Object} src the source object to handle\n   */\n  ;\n\n  _proto.src = function src(_src, type) {\n    var _this3 = this; // do nothing if the src is falsey\n\n\n    if (!_src) {\n      return;\n    }\n\n    this.setOptions_(); // add master playlist controller options\n\n    this.options_.src = expandDataUri(this.source_.src);\n    this.options_.tech = this.tech_;\n    this.options_.externVhs = Vhs$1;\n    this.options_.sourceType = simpleTypeFromSourceType(type); // Whenever we seek internally, we should update the tech\n\n    this.options_.seekTo = function (time) {\n      _this3.tech_.setCurrentTime(time);\n    };\n\n    this.masterPlaylistController_ = new MasterPlaylistController(this.options_);\n    this.playbackWatcher_ = new PlaybackWatcher(videojs$1.mergeOptions(this.options_, {\n      seekable: function seekable() {\n        return _this3.seekable();\n      },\n      media: function media() {\n        return _this3.masterPlaylistController_.media();\n      },\n      masterPlaylistController: this.masterPlaylistController_\n    }));\n    this.masterPlaylistController_.on('error', function () {\n      var player = videojs$1.players[_this3.tech_.options_.playerId];\n      var error = _this3.masterPlaylistController_.error;\n\n      if (typeof error === 'object' && !error.code) {\n        error.code = 3;\n      } else if (typeof error === 'string') {\n        error = {\n          message: error,\n          code: 3\n        };\n      }\n\n      player.error(error);\n    }); // `this` in selectPlaylist should be the VhsHandler for backwards\n    // compatibility with < v2\n\n    this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : Vhs$1.STANDARD_PLAYLIST_SELECTOR.bind(this);\n    this.masterPlaylistController_.selectInitialPlaylist = Vhs$1.INITIAL_PLAYLIST_SELECTOR.bind(this); // re-expose some internal objects for backwards compatibility with < v2\n\n    this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;\n    this.mediaSource = this.masterPlaylistController_.mediaSource; // Proxy assignment of some properties to the master playlist\n    // controller. Using a custom property for backwards compatibility\n    // with < v2\n\n    Object.defineProperties(this, {\n      selectPlaylist: {\n        get: function get() {\n          return this.masterPlaylistController_.selectPlaylist;\n        },\n        set: function set(selectPlaylist) {\n          this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);\n        }\n      },\n      throughput: {\n        get: function get() {\n          return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;\n        },\n        set: function set(throughput) {\n          this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput; // By setting `count` to 1 the throughput value becomes the starting value\n          // for the cumulative average\n\n          this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;\n        }\n      },\n      bandwidth: {\n        get: function get() {\n          return this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\n        },\n        set: function set(bandwidth) {\n          this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth; // setting the bandwidth manually resets the throughput counter\n          // `count` is set to zero that current value of `rate` isn't included\n          // in the cumulative average\n\n          this.masterPlaylistController_.mainSegmentLoader_.throughput = {\n            rate: 0,\n            count: 0\n          };\n        }\n      },\n\n      /**\n       * `systemBandwidth` is a combination of two serial processes bit-rates. The first\n       * is the network bitrate provided by `bandwidth` and the second is the bitrate of\n       * the entire process after that - decryption, transmuxing, and appending - provided\n       * by `throughput`.\n       *\n       * Since the two process are serial, the overall system bandwidth is given by:\n       *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)\n       */\n      systemBandwidth: {\n        get: function get() {\n          var invBandwidth = 1 / (this.bandwidth || 1);\n          var invThroughput;\n\n          if (this.throughput > 0) {\n            invThroughput = 1 / this.throughput;\n          } else {\n            invThroughput = 0;\n          }\n\n          var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));\n          return systemBitrate;\n        },\n        set: function set() {\n          videojs$1.log.error('The \"systemBandwidth\" property is read-only');\n        }\n      }\n    });\n\n    if (this.options_.bandwidth) {\n      this.bandwidth = this.options_.bandwidth;\n    }\n\n    if (this.options_.throughput) {\n      this.throughput = this.options_.throughput;\n    }\n\n    Object.defineProperties(this.stats, {\n      bandwidth: {\n        get: function get() {\n          return _this3.bandwidth || 0;\n        },\n        enumerable: true\n      },\n      mediaRequests: {\n        get: function get() {\n          return _this3.masterPlaylistController_.mediaRequests_() || 0;\n        },\n        enumerable: true\n      },\n      mediaRequestsAborted: {\n        get: function get() {\n          return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;\n        },\n        enumerable: true\n      },\n      mediaRequestsTimedout: {\n        get: function get() {\n          return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;\n        },\n        enumerable: true\n      },\n      mediaRequestsErrored: {\n        get: function get() {\n          return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;\n        },\n        enumerable: true\n      },\n      mediaTransferDuration: {\n        get: function get() {\n          return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;\n        },\n        enumerable: true\n      },\n      mediaBytesTransferred: {\n        get: function get() {\n          return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;\n        },\n        enumerable: true\n      },\n      mediaSecondsLoaded: {\n        get: function get() {\n          return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;\n        },\n        enumerable: true\n      },\n      buffered: {\n        get: function get() {\n          return timeRangesToArray(_this3.tech_.buffered());\n        },\n        enumerable: true\n      },\n      currentTime: {\n        get: function get() {\n          return _this3.tech_.currentTime();\n        },\n        enumerable: true\n      },\n      currentSource: {\n        get: function get() {\n          return _this3.tech_.currentSource_;\n        },\n        enumerable: true\n      },\n      currentTech: {\n        get: function get() {\n          return _this3.tech_.name_;\n        },\n        enumerable: true\n      },\n      duration: {\n        get: function get() {\n          return _this3.tech_.duration();\n        },\n        enumerable: true\n      },\n      master: {\n        get: function get() {\n          return _this3.playlists.master;\n        },\n        enumerable: true\n      },\n      playerDimensions: {\n        get: function get() {\n          return _this3.tech_.currentDimensions();\n        },\n        enumerable: true\n      },\n      seekable: {\n        get: function get() {\n          return timeRangesToArray(_this3.tech_.seekable());\n        },\n        enumerable: true\n      },\n      timestamp: {\n        get: function get() {\n          return Date.now();\n        },\n        enumerable: true\n      },\n      videoPlaybackQuality: {\n        get: function get() {\n          return _this3.tech_.getVideoPlaybackQuality();\n        },\n        enumerable: true\n      }\n    });\n    this.tech_.one('canplay', this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));\n    this.tech_.on('bandwidthupdate', function () {\n      if (_this3.options_.useBandwidthFromLocalStorage) {\n        updateVhsLocalStorage({\n          bandwidth: _this3.bandwidth,\n          throughput: Math.round(_this3.throughput)\n        });\n      }\n    });\n    this.masterPlaylistController_.on('selectedinitialmedia', function () {\n      // Add the manual rendition mix-in to VhsHandler\n      renditionSelectionMixin(_this3);\n    });\n    this.masterPlaylistController_.sourceUpdater_.on('ready', function () {\n      var audioPlaylistLoader = _this3.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;\n      setupEmeOptions({\n        player: _this3.player_,\n        sourceKeySystems: _this3.source_.keySystems,\n        media: _this3.playlists.media(),\n        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),\n        mainPlaylists: _this3.playlists.master.playlists\n      });\n    }); // the bandwidth of the primary segment loader is our best\n    // estimate of overall bandwidth\n\n    this.on(this.masterPlaylistController_, 'progress', function () {\n      this.tech_.trigger('progress');\n    }); // In the live case, we need to ignore the very first `seeking` event since\n    // that will be the result of the seek-to-live behavior\n\n    this.on(this.masterPlaylistController_, 'firstplay', function () {\n      this.ignoreNextSeekingEvent_ = true;\n    });\n    this.setupQualityLevels_(); // do nothing if the tech has been disposed already\n    // this can occur if someone sets the src in player.ready(), for instance\n\n    if (!this.tech_.el()) {\n      return;\n    }\n\n    this.mediaSourceUrl_ = window$1.URL.createObjectURL(this.masterPlaylistController_.mediaSource);\n    this.tech_.src(this.mediaSourceUrl_);\n  }\n  /**\n   * Initializes the quality levels and sets listeners to update them.\n   *\n   * @method setupQualityLevels_\n   * @private\n   */\n  ;\n\n  _proto.setupQualityLevels_ = function setupQualityLevels_() {\n    var _this4 = this;\n\n    var player = videojs$1.players[this.tech_.options_.playerId]; // if there isn't a player or there isn't a qualityLevels plugin\n    // or qualityLevels_ listeners have already been setup, do nothing.\n\n    if (!player || !player.qualityLevels || this.qualityLevels_) {\n      return;\n    }\n\n    this.qualityLevels_ = player.qualityLevels();\n    this.masterPlaylistController_.on('selectedinitialmedia', function () {\n      handleVhsLoadedMetadata(_this4.qualityLevels_, _this4);\n    });\n    this.playlists.on('mediachange', function () {\n      handleVhsMediaChange(_this4.qualityLevels_, _this4.playlists);\n    });\n  }\n  /**\n   * return the version\n   */\n  ;\n\n  VhsHandler.version = function version() {\n    return {\n      '@videojs/http-streaming': vhsVersion,\n      'mux.js': muxVersion,\n      'mpd-parser': mpdVersion,\n      'm3u8-parser': m3u8Version,\n      'aes-decrypter': aesVersion\n    };\n  }\n  /**\n   * return the version\n   */\n  ;\n\n  _proto.version = function version() {\n    return this.constructor.version();\n  };\n\n  _proto.canChangeType = function canChangeType() {\n    return SourceUpdater.canChangeType();\n  }\n  /**\n   * Begin playing the video.\n   */\n  ;\n\n  _proto.play = function play() {\n    this.masterPlaylistController_.play();\n  }\n  /**\n   * a wrapper around the function in MasterPlaylistController\n   */\n  ;\n\n  _proto.setCurrentTime = function setCurrentTime(currentTime) {\n    this.masterPlaylistController_.setCurrentTime(currentTime);\n  }\n  /**\n   * a wrapper around the function in MasterPlaylistController\n   */\n  ;\n\n  _proto.duration = function duration() {\n    return this.masterPlaylistController_.duration();\n  }\n  /**\n   * a wrapper around the function in MasterPlaylistController\n   */\n  ;\n\n  _proto.seekable = function seekable() {\n    return this.masterPlaylistController_.seekable();\n  }\n  /**\n   * Abort all outstanding work and cleanup.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    if (this.playbackWatcher_) {\n      this.playbackWatcher_.dispose();\n    }\n\n    if (this.masterPlaylistController_) {\n      this.masterPlaylistController_.dispose();\n    }\n\n    if (this.qualityLevels_) {\n      this.qualityLevels_.dispose();\n    }\n\n    if (this.player_) {\n      delete this.player_.vhs;\n      delete this.player_.dash;\n      delete this.player_.hls;\n    }\n\n    if (this.tech_ && this.tech_.vhs) {\n      delete this.tech_.vhs;\n    } // don't check this.tech_.hls as it will log a deprecated warning\n\n\n    if (this.tech_) {\n      delete this.tech_.hls;\n    }\n\n    if (this.mediaSourceUrl_ && window$1.URL.revokeObjectURL) {\n      window$1.URL.revokeObjectURL(this.mediaSourceUrl_);\n      this.mediaSourceUrl_ = null;\n    }\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  _proto.convertToProgramTime = function convertToProgramTime(time, callback) {\n    return getProgramTime({\n      playlist: this.masterPlaylistController_.media(),\n      time: time,\n      callback: callback\n    });\n  } // the player must be playing before calling this\n  ;\n\n  _proto.seekToProgramTime = function seekToProgramTime$1(programTime, callback, pauseAfterSeek, retryCount) {\n    if (pauseAfterSeek === void 0) {\n      pauseAfterSeek = true;\n    }\n\n    if (retryCount === void 0) {\n      retryCount = 2;\n    }\n\n    return seekToProgramTime({\n      programTime: programTime,\n      playlist: this.masterPlaylistController_.media(),\n      retryCount: retryCount,\n      pauseAfterSeek: pauseAfterSeek,\n      seekTo: this.options_.seekTo,\n      tech: this.options_.tech,\n      callback: callback\n    });\n  };\n\n  return VhsHandler;\n}(Component$1);\n/**\n * The Source Handler object, which informs video.js what additional\n * MIME types are supported and sets up playback. It is registered\n * automatically to the appropriate tech based on the capabilities of\n * the browser it is running in. It is not necessary to use or modify\n * this object in normal usage.\n */\n\n\nvar VhsSourceHandler = {\n  name: 'videojs-http-streaming',\n  VERSION: vhsVersion,\n  canHandleSource: function canHandleSource(srcObj, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var localOptions = videojs$1.mergeOptions(videojs$1.options, options);\n    return VhsSourceHandler.canPlayType(srcObj.type, localOptions);\n  },\n  handleSource: function handleSource(source, tech, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var localOptions = videojs$1.mergeOptions(videojs$1.options, options);\n    tech.vhs = new VhsHandler(source, tech, localOptions);\n\n    if (!videojs$1.hasOwnProperty('hls')) {\n      Object.defineProperty(tech, 'hls', {\n        get: function get() {\n          videojs$1.log.warn('player.tech().hls is deprecated. Use player.tech().vhs instead.');\n          return tech.vhs;\n        },\n        configurable: true\n      });\n    }\n\n    tech.vhs.xhr = xhrFactory();\n    tech.vhs.src(source.src, source.type);\n    return tech.vhs;\n  },\n  canPlayType: function canPlayType(type, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _videojs$mergeOptions = videojs$1.mergeOptions(videojs$1.options, options),\n        _videojs$mergeOptions2 = _videojs$mergeOptions.vhs.overrideNative,\n        overrideNative = _videojs$mergeOptions2 === void 0 ? !videojs$1.browser.IS_ANY_SAFARI : _videojs$mergeOptions2;\n\n    var supportedType = simpleTypeFromSourceType(type);\n    var canUseMsePlayback = supportedType && (!Vhs$1.supportsTypeNatively(supportedType) || overrideNative);\n    return canUseMsePlayback ? 'maybe' : '';\n  }\n};\n/**\n * Check to see if the native MediaSource object exists and supports\n * an MP4 container with both H.264 video and AAC-LC audio.\n *\n * @return {boolean} if  native media sources are supported\n */\n\nvar supportsNativeMediaSources = function supportsNativeMediaSources() {\n  return browserSupportsCodec('avc1.4d400d,mp4a.40.2');\n}; // register source handlers with the appropriate techs\n\n\nif (supportsNativeMediaSources()) {\n  videojs$1.getTech('Html5').registerSourceHandler(VhsSourceHandler, 0);\n}\n\nvideojs$1.VhsHandler = VhsHandler;\nObject.defineProperty(videojs$1, 'HlsHandler', {\n  get: function get() {\n    videojs$1.log.warn('videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead.');\n    return VhsHandler;\n  },\n  configurable: true\n});\nvideojs$1.VhsSourceHandler = VhsSourceHandler;\nObject.defineProperty(videojs$1, 'HlsSourceHandler', {\n  get: function get() {\n    videojs$1.log.warn('videojs.HlsSourceHandler is deprecated. ' + 'Use videojs.VhsSourceHandler instead.');\n    return VhsSourceHandler;\n  },\n  configurable: true\n});\nvideojs$1.Vhs = Vhs$1;\nObject.defineProperty(videojs$1, 'Hls', {\n  get: function get() {\n    videojs$1.log.warn('videojs.Hls is deprecated. Use videojs.Vhs instead.');\n    return Vhs$1;\n  },\n  configurable: true\n});\n\nif (!videojs$1.use) {\n  videojs$1.registerComponent('Hls', Vhs$1);\n  videojs$1.registerComponent('Vhs', Vhs$1);\n}\n\nvideojs$1.options.vhs = videojs$1.options.vhs || {};\nvideojs$1.options.hls = videojs$1.options.hls || {};\n\nif (videojs$1.registerPlugin) {\n  videojs$1.registerPlugin('reloadSourceOnError', reloadSourceOnError);\n} else {\n  videojs$1.plugin('reloadSourceOnError', reloadSourceOnError);\n}\n\nexport default videojs$1;"],"sourceRoot":""}